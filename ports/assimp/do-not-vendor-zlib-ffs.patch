diff --git a/CMakeLists.txt b/CMakeLists.txt
index 458a32834..ec8d293cf 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -467,53 +467,12 @@ IF( ASSIMP_BUILD_DOCS )
 ENDIF()
 
 # Search for external dependencies, and build them from source if not found
-# Search for zlib
-IF(ASSIMP_HUNTER_ENABLED)
-  hunter_add_package(ZLIB)
-  find_package(ZLIB CONFIG REQUIRED)
 
-  add_definitions(-DASSIMP_BUILD_NO_OWN_ZLIB)
-  set(ZLIB_FOUND TRUE)
-  set(ZLIB_LIBRARIES ZLIB::zlib)
-  set(ASSIMP_BUILD_MINIZIP TRUE)
-ELSE()
-  # If the zlib is already found outside, add an export in case assimpTargets can't find it.
-  IF( ZLIB_FOUND )
-    INSTALL( TARGETS zlib zlibstatic
-        EXPORT "${TARGETS_EXPORT_NAME}")
-  ENDIF()
-
-  IF ( NOT ASSIMP_BUILD_ZLIB )
-    FIND_PACKAGE(ZLIB)
-  ENDIF()
-
-  IF( NOT ZLIB_FOUND )
-    MESSAGE(STATUS "compiling zlib from sources")
-    INCLUDE(CheckIncludeFile)
-    INCLUDE(CheckTypeSize)
-    INCLUDE(CheckFunctionExists)
-
-    # Explicitly turn off ASM686 and AMD64 cmake options.
-    # The AMD64 option causes a build failure on MSVC and the ASM builds seem to have problems:
-    #		https://github.com/madler/zlib/issues/41#issuecomment-125848075
-    # Also prevents these options from "polluting" the cmake options if assimp is being
-    # included as a submodule.
-    set( ASM686 FALSE CACHE INTERNAL "Override ZLIB flag to turn off assembly" FORCE )
-    set( AMD64 FALSE CACHE INTERNAL "Override ZLIB flag to turn off assembly" FORCE )
-
-    # compile from sources
-    ADD_SUBDIRECTORY(contrib/zlib)
-    SET(ZLIB_FOUND 1)
-    SET(ZLIB_LIBRARIES zlibstatic)
-    SET(ZLIB_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/contrib/zlib ${CMAKE_CURRENT_BINARY_DIR}/contrib/zlib)
-    # need to ensure we don't link with system zlib or minizip as well.
-    SET(ASSIMP_BUILD_MINIZIP 1)
-  ELSE()
-    ADD_DEFINITIONS(-DASSIMP_BUILD_NO_OWN_ZLIB)
-    SET(ZLIB_LIBRARIES_LINKED -lz)
-  ENDIF()
-  INCLUDE_DIRECTORIES(${ZLIB_INCLUDE_DIR})
-ENDIF()
+find_package(zlib CONFIG REQUIRED)
+add_definitions(-DASSIMP_BUILD_NO_OWN_ZLIB)
+set(ZLIB_FOUND TRUE)
+set(ZLIB_LIBRARIES zlib)
+set(ASSIMP_BUILD_MINIZIP TRUE)
 
 IF( NOT IOS )
   IF( NOT ASSIMP_BUILD_MINIZIP )
diff --git a/code/AssetLib/Assbin/AssbinFileWriter.cpp b/code/AssetLib/Assbin/AssbinFileWriter.cpp
index 97be634de..003b4b0ef 100644
--- a/code/AssetLib/Assbin/AssbinFileWriter.cpp
+++ b/code/AssetLib/Assbin/AssbinFileWriter.cpp
@@ -51,7 +51,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <assimp/IOStream.hpp>
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include "../contrib/zlib/zlib.h"
 #endif
diff --git a/code/AssetLib/Assbin/AssbinLoader.cpp b/code/AssetLib/Assbin/AssbinLoader.cpp
index f7b35636c..5175d007d 100644
--- a/code/AssetLib/Assbin/AssbinLoader.cpp
+++ b/code/AssetLib/Assbin/AssbinLoader.cpp
@@ -58,7 +58,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <memory>
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include <contrib/zlib/zlib.h>
 #endif
diff --git a/code/AssetLib/Assxml/AssxmlFileWriter.cpp b/code/AssetLib/Assxml/AssxmlFileWriter.cpp
index a443e3fe9..3e49fe3de 100644
--- a/code/AssetLib/Assxml/AssxmlFileWriter.cpp
+++ b/code/AssetLib/Assxml/AssxmlFileWriter.cpp
@@ -56,7 +56,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdarg.h>
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include <contrib/zlib/zlib.h>
 #endif
diff --git a/code/AssetLib/Blender/BlenderLoader.cpp b/code/AssetLib/Blender/BlenderLoader.cpp
index 9322369eb..6a7e8cf24 100644
--- a/code/AssetLib/Blender/BlenderLoader.cpp
+++ b/code/AssetLib/Blender/BlenderLoader.cpp
@@ -68,7 +68,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef ASSIMP_BUILD_NO_COMPRESSED_BLEND
 #include "Common/Compression.h"
 /* #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#    include <zlib.h>
+#    include <zlib/zlib.h>
 #  else
 #    include "../contrib/zlib/zlib.h"
 #  endif*/
diff --git a/code/AssetLib/FBX/FBXParser.cpp b/code/AssetLib/FBX/FBXParser.cpp
index da6d3889a..c913cb9f8 100644
--- a/code/AssetLib/FBX/FBXParser.cpp
+++ b/code/AssetLib/FBX/FBXParser.cpp
@@ -47,7 +47,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 //#ifdef ASSIMP_BUILD_NO_OWN_ZLIB
 #include "Common/Compression.h"
-//#   include <zlib.h>
+//#   include <zlib/zlib.h>
 //#else
 //#   include "../contrib/zlib/zlib.h"
 //#endif
diff --git a/code/AssetLib/Q3BSP/Q3BSPFileImporter.cpp b/code/AssetLib/Q3BSP/Q3BSPFileImporter.cpp
index 30f281a44..0a9162734 100644
--- a/code/AssetLib/Q3BSP/Q3BSPFileImporter.cpp
+++ b/code/AssetLib/Q3BSP/Q3BSPFileImporter.cpp
@@ -49,7 +49,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <assimp/DefaultLogger.hpp>
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include "../contrib/zlib/zlib.h"
 #endif
diff --git a/code/Common/Compression.h b/code/Common/Compression.h
index edf1d232f..714256923 100644
--- a/code/Common/Compression.h
+++ b/code/Common/Compression.h
@@ -42,7 +42,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #pragma once
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include "../contrib/zlib/zlib.h"
 #endif
diff --git a/contrib/unzip/crypt.c b/contrib/unzip/crypt.c
index 4cc731b3e..faca085f5 100644
--- a/contrib/unzip/crypt.c
+++ b/contrib/unzip/crypt.c
@@ -39,7 +39,7 @@
 #  include <unistd.h>
 #endif
 
-#include "zlib.h"
+#include <zlib/zlib.h>
 
 #include "crypt.h"
 
diff --git a/contrib/unzip/ioapi.h b/contrib/unzip/ioapi.h
index 0e49543e5..a4ba107cd 100644
--- a/contrib/unzip/ioapi.h
+++ b/contrib/unzip/ioapi.h
@@ -18,7 +18,7 @@
 #include <stdlib.h>
 #include <stdint.h>
 
-#include "zlib.h"
+#include <zlib/zlib.h>
 
 #if defined(USE_FILE32API)
 #   define fopen64 fopen
diff --git a/contrib/unzip/unzip.c b/contrib/unzip/unzip.c
index b2f045b0a..5db40f063 100644
--- a/contrib/unzip/unzip.c
+++ b/contrib/unzip/unzip.c
@@ -22,7 +22,7 @@
 #include <string.h>
 #include <errno.h>
 
-#include "zlib.h"
+#include <zlib/zlib.h>
 #include "unzip.h"
 
 #ifdef HAVE_AES
diff --git a/contrib/unzip/unzip.h b/contrib/unzip/unzip.h
index ea4c90a4d..58b5b5644 100644
--- a/contrib/unzip/unzip.h
+++ b/contrib/unzip/unzip.h
@@ -22,7 +22,7 @@ extern "C" {
 #endif
 
 #ifndef _ZLIB_H
-#include "zlib.h"
+#include <zlib/zlib.h>
 #endif
 
 #ifndef _ZLIBIOAPI_H
diff --git a/contrib/zlib/CMakeLists.txt b/contrib/zlib/CMakeLists.txt
deleted file mode 100644
index 469151ff6..000000000
--- a/contrib/zlib/CMakeLists.txt
+++ /dev/null
@@ -1,206 +0,0 @@
-cmake_minimum_required(VERSION 3.10.0)
-set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
-
-# CMake 3.0 changed the project command, setting policy CMP0048 reverts to the old behaviour.
-# See http://www.cmake.org/cmake/help/v3.0/policy/CMP0048.html
-cmake_policy(PUSH)
-if(CMAKE_MAJOR_VERSION GREATER 2)
-	cmake_policy(SET CMP0048 NEW)
-endif()
-project(zlib C)
-SET (ZLIB_VERSION_MAJOR 1)
-SET (ZLIB_VERSION_MINOR 2)
-SET (ZLIB_VERSION_PATCH 11)
-SET (ZLIB_VERSION ${ZLIB_VERSION_MAJOR}.${ZLIB_VERSION_MINOR}.${ZLIB_VERSION_PATCH})
-SET (ZLIB_SOVERSION 1)
-SET (PROJECT_VERSION "${ZLIB_VERSION}")
-cmake_policy(POP)
-
-
-option(ASM686 "Enable building i686 assembly implementation")
-option(AMD64 "Enable building amd64 assembly implementation")
-
-#set(INSTALL_BIN_DIR "${CMAKE_INSTALL_PREFIX}/bin" CACHE PATH "Installation directory for executables")
-#set(INSTALL_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib" CACHE PATH "Installation directory for libraries")
-#set(INSTALL_INC_DIR "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "Installation directory for headers")
-#set(INSTALL_MAN_DIR "${CMAKE_INSTALL_PREFIX}/share/man" CACHE PATH "Installation directory for manual pages")
-#set(INSTALL_PKGCONFIG_DIR "${CMAKE_INSTALL_PREFIX}/share/pkgconfig" CACHE PATH "Installation directory for pkgconfig (.pc) files")
-
-include(CheckTypeSize)
-include(CheckFunctionExists)
-include(CheckIncludeFile)
-include(CheckCSourceCompiles)
-enable_testing()
-
-check_include_file(sys/types.h HAVE_SYS_TYPES_H)
-check_include_file(stdint.h    HAVE_STDINT_H)
-check_include_file(stddef.h    HAVE_STDDEF_H)
-
-#
-# Check to see if we have large file support
-#
-set(CMAKE_REQUIRED_DEFINITIONS -D_LARGEFILE64_SOURCE=1)
-# We add these other definitions here because CheckTypeSize.cmake
-# in CMake 2.4.x does not automatically do so and we want
-# compatibility with CMake 2.4.x.
-if(HAVE_SYS_TYPES_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_SYS_TYPES_H)
-endif()
-if(HAVE_STDINT_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDINT_H)
-endif()
-if(HAVE_STDDEF_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDDEF_H)
-endif()
-check_type_size(off64_t OFF64_T)
-if(HAVE_OFF64_T)
-   add_definitions(-D_LARGEFILE64_SOURCE=1)
-endif()
-set(CMAKE_REQUIRED_DEFINITIONS) # clear variable
-
-#
-# Check for fseeko
-#
-check_function_exists(fseeko HAVE_FSEEKO)
-if(NOT HAVE_FSEEKO)
-    add_definitions(-DNO_FSEEKO)
-endif()
-
-#
-# Check for unistd.h
-#
-check_include_file(unistd.h Z_HAVE_UNISTD_H)
-
-if(MSVC)
-    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /wd4131 /wd4127 /wd4244")
-    set(CMAKE_DEBUG_POSTFIX "d")
-    add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
-    add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)
-    include_directories(${CMAKE_CURRENT_SOURCE_DIR})
-endif()
-
-if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)
-    # If we're doing an out of source build and the user has a zconf.h
-    # in their source tree...
-    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h)
-        message(STATUS "Renaming")
-        message(STATUS "    ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h")
-        message(STATUS "to 'zconf.h.included' because this file is included with zlib")
-        message(STATUS "but CMake generates it automatically in the build directory.")
-        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.included)
-  endif()
-endif()
-
-set(ZLIB_PC ${CMAKE_CURRENT_BINARY_DIR}/zlib.pc)
-configure_file( ${CMAKE_CURRENT_SOURCE_DIR}/zlib.pc.cmakein
-		${ZLIB_PC} @ONLY)
-configure_file(	${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.cmakein
-		${CMAKE_CURRENT_BINARY_DIR}/zconf.h @ONLY)
-include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR})
-
-
-#============================================================================
-# zlib
-#============================================================================
-
-set(ZLIB_PUBLIC_HDRS
-    ${CMAKE_CURRENT_BINARY_DIR}/zconf.h
-    zlib.h
-)
-set(ZLIB_PRIVATE_HDRS
-    crc32.h
-    deflate.h
-    gzguts.h
-    inffast.h
-    inffixed.h
-    inflate.h
-    inftrees.h
-    trees.h
-    zutil.h
-)
-set(ZLIB_SRCS
-    adler32.c
-    compress.c
-    crc32.c
-    deflate.c
-    gzclose.c
-    gzlib.c
-    gzread.c
-    gzwrite.c
-    inflate.c
-    infback.c
-    inftrees.c
-    inffast.c
-    trees.c
-    uncompr.c
-    zutil.c
-)
-
-if(NOT MINGW)
-    set(ZLIB_DLL_SRCS
-        win32/zlib1.rc # If present will override custom build rule below.
-    )
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCC)
-    if(ASM686)
-        set(ZLIB_ASMS contrib/asm686/match.S)
-    elseif (AMD64)
-        set(ZLIB_ASMS contrib/amd64/amd64-match.S)
-    endif ()
-
-	if(ZLIB_ASMS)
-		add_definitions(-DASMV)
-		set_source_files_properties(${ZLIB_ASMS} PROPERTIES LANGUAGE C COMPILE_FLAGS -DNO_UNDERLINE)
-	endif()
-endif()
-
-if(MSVC)
-    if(ASM686)
-		ENABLE_LANGUAGE(ASM_MASM)
-        set(ZLIB_ASMS
-			contrib/masmx86/inffas32.asm
-			contrib/masmx86/match686.asm
-		)
-    elseif (AMD64)
-		ENABLE_LANGUAGE(ASM_MASM)
-        set(ZLIB_ASMS
-			contrib/masmx64/gvmat64.asm
-			contrib/masmx64/inffasx64.asm
-		)
-    endif()
-
-	if(ZLIB_ASMS)
-		add_definitions(-DASMV -DASMINF)
-	endif()
-endif()
-
-# parse the full version number from zlib.h and include in ZLIB_FULL_VERSION
-file(READ ${CMAKE_CURRENT_SOURCE_DIR}/zlib.h _zlib_h_contents)
-string(REGEX REPLACE ".*#define[ \t]+ZLIB_VERSION[ \t]+\"([-0-9A-Za-z.]+)\".*"
-    "\\1" ZLIB_FULL_VERSION ${_zlib_h_contents})
-
-if(MINGW)
-    # This gets us DLL resource information when compiling on MinGW.
-    if(NOT CMAKE_RC_COMPILER)
-        set(CMAKE_RC_COMPILER windres.exe)
-    endif()
-
-    add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj
-                       COMMAND ${CMAKE_RC_COMPILER}
-                            -D GCC_WINDRES
-                            -I ${CMAKE_CURRENT_SOURCE_DIR}
-                            -I ${CMAKE_CURRENT_BINARY_DIR}
-                            -o ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj
-                            -i ${CMAKE_CURRENT_SOURCE_DIR}/win32/zlib1.rc)
-    set(ZLIB_DLL_SRCS ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj)
-endif(MINGW)
-
-add_library(zlibstatic STATIC ${ZLIB_SRCS} ${ZLIB_ASMS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})
-
-INSTALL( TARGETS zlibstatic
-     EXPORT "${TARGETS_EXPORT_NAME}"
-     LIBRARY DESTINATION ${ASSIMP_LIB_INSTALL_DIR}
-     ARCHIVE DESTINATION ${ASSIMP_LIB_INSTALL_DIR}
-     RUNTIME DESTINATION ${ASSIMP_BIN_INSTALL_DIR}
-     COMPONENT ${LIBASSIMP_COMPONENT})
diff --git a/contrib/zlib/README b/contrib/zlib/README
deleted file mode 100644
index 41777d06d..000000000
--- a/contrib/zlib/README
+++ /dev/null
@@ -1,115 +0,0 @@
-ZLIB DATA COMPRESSION LIBRARY
-
-zlib 1.2.11.1 is a general purpose data compression library.  All the code is
-thread safe.  The data format used by the zlib library is described by RFCs
-(Request for Comments) 1950 to 1952 in the files
-http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and
-rfc1952 (gzip format).
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example
-of the library is given in the file test/example.c which also tests that
-the library is working correctly.  Another example is given in the file
-test/minigzip.c.  The compression library itself is composed of all source
-files in the root directory.
-
-To compile all files and run the test program, follow the instructions given at
-the top of Makefile.in.  In short "./configure; make test", and if that goes
-well, "make install" should work for most flavors of Unix.  For Windows, use
-one of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use
-make_vms.com.
-
-Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant
-<info@winimage.com> for the Windows DLL version.  The zlib home page is
-http://zlib.net/ .  Before reporting a problem, please check this site to
-verify that you have the latest version of zlib; otherwise get the latest
-version and check whether the problem still exists or not.
-
-PLEASE read the zlib FAQ http://zlib.net/zlib_faq.html before asking for help.
-
-Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan.  1997
-issue of Dr.  Dobb's Journal; a copy of the article is available at
-http://marknelson.us/1997/01/01/zlib-engine/ .
-
-The changes made in version 1.2.11.1 are documented in the file ChangeLog.
-
-Unsupported third party contributions are provided in directory contrib/ .
-
-zlib is available in Java using the java.util.zip package, documented at
-http://java.sun.com/developer/technicalArticles/Programming/compression/ .
-
-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is available
-at CPAN (Comprehensive Perl Archive Network) sites, including
-http://search.cpan.org/~pmqs/IO-Compress-Zlib/ .
-
-A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is
-available in Python 1.5 and later versions, see
-http://docs.python.org/library/zlib.html .
-
-zlib is built into tcl: http://wiki.tcl.tk/4610 .
-
-An experimental package to read and write files in .zip format, written on top
-of zlib by Gilles Vollant <info@winimage.com>, is available in the
-contrib/minizip directory of zlib.
-
-
-Notes for some targets:
-
-- For Windows DLL versions, please see win32/DLL_FAQ.txt
-
-- For 64-bit Irix, deflate.c must be compiled without any optimization. With
-  -O, one libpng test fails. The test works in 32 bit mode (with the -n32
-  compiler flag). The compiler bug has been reported to SGI.
-
-- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works
-  when compiled with cc.
-
-- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is
-  necessary to get gzprintf working correctly. This is done by configure.
-
-- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with
-  other compilers. Use "make test" to check your compiler.
-
-- gzdopen is not supported on RISCOS or BEOS.
-
-- For PalmOs, see http://palmzlib.sourceforge.net/
-
-
-Acknowledgments:
-
-  The deflate format used by zlib was defined by Phil Katz.  The deflate and
-  zlib specifications were written by L.  Peter Deutsch.  Thanks to all the
-  people who reported problems and suggested various improvements in zlib; they
-  are too numerous to cite here.
-
-Copyright notice:
-
- (C) 1995-2017 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not* receiving
-lengthy legal documents to sign.  The sources are provided for free but without
-warranty of any kind.  The library has been entirely written by Jean-loup
-Gailly and Mark Adler; it does not include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include in
-the file ChangeLog history information documenting your changes.  Please read
-the FAQ for more information on the distribution of modified source versions.
diff --git a/contrib/zlib/adler32.c b/contrib/zlib/adler32.c
deleted file mode 100644
index d0be4380a..000000000
--- a/contrib/zlib/adler32.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-2011, 2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zutil.h"
-
-local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));
-
-#define BASE 65521U     /* largest prime smaller than 65536 */
-#define NMAX 5552
-/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
-
-#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* use NO_DIVIDE if your processor does not do division in hardware --
-   try it both ways to see which is faster */
-#ifdef NO_DIVIDE
-/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
-   (thank you to John Reiser for pointing this out) */
-#  define CHOP(a) \
-    do { \
-        unsigned long tmp = a >> 16; \
-        a &= 0xffffUL; \
-        a += (tmp << 4) - tmp; \
-    } while (0)
-#  define MOD28(a) \
-    do { \
-        CHOP(a); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#  define MOD(a) \
-    do { \
-        CHOP(a); \
-        MOD28(a); \
-    } while (0)
-#  define MOD63(a) \
-    do { /* this assumes a is not negative */ \
-        z_off64_t tmp = a >> 32; \
-        a &= 0xffffffffL; \
-        a += (tmp << 8) - (tmp << 5) + tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#else
-#  define MOD(a) a %= BASE
-#  define MOD28(a) a %= BASE
-#  define MOD63(a) a %= BASE
-#endif
-
-/* ========================================================================= */
-uLong ZEXPORT adler32_z(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    z_size_t len;
-{
-    unsigned long sum2;
-    unsigned n;
-
-    /* split Adler-32 into component sums */
-    sum2 = (adler >> 16) & 0xffff;
-    adler &= 0xffff;
-
-    /* in case user likes doing a byte at a time, keep it fast */
-    if (len == 1) {
-        adler += buf[0];
-        if (adler >= BASE)
-            adler -= BASE;
-        sum2 += adler;
-        if (sum2 >= BASE)
-            sum2 -= BASE;
-        return adler | (sum2 << 16);
-    }
-
-    /* initial Adler-32 value (deferred check for len == 1 speed) */
-    if (buf == Z_NULL)
-        return 1L;
-
-    /* in case short lengths are provided, keep it somewhat fast */
-    if (len < 16) {
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        if (adler >= BASE)
-            adler -= BASE;
-        MOD28(sum2);            /* only added so many BASE's */
-        return adler | (sum2 << 16);
-    }
-
-    /* do length NMAX blocks -- requires just one modulo operation */
-    while (len >= NMAX) {
-        len -= NMAX;
-        n = NMAX / 16;          /* NMAX is divisible by 16 */
-        do {
-            DO16(buf);          /* 16 sums unrolled */
-            buf += 16;
-        } while (--n);
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* do remaining bytes (less than NMAX, still just one modulo) */
-    if (len) {                  /* avoid modulos if none remaining */
-        while (len >= 16) {
-            len -= 16;
-            DO16(buf);
-            buf += 16;
-        }
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* return recombined sums */
-    return adler | (sum2 << 16);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
-{
-    return adler32_z(adler, buf, len);
-}
-
-/* ========================================================================= */
-local uLong adler32_combine_(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* for negative len, return invalid adler32 as a clue for debugging */
-    if (len2 < 0)
-        return 0xffffffffUL;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    MOD63(len2);                /* assumes len2 >= 0 */
-    rem = (unsigned)len2;
-    sum1 = adler1 & 0xffff;
-    sum2 = rem * sum1;
-    MOD(sum2);
-    sum1 += (adler2 & 0xffff) + BASE - 1;
-    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
-    if (sum2 >= BASE) sum2 -= BASE;
-    return sum1 | (sum2 << 16);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
-
-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
diff --git a/contrib/zlib/compress.c b/contrib/zlib/compress.c
deleted file mode 100644
index e2db404ab..000000000
--- a/contrib/zlib/compress.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-    const uInt max = (uInt)-1;
-    uLong left;
-
-    left = *destLen;
-    *destLen = 0;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-
-    stream.next_out = dest;
-    stream.avail_out = 0;
-    stream.next_in = (z_const Bytef *)source;
-    stream.avail_in = 0;
-
-    do {
-        if (stream.avail_out == 0) {
-            stream.avail_out = left > (uLong)max ? max : (uInt)left;
-            left -= stream.avail_out;
-        }
-        if (stream.avail_in == 0) {
-            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
-            sourceLen -= stream.avail_in;
-        }
-        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
-    } while (err == Z_OK);
-
-    *destLen = stream.total_out;
-    deflateEnd(&stream);
-    return err == Z_STREAM_END ? Z_OK : err;
-}
-
-/* ===========================================================================
- */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound (sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13;
-}
diff --git a/contrib/zlib/contrib/README.contrib b/contrib/zlib/contrib/README.contrib
deleted file mode 100644
index a411d5c39..000000000
--- a/contrib/zlib/contrib/README.contrib
+++ /dev/null
@@ -1,78 +0,0 @@
-All files under this contrib directory are UNSUPPORTED. There were
-provided by users of zlib and were not tested by the authors of zlib.
-Use at your own risk. Please contact the authors of the contributions
-for help about these, not the zlib authors. Thanks.
-
-
-ada/        by Dmitriy Anisimkov <anisimkov@yahoo.com>
-        Support for Ada
-        See http://zlib-ada.sourceforge.net/
-
-amd64/      by Mikhail Teterin <mi@ALDAN.algebra.com>
-        asm code for AMD64
-        See patch at http://www.freebsd.org/cgi/query-pr.cgi?pr=bin/96393
-
-asm686/     by Brian Raiter <breadbox@muppetlabs.com>
-        asm code for Pentium and PPro/PII, using the AT&T (GNU as) syntax
-        See http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-blast/      by Mark Adler <madler@alumni.caltech.edu>
-        Decompressor for output of PKWare Data Compression Library (DCL)
-
-delphi/     by Cosmin Truta <cosmint@cs.ubbcluj.ro>
-        Support for Delphi and C++ Builder
-
-dotzlib/    by Henrik Ravn <henrik@ravn.com>
-        Support for Microsoft .Net and Visual C++ .Net
-
-gcc_gvmat64/by Gilles Vollant <info@winimage.com>
-        GCC Version of x86 64-bit (AMD64 and Intel EM64t) code for x64
-        assembler to replace longest_match() and inflate_fast()
-
-infback9/   by Mark Adler <madler@alumni.caltech.edu>
-        Unsupported diffs to infback to decode the deflate64 format
-
-inflate86/  by Chris Anderson <christop@charm.net>
-        Tuned x86 gcc asm code to replace inflate_fast()
-
-iostream/   by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-
-iostream2/  by Tyge Løvset <Tyge.Lovset@cmr.no>
-        Another C++ I/O streams interface
-
-iostream3/  by Ludwig Schwardt <schwardt@sun.ac.za>
-            and Kevin Ruland <kevin@rodin.wustl.edu>
-        Yet another C++ I/O streams interface
-
-masmx64/    by Gilles Vollant <info@winimage.com>
-        x86 64-bit (AMD64 and Intel EM64t) code for x64 assembler to
-        replace longest_match() and inflate_fast(),  also masm x86
-        64-bits translation of Chris Anderson inflate_fast()
-
-masmx86/    by Gilles Vollant <info@winimage.com>
-        x86 asm code to replace longest_match() and inflate_fast(),
-        for Visual C++ and MASM (32 bits).
-        Based on Brian Raiter (asm686) and Chris Anderson (inflate86)
-
-minizip/    by Gilles Vollant <info@winimage.com>
-        Mini zip and unzip based on zlib
-        Includes Zip64 support by Mathias Svensson <mathias@result42.com>
-        See http://www.winimage.com/zLibDll/minizip.html
-
-pascal/     by Bob Dellaca <bobdl@xtra.co.nz> et al.
-        Support for Pascal
-
-puff/       by Mark Adler <madler@alumni.caltech.edu>
-        Small, low memory usage inflate.  Also serves to provide an
-        unambiguous description of the deflate format.
-
-testzlib/   by Gilles Vollant <info@winimage.com>
-        Example of the use of zlib
-
-untgz/      by Pedro A. Aranda Gutierrez <paag@tid.es>
-        A very simple tar.gz file extractor using zlib
-
-vstudio/    by Gilles Vollant <info@winimage.com>
-        Building a minizip-enhanced zlib with Microsoft Visual Studio
-        Includes vc11 from kreuzerkrieg and vc12 from davispuh
diff --git a/contrib/zlib/contrib/ada/buffer_demo.adb b/contrib/zlib/contrib/ada/buffer_demo.adb
deleted file mode 100644
index 46b863810..000000000
--- a/contrib/zlib/contrib/ada/buffer_demo.adb
+++ /dev/null
@@ -1,106 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---
---  $Id: buffer_demo.adb,v 1.3 2004/09/06 06:55:35 vagul Exp $
-
---  This demo program provided by Dr Steve Sangwine <sjs@essex.ac.uk>
---
---  Demonstration of a problem with Zlib-Ada (already fixed) when a buffer
---  of exactly the correct size is used for decompressed data, and the last
---  few bytes passed in to Zlib are checksum bytes.
-
---  This program compresses a string of text, and then decompresses the
---  compressed text into a buffer of the same size as the original text.
-
-with Ada.Streams; use Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib; use ZLib;
-
-procedure Buffer_Demo is
-   EOL  : Character renames ASCII.LF;
-   Text : constant String
-     := "Four score and seven years ago our fathers brought forth," & EOL &
-        "upon this continent, a new nation, conceived in liberty," & EOL &
-        "and dedicated to the proposition that `all men are created equal'.";
-
-   Source : Stream_Element_Array (1 .. Text'Length);
-   for Source'Address use Text'Address;
-
-begin
-   Ada.Text_IO.Put (Text);
-   Ada.Text_IO.New_Line;
-   Ada.Text_IO.Put_Line
-     ("Uncompressed size : " & Positive'Image (Text'Length) & " bytes");
-
-   declare
-      Compressed_Data : Stream_Element_Array (1 .. Text'Length);
-      L               : Stream_Element_Offset;
-   begin
-      Compress : declare
-         Compressor : Filter_Type;
-         I : Stream_Element_Offset;
-      begin
-         Deflate_Init (Compressor);
-
-         --  Compress the whole of T at once.
-
-         Translate (Compressor, Source, I, Compressed_Data, L, Finish);
-         pragma Assert (I = Source'Last);
-
-         Close (Compressor);
-
-         Ada.Text_IO.Put_Line
-           ("Compressed size :   "
-            & Stream_Element_Offset'Image (L) & " bytes");
-      end Compress;
-
-      --  Now we decompress the data, passing short blocks of data to Zlib
-      --  (because this demonstrates the problem - the last block passed will
-      --  contain checksum information and there will be no output, only a
-      --  check inside Zlib that the checksum is correct).
-
-      Decompress : declare
-         Decompressor : Filter_Type;
-
-         Uncompressed_Data : Stream_Element_Array (1 .. Text'Length);
-
-         Block_Size : constant := 4;
-         --  This makes sure that the last block contains
-         --  only Adler checksum data.
-
-         P : Stream_Element_Offset := Compressed_Data'First - 1;
-         O : Stream_Element_Offset;
-      begin
-         Inflate_Init (Decompressor);
-
-         loop
-            Translate
-              (Decompressor,
-               Compressed_Data
-                 (P + 1 .. Stream_Element_Offset'Min (P + Block_Size, L)),
-               P,
-               Uncompressed_Data
-                 (Total_Out (Decompressor) + 1 .. Uncompressed_Data'Last),
-               O,
-               No_Flush);
-
-               Ada.Text_IO.Put_Line
-                 ("Total in : " & Count'Image (Total_In (Decompressor)) &
-                  ", out : " & Count'Image (Total_Out (Decompressor)));
-
-               exit when P = L;
-         end loop;
-
-         Ada.Text_IO.New_Line;
-         Ada.Text_IO.Put_Line
-           ("Decompressed text matches original text : "
-             & Boolean'Image (Uncompressed_Data = Source));
-      end Decompress;
-   end;
-end Buffer_Demo;
diff --git a/contrib/zlib/contrib/ada/mtest.adb b/contrib/zlib/contrib/ada/mtest.adb
deleted file mode 100644
index c4dfd080f..000000000
--- a/contrib/zlib/contrib/ada/mtest.adb
+++ /dev/null
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---  Continuous test for ZLib multithreading. If the test would fail
---  we should provide thread safe allocation routines for the Z_Stream.
---
---  $Id: mtest.adb,v 1.4 2004/07/23 07:49:54 vagul Exp $
-
-with ZLib;
-with Ada.Streams;
-with Ada.Numerics.Discrete_Random;
-with Ada.Text_IO;
-with Ada.Exceptions;
-with Ada.Task_Identification;
-
-procedure MTest is
-   use Ada.Streams;
-   use ZLib;
-
-   Stop : Boolean := False;
-
-   pragma Atomic (Stop);
-
-   subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is
-      new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   task type Test_Task;
-
-   task body Test_Task is
-      Buffer : Stream_Element_Array (1 .. 100_000);
-      Gen : Random_Elements.Generator;
-
-      Buffer_First  : Stream_Element_Offset;
-      Compare_First : Stream_Element_Offset;
-
-      Deflate : Filter_Type;
-      Inflate : Filter_Type;
-
-      procedure Further (Item : in Stream_Element_Array);
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-
-      -------------
-      -- Further --
-      -------------
-
-      procedure Further (Item : in Stream_Element_Array) is
-
-         procedure Compare (Item : in Stream_Element_Array);
-
-         -------------
-         -- Compare --
-         -------------
-
-         procedure Compare (Item : in Stream_Element_Array) is
-            Next_First : Stream_Element_Offset := Compare_First + Item'Length;
-         begin
-            if Buffer (Compare_First .. Next_First - 1) /= Item then
-               raise Program_Error;
-            end if;
-
-            Compare_First := Next_First;
-         end Compare;
-
-         procedure Compare_Write is new ZLib.Write (Write => Compare);
-      begin
-         Compare_Write (Inflate, Item, No_Flush);
-      end Further;
-
-      -----------------
-      -- Read_Buffer --
-      -----------------
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset)
-      is
-         Buff_Diff   : Stream_Element_Offset := Buffer'Last - Buffer_First;
-         Next_First : Stream_Element_Offset;
-      begin
-         if Item'Length <= Buff_Diff then
-            Last := Item'Last;
-
-            Next_First := Buffer_First + Item'Length;
-
-            Item := Buffer (Buffer_First .. Next_First - 1);
-
-            Buffer_First := Next_First;
-         else
-            Last := Item'First + Buff_Diff;
-            Item (Item'First .. Last) := Buffer (Buffer_First .. Buffer'Last);
-            Buffer_First := Buffer'Last + 1;
-         end if;
-      end Read_Buffer;
-
-      procedure Translate is new Generic_Translate
-                                   (Data_In  => Read_Buffer,
-                                    Data_Out => Further);
-
-   begin
-      Random_Elements.Reset (Gen);
-
-      Buffer := (others => 20);
-
-      Main : loop
-         for J in Buffer'Range loop
-            Buffer (J) := Random_Elements.Random (Gen);
-
-            Deflate_Init (Deflate);
-            Inflate_Init (Inflate);
-
-            Buffer_First  := Buffer'First;
-            Compare_First := Buffer'First;
-
-            Translate (Deflate);
-
-            if Compare_First /= Buffer'Last + 1 then
-               raise Program_Error;
-            end if;
-
-            Ada.Text_IO.Put_Line
-              (Ada.Task_Identification.Image
-                 (Ada.Task_Identification.Current_Task)
-               & Stream_Element_Offset'Image (J)
-               & ZLib.Count'Image (Total_Out (Deflate)));
-
-            Close (Deflate);
-            Close (Inflate);
-
-            exit Main when Stop;
-         end loop;
-      end loop Main;
-   exception
-      when E : others =>
-         Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Information (E));
-         Stop := True;
-   end Test_Task;
-
-   Test : array (1 .. 4) of Test_Task;
-
-   pragma Unreferenced (Test);
-
-   Dummy : Character;
-
-begin
-   Ada.Text_IO.Get_Immediate (Dummy);
-   Stop := True;
-end MTest;
diff --git a/contrib/zlib/contrib/ada/read.adb b/contrib/zlib/contrib/ada/read.adb
deleted file mode 100644
index 1f2efbfeb..000000000
--- a/contrib/zlib/contrib/ada/read.adb
+++ /dev/null
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: read.adb,v 1.8 2004/05/31 10:53:40 vagul Exp $
-
---  Test/demo program for the generic read interface.
-
-with Ada.Numerics.Discrete_Random;
-with Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib;
-
-procedure Read is
-
-   use Ada.Streams;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Stream_Element_Offset := 100_000;
-
-   Continuous  : constant Boolean          := False;
-   --  If this constant is True, the test would be repeated again and again,
-   --  with increment File_Size for every iteration.
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-   --  Do not use Header other than Default in ZLib versions 1.1.4 and older.
-
-   Init_Random : constant := 8;
-   --  We are using the same random sequence, in case of we catch bug,
-   --  so we would be able to reproduce it.
-
-   -- End --
-
-   Pack_Size : Stream_Element_Offset;
-   Offset    : Stream_Element_Offset;
-
-   Filter     : ZLib.Filter_Type;
-
-   subtype Visible_Symbols
-      is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is new
-      Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   Gen : Random_Elements.Generator;
-   Period  : constant Stream_Element_Offset := 200;
-   --  Period constant variable for random generator not to be very random.
-   --  Bigger period, harder random.
-
-   Read_Buffer : Stream_Element_Array (1 .. 2048);
-   Read_First  : Stream_Element_Offset;
-   Read_Last   : Stream_Element_Offset;
-
-   procedure Reset;
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Read
-   --  reading data from the File_In.
-
-   procedure Read is new ZLib.Read
-                           (Read,
-                            Read_Buffer,
-                            Rest_First => Read_First,
-                            Rest_Last  => Read_Last);
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Last := Stream_Element_Offset'Min
-               (Item'Last,
-                Item'First + File_Size - Offset);
-
-      for J in Item'First .. Last loop
-         if J < Item'First + Period then
-            Item (J) := Random_Elements.Random (Gen);
-         else
-            Item (J) := Item (J - Period);
-         end if;
-
-         Offset   := Offset + 1;
-      end loop;
-   end Read;
-
-   -----------
-   -- Reset --
-   -----------
-
-   procedure Reset is
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-      Pack_Size := 0;
-      Offset := 1;
-      Read_First := Read_Buffer'Last + 1;
-      Read_Last  := Read_Buffer'Last;
-   end Reset;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter,
-                Level,
-                Header => Header);
-
-         Reset;
-
-         Ada.Text_IO.Put
-           (Stream_Element_Offset'Image (File_Size) & " ->");
-
-         loop
-            declare
-               Buffer : Stream_Element_Array (1 .. 1024);
-               Last   : Stream_Element_Offset;
-            begin
-               Read (Filter, Buffer, Last);
-
-               Pack_Size := Pack_Size + Last - Buffer'First + 1;
-
-               exit when Last < Buffer'Last;
-            end;
-         end loop;
-
-         Ada.Text_IO.Put_Line (Stream_Element_Offset'Image (Pack_Size));
-
-         ZLib.Close (Filter);
-      end loop;
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Read;
diff --git a/contrib/zlib/contrib/ada/readme.txt b/contrib/zlib/contrib/ada/readme.txt
deleted file mode 100644
index ce4d2cadf..000000000
--- a/contrib/zlib/contrib/ada/readme.txt
+++ /dev/null
@@ -1,65 +0,0 @@
-                        ZLib for Ada thick binding (ZLib.Ada)
-                        Release 1.3
-
-ZLib.Ada is a thick binding interface to the popular ZLib data
-compression library, available at http://www.gzip.org/zlib/.
-It provides Ada-style access to the ZLib C library.
-
-
-        Here are the main changes since ZLib.Ada 1.2:
-
-- Attension: ZLib.Read generic routine have a initialization requirement
-  for Read_Last parameter now. It is a bit incompartible with previous version,
-  but extends functionality, we could use new parameters Allow_Read_Some and
-  Flush now.
-
-- Added Is_Open routines to ZLib and ZLib.Streams packages.
-
-- Add pragma Assert to check Stream_Element is 8 bit.
-
-- Fix extraction to buffer with exact known decompressed size. Error reported by
-  Steve Sangwine.
-
-- Fix definition of ULong (changed to unsigned_long), fix regression on 64 bits
-  computers. Patch provided by Pascal Obry.
-
-- Add Status_Error exception definition.
-
-- Add pragma Assertion that Ada.Streams.Stream_Element size is 8 bit.
-
-
-        How to build ZLib.Ada under GNAT
-
-You should have the ZLib library already build on your computer, before
-building ZLib.Ada. Make the directory of ZLib.Ada sources current and
-issue the command:
-
-  gnatmake test -largs -L<directory where libz.a is> -lz
-
-Or use the GNAT project file build for GNAT 3.15 or later:
-
-  gnatmake -Pzlib.gpr -L<directory where libz.a is>
-
-
-        How to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2
-
-1. Make a project with all *.ads and *.adb files from the distribution.
-2. Build the libz.a library from the ZLib C sources.
-3. Rename libz.a to z.lib.
-4. Add the library z.lib to the project.
-5. Add the libc.lib library from the ObjectAda distribution to the project.
-6. Build the executable using test.adb as a main procedure.
-
-
-        How to use ZLib.Ada
-
-The source files test.adb and read.adb are small demo programs that show
-the main functionality of ZLib.Ada.
-
-The routines from the package specifications are commented.
-
-
-Homepage: http://zlib-ada.sourceforge.net/
-Author: Dmitriy Anisimkov <anisimkov@yahoo.com>
-
-Contributors: Pascal Obry <pascal@obry.org>, Steve Sangwine <sjs@essex.ac.uk>
diff --git a/contrib/zlib/contrib/ada/test.adb b/contrib/zlib/contrib/ada/test.adb
deleted file mode 100644
index 90773acfa..000000000
--- a/contrib/zlib/contrib/ada/test.adb
+++ /dev/null
@@ -1,463 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: test.adb,v 1.17 2003/08/12 12:13:30 vagul Exp $
-
---  The program has a few aims.
---  1. Test ZLib.Ada95 thick binding functionality.
---  2. Show the example of use main functionality of the ZLib.Ada95 binding.
---  3. Build this program automatically compile all ZLib.Ada95 packages under
---     GNAT Ada95 compiler.
-
-with ZLib.Streams;
-with Ada.Streams.Stream_IO;
-with Ada.Numerics.Discrete_Random;
-
-with Ada.Text_IO;
-
-with Ada.Calendar;
-
-procedure Test is
-
-   use Ada.Streams;
-   use Stream_IO;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Count   := 100_000;
-   Continuous  : constant Boolean := False;
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-                                              --  ZLib.None;
-                                              --  ZLib.Auto;
-                                              --  ZLib.GZip;
-   --  Do not use Header other then Default in ZLib versions 1.1.4
-   --  and older.
-
-   Strategy    : constant ZLib.Strategy_Type := ZLib.Default_Strategy;
-   Init_Random : constant := 10;
-
-   -- End --
-
-   In_File_Name  : constant String := "testzlib.in";
-   --  Name of the input file
-
-   Z_File_Name   : constant String := "testzlib.zlb";
-   --  Name of the compressed file.
-
-   Out_File_Name : constant String := "testzlib.out";
-   --  Name of the decompressed file.
-
-   File_In   : File_Type;
-   File_Out  : File_Type;
-   File_Back : File_Type;
-   File_Z    : ZLib.Streams.Stream_Type;
-
-   Filter : ZLib.Filter_Type;
-
-   Time_Stamp : Ada.Calendar.Time;
-
-   procedure Generate_File;
-   --  Generate file of spetsified size with some random data.
-   --  The random data is repeatable, for the good compression.
-
-   procedure Compare_Streams
-     (Left, Right : in out Root_Stream_Type'Class);
-   --  The procedure compearing data in 2 streams.
-   --  It is for compare data before and after compression/decompression.
-
-   procedure Compare_Files (Left, Right : String);
-   --  Compare files. Based on the Compare_Streams.
-
-   procedure Copy_Streams
-     (Source, Target : in out Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024);
-   --  Copying data from one stream to another. It is for test stream
-   --  interface of the library.
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  reading data from the File_In.
-
-   procedure Data_Out (Item : in Stream_Element_Array);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  writing data to the File_Out.
-
-   procedure Stamp;
-   --  Store the timestamp to the local variable.
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count);
-   --  Print the time statistic with the message.
-
-   procedure Translate is new ZLib.Generic_Translate
-                                (Data_In  => Data_In,
-                                 Data_Out => Data_Out);
-   --  This procedure is moving data from File_In to File_Out
-   --  with compression or decompression, depend on initialization of
-   --  Filter parameter.
-
-   -------------------
-   -- Compare_Files --
-   -------------------
-
-   procedure Compare_Files (Left, Right : String) is
-      Left_File, Right_File : File_Type;
-   begin
-      Open (Left_File, In_File, Left);
-      Open (Right_File, In_File, Right);
-      Compare_Streams (Stream (Left_File).all, Stream (Right_File).all);
-      Close (Left_File);
-      Close (Right_File);
-   end Compare_Files;
-
-   ---------------------
-   -- Compare_Streams --
-   ---------------------
-
-   procedure Compare_Streams
-     (Left, Right : in out Ada.Streams.Root_Stream_Type'Class)
-   is
-      Left_Buffer, Right_Buffer : Stream_Element_Array (0 .. 16#FFF#);
-      Left_Last, Right_Last : Stream_Element_Offset;
-   begin
-      loop
-         Read (Left, Left_Buffer, Left_Last);
-         Read (Right, Right_Buffer, Right_Last);
-
-         if Left_Last /= Right_Last then
-            Ada.Text_IO.Put_Line ("Compare error :"
-              & Stream_Element_Offset'Image (Left_Last)
-              & " /= "
-              & Stream_Element_Offset'Image (Right_Last));
-
-            raise Constraint_Error;
-
-         elsif Left_Buffer (0 .. Left_Last)
-               /= Right_Buffer (0 .. Right_Last)
-         then
-            Ada.Text_IO.Put_Line ("ERROR: IN and OUT files is not equal.");
-            raise Constraint_Error;
-
-         end if;
-
-         exit when Left_Last < Left_Buffer'Last;
-      end loop;
-   end Compare_Streams;
-
-   ------------------
-   -- Copy_Streams --
-   ------------------
-
-   procedure Copy_Streams
-     (Source, Target : in out Ada.Streams.Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024)
-   is
-      Buffer : Stream_Element_Array (1 .. Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Read  (Source, Buffer, Last);
-         Write (Target, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Copy_Streams;
-
-   -------------
-   -- Data_In --
-   -------------
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Read (File_In, Item, Last);
-   end Data_In;
-
-   --------------
-   -- Data_Out --
-   --------------
-
-   procedure Data_Out (Item : in Stream_Element_Array) is
-   begin
-      Write (File_Out, Item);
-   end Data_Out;
-
-   -------------------
-   -- Generate_File --
-   -------------------
-
-   procedure Generate_File is
-      subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-      package Random_Elements is
-         new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-      Gen    : Random_Elements.Generator;
-      Buffer : Stream_Element_Array := (1 .. 77 => 16#20#) & 10;
-
-      Buffer_Count : constant Count := File_Size / Buffer'Length;
-      --  Number of same buffers in the packet.
-
-      Density : constant Count := 30; --  from 0 to Buffer'Length - 2;
-
-      procedure Fill_Buffer (J, D : in Count);
-      --  Change the part of the buffer.
-
-      -----------------
-      -- Fill_Buffer --
-      -----------------
-
-      procedure Fill_Buffer (J, D : in Count) is
-      begin
-         for K in 0 .. D loop
-            Buffer
-              (Stream_Element_Offset ((J + K) mod (Buffer'Length - 1) + 1))
-             := Random_Elements.Random (Gen);
-
-         end loop;
-      end Fill_Buffer;
-
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-
-      Create (File_In, Out_File, In_File_Name);
-
-      Fill_Buffer (1, Buffer'Length - 2);
-
-      for J in 1 .. Buffer_Count loop
-         Write (File_In, Buffer);
-
-         Fill_Buffer (J, Density);
-      end loop;
-
-      --  fill remain size.
-
-      Write
-        (File_In,
-         Buffer
-           (1 .. Stream_Element_Offset
-                   (File_Size - Buffer'Length * Buffer_Count)));
-
-      Flush (File_In);
-      Close (File_In);
-   end Generate_File;
-
-   ---------------------
-   -- Print_Statistic --
-   ---------------------
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count) is
-      use Ada.Calendar;
-      use Ada.Text_IO;
-
-      package Count_IO is new Integer_IO (ZLib.Count);
-
-      Curr_Dur : Duration := Clock - Time_Stamp;
-   begin
-      Put (Msg);
-
-      Set_Col (20);
-      Ada.Text_IO.Put ("size =");
-
-      Count_IO.Put
-        (Data_Size,
-         Width => Stream_IO.Count'Image (File_Size)'Length);
-
-      Put_Line (" duration =" & Duration'Image (Curr_Dur));
-   end Print_Statistic;
-
-   -----------
-   -- Stamp --
-   -----------
-
-   procedure Stamp is
-   begin
-      Time_Stamp := Ada.Calendar.Clock;
-   end Stamp;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      Generate_File;
-
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put_Line ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Test generic interface.
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         Stamp;
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter   => Filter,
-                Level    => Level,
-                Strategy => Strategy,
-                Header   => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic compress", ZLib.Total_Out (Filter));
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Open   (File_In, In_File, Z_File_Name);
-         Create (File_Out, Out_File, Out_File_Name);
-
-         Stamp;
-
-         --  Inflate using generic instantiation.
-
-         ZLib.Inflate_Init (Filter, Header => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic decompress", ZLib.Total_Out (Filter));
-
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-
-         --  Test stream interface.
-
-         --  Compress to the back stream.
-
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Back, Out_File, Z_File_Name);
-
-         Stamp;
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         --  Flushing internal buffers to the back stream.
-
-         ZLib.Streams.Flush (File_Z, ZLib.Finish);
-
-         Print_Statistic ("Write compress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compare reading from original file and from
-         --  decompression stream.
-
-         Open (File_In,   In_File, In_File_Name);
-         Open (File_Back, In_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Header          => Header);
-
-         Stamp;
-         Compare_Streams (Stream (File_In).all, File_Z);
-
-         Print_Statistic ("Read decompress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compress by reading from compression stream.
-
-         Open (File_Back, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Stamp;
-         Copy_Streams
-           (Source => File_Z,
-            Target => Stream (File_Out).all);
-
-         Print_Statistic ("Read compress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_Out);
-         Close (File_Back);
-
-         --  Decompress to decompression stream.
-
-         Open   (File_In,   In_File, Z_File_Name);
-         Create (File_Back, Out_File, Out_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Header          => Header);
-
-         Stamp;
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         Print_Statistic ("Write decompress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-      end loop;
-
-      Ada.Text_IO.Put_Line (Count'Image (File_Size) & " Ok.");
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Test;
diff --git a/contrib/zlib/contrib/ada/zlib-streams.adb b/contrib/zlib/contrib/ada/zlib-streams.adb
deleted file mode 100644
index b6497bae2..000000000
--- a/contrib/zlib/contrib/ada/zlib-streams.adb
+++ /dev/null
@@ -1,225 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.adb,v 1.10 2004/05/31 10:53:40 vagul Exp $
-
-with Ada.Unchecked_Deallocation;
-
-package body ZLib.Streams is
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close (Stream : in out Stream_Type) is
-      procedure Free is new Ada.Unchecked_Deallocation
-         (Stream_Element_Array, Buffer_Access);
-   begin
-      if Stream.Mode = Out_Stream or Stream.Mode = Duplex then
-         --  We should flush the data written by the writer.
-
-         Flush (Stream, Finish);
-
-         Close (Stream.Writer);
-      end if;
-
-      if Stream.Mode = In_Stream or Stream.Mode = Duplex then
-         Close (Stream.Reader);
-         Free (Stream.Buffer);
-      end if;
-   end Close;
-
-   ------------
-   -- Create --
-   ------------
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size)
-   is
-
-      subtype Buffer_Subtype is Stream_Element_Array (1 .. Read_Buffer_Size);
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean);
-
-      -----------------
-      -- Init_Filter --
-      -----------------
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean) is
-      begin
-         if Compress then
-            Deflate_Init
-              (Filter, Level, Strategy, Header => Header);
-         else
-            Inflate_Init (Filter, Header => Header);
-         end if;
-      end Init_Filter;
-
-   begin
-      Stream.Back := Back;
-      Stream.Mode := Mode;
-
-      if Mode = Out_Stream or Mode = Duplex then
-         Init_Filter (Stream.Writer, Back_Compressed);
-         Stream.Buffer_Size := Write_Buffer_Size;
-      else
-         Stream.Buffer_Size := 0;
-      end if;
-
-      if Mode = In_Stream or Mode = Duplex then
-         Init_Filter (Stream.Reader, not Back_Compressed);
-
-         Stream.Buffer     := new Buffer_Subtype;
-         Stream.Rest_First := Stream.Buffer'Last + 1;
-         Stream.Rest_Last  := Stream.Buffer'Last;
-      end if;
-   end Create;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush)
-   is
-      Buffer : Stream_Element_Array (1 .. Stream.Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Flush (Stream.Writer, Buffer, Last, Mode);
-
-         Ada.Streams.Write (Stream.Back.all, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Flush;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Stream : Stream_Type) return Boolean is
-   begin
-      return Is_Open (Stream.Reader) or else Is_Open (Stream.Writer);
-   end Is_Open;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Stream_Element_Array;
-      Last   :    out Stream_Element_Offset)
-   is
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset);
-
-      ----------
-      -- Read --
-      ----------
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset) is
-      begin
-         Ada.Streams.Read (Stream.Back.all, Item, Last);
-      end Read;
-
-      procedure Read is new ZLib.Read
-         (Read       => Read,
-          Buffer     => Stream.Buffer.all,
-          Rest_First => Stream.Rest_First,
-          Rest_Last  => Stream.Rest_Last);
-
-   begin
-      Read (Stream.Reader, Item, Last);
-   end Read;
-
-   -------------------
-   -- Read_Total_In --
-   -------------------
-
-   function Read_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Reader);
-   end Read_Total_In;
-
-   --------------------
-   -- Read_Total_Out --
-   --------------------
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Reader);
-   end Read_Total_Out;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Stream_Element_Array)
-   is
-
-      procedure Write (Item : in Stream_Element_Array);
-
-      -----------
-      -- Write --
-      -----------
-
-      procedure Write (Item : in Stream_Element_Array) is
-      begin
-         Ada.Streams.Write (Stream.Back.all, Item);
-      end Write;
-
-      procedure Write is new ZLib.Write
-         (Write       => Write,
-          Buffer_Size => Stream.Buffer_Size);
-
-   begin
-      Write (Stream.Writer, Item, No_Flush);
-   end Write;
-
-   --------------------
-   -- Write_Total_In --
-   --------------------
-
-   function Write_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Writer);
-   end Write_Total_In;
-
-   ---------------------
-   -- Write_Total_Out --
-   ---------------------
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Writer);
-   end Write_Total_Out;
-
-end ZLib.Streams;
diff --git a/contrib/zlib/contrib/ada/zlib-streams.ads b/contrib/zlib/contrib/ada/zlib-streams.ads
deleted file mode 100644
index 8e26cd450..000000000
--- a/contrib/zlib/contrib/ada/zlib-streams.ads
+++ /dev/null
@@ -1,114 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.ads,v 1.12 2004/05/31 10:53:40 vagul Exp $
-
-package ZLib.Streams is
-
-   type Stream_Mode is (In_Stream, Out_Stream, Duplex);
-
-   type Stream_Access is access all Ada.Streams.Root_Stream_Type'Class;
-
-   type Stream_Type is
-      new Ada.Streams.Root_Stream_Type with private;
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset);
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array);
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush);
-   --  Flush the written data to the back stream,
-   --  all data placed to the compressor is flushing to the Back stream.
-   --  Should not be used until necessary, because it is decreasing
-   --  compression.
-
-   function Read_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_In);
-   --  Return total number of bytes read from back stream so far.
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_Out);
-   --  Return total number of bytes read so far.
-
-   function Write_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_In);
-   --  Return total number of bytes written so far.
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_Out);
-   --  Return total number of bytes written to the back stream.
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size);
-   --  Create the Comression/Decompression stream.
-   --  If mode is In_Stream then Write operation is disabled.
-   --  If mode is Out_Stream then Read operation is disabled.
-
-   --  If Back_Compressed is true then
-   --  Data written to the Stream is compressing to the Back stream
-   --  and data read from the Stream is decompressed data from the Back stream.
-
-   --  If Back_Compressed is false then
-   --  Data written to the Stream is decompressing to the Back stream
-   --  and data read from the Stream is compressed data from the Back stream.
-
-   --  !!! When the Need_Header is False ZLib-Ada is using undocumented
-   --  ZLib 1.1.4 functionality to do not create/wait for ZLib headers.
-
-   function Is_Open (Stream : Stream_Type) return Boolean;
-
-   procedure Close (Stream : in out Stream_Type);
-
-private
-
-   use Ada.Streams;
-
-   type Buffer_Access is access all Stream_Element_Array;
-
-   type Stream_Type
-     is new Root_Stream_Type with
-   record
-      Mode       : Stream_Mode;
-
-      Buffer     : Buffer_Access;
-      Rest_First : Stream_Element_Offset;
-      Rest_Last  : Stream_Element_Offset;
-      --  Buffer for Read operation.
-      --  We need to have this buffer in the record
-      --  because not all read data from back stream
-      --  could be processed during the read operation.
-
-      Buffer_Size : Stream_Element_Offset;
-      --  Buffer size for write operation.
-      --  We do not need to have this buffer
-      --  in the record because all data could be
-      --  processed in the write operation.
-
-      Back       : Stream_Access;
-      Reader     : Filter_Type;
-      Writer     : Filter_Type;
-   end record;
-
-end ZLib.Streams;
diff --git a/contrib/zlib/contrib/ada/zlib-thin.adb b/contrib/zlib/contrib/ada/zlib-thin.adb
deleted file mode 100644
index 0ca4a7120..000000000
--- a/contrib/zlib/contrib/ada/zlib-thin.adb
+++ /dev/null
@@ -1,141 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.adb,v 1.8 2003/12/14 18:27:31 vagul Exp $
-
-package body ZLib.Thin is
-
-   ZLIB_VERSION  : constant Chars_Ptr := zlibVersion;
-
-   Z_Stream_Size : constant Int := Z_Stream'Size / System.Storage_Unit;
-
-   --------------
-   -- Avail_In --
-   --------------
-
-   function Avail_In (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_In;
-   end Avail_In;
-
-   ---------------
-   -- Avail_Out --
-   ---------------
-
-   function Avail_Out (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_Out;
-   end Avail_Out;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int is
-   begin
-      return deflateInit2
-               (strm,
-                level,
-                method,
-                windowBits,
-                memLevel,
-                strategy,
-                ZLIB_VERSION,
-                Z_Stream_Size);
-   end Deflate_Init;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int is
-   begin
-      return inflateInit2 (strm, windowBits, ZLIB_VERSION, Z_Stream_Size);
-   end Inflate_Init;
-
-   ------------------------
-   -- Last_Error_Message --
-   ------------------------
-
-   function Last_Error_Message (Strm : in Z_Stream) return String is
-      use Interfaces.C.Strings;
-   begin
-      if Strm.msg = Null_Ptr then
-         return "";
-      else
-         return Value (Strm.msg);
-      end if;
-   end Last_Error_Message;
-
-   ------------
-   -- Set_In --
-   ------------
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_In  := Buffer;
-      Strm.Avail_In := Size;
-   end Set_In;
-
-   ------------------
-   -- Set_Mem_Func --
-   ------------------
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in     Voidp;
-      Alloc  : in     alloc_func;
-      Free   : in     free_func) is
-   begin
-      Strm.opaque := Opaque;
-      Strm.zalloc := Alloc;
-      Strm.zfree  := Free;
-   end Set_Mem_Func;
-
-   -------------
-   -- Set_Out --
-   -------------
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_Out  := Buffer;
-      Strm.Avail_Out := Size;
-   end Set_Out;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_In;
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_Out;
-   end Total_Out;
-
-end ZLib.Thin;
diff --git a/contrib/zlib/contrib/ada/zlib-thin.ads b/contrib/zlib/contrib/ada/zlib-thin.ads
deleted file mode 100644
index 810173cff..000000000
--- a/contrib/zlib/contrib/ada/zlib-thin.ads
+++ /dev/null
@@ -1,450 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.ads,v 1.11 2004/07/23 06:33:11 vagul Exp $
-
-with Interfaces.C.Strings;
-
-with System;
-
-private package ZLib.Thin is
-
-   --  From zconf.h
-
-   MAX_MEM_LEVEL : constant := 9;         --  zconf.h:105
-                                          --  zconf.h:105
-   MAX_WBITS : constant := 15;      --  zconf.h:115
-                                    --  32K LZ77 window
-                                    --  zconf.h:115
-   SEEK_SET : constant := 8#0000#;  --  zconf.h:244
-                                    --  Seek from beginning of file.
-                                    --  zconf.h:244
-   SEEK_CUR : constant := 1;        --  zconf.h:245
-                                    --  Seek from current position.
-                                    --  zconf.h:245
-   SEEK_END : constant := 2;        --  zconf.h:246
-                                    --  Set file pointer to EOF plus "offset"
-                                    --  zconf.h:246
-
-   type Byte is new Interfaces.C.unsigned_char; --  8 bits
-                                                --  zconf.h:214
-   type UInt is new Interfaces.C.unsigned;      --  16 bits or more
-                                                --  zconf.h:216
-   type Int is new Interfaces.C.int;
-
-   type ULong is new Interfaces.C.unsigned_long;     --  32 bits or more
-                                                     --  zconf.h:217
-   subtype Chars_Ptr is Interfaces.C.Strings.chars_ptr;
-
-   type ULong_Access is access ULong;
-   type Int_Access is access Int;
-
-   subtype Voidp is System.Address;            --  zconf.h:232
-
-   subtype Byte_Access is Voidp;
-
-   Nul : constant Voidp := System.Null_Address;
-   --  end from zconf
-
-   Z_NO_FLUSH : constant := 8#0000#;   --  zlib.h:125
-                                       --  zlib.h:125
-   Z_PARTIAL_FLUSH : constant := 1;       --  zlib.h:126
-                                          --  will be removed, use
-                                          --  Z_SYNC_FLUSH instead
-                                          --  zlib.h:126
-   Z_SYNC_FLUSH : constant := 2;       --  zlib.h:127
-                                       --  zlib.h:127
-   Z_FULL_FLUSH : constant := 3;       --  zlib.h:128
-                                       --  zlib.h:128
-   Z_FINISH : constant := 4;        --  zlib.h:129
-                                    --  zlib.h:129
-   Z_OK : constant := 8#0000#;   --  zlib.h:132
-                                 --  zlib.h:132
-   Z_STREAM_END : constant := 1;       --  zlib.h:133
-                                       --  zlib.h:133
-   Z_NEED_DICT : constant := 2;        --  zlib.h:134
-                                       --  zlib.h:134
-   Z_ERRNO : constant := -1;        --  zlib.h:135
-                                    --  zlib.h:135
-   Z_STREAM_ERROR : constant := -2;       --  zlib.h:136
-                                          --  zlib.h:136
-   Z_DATA_ERROR : constant := -3;      --  zlib.h:137
-                                       --  zlib.h:137
-   Z_MEM_ERROR : constant := -4;       --  zlib.h:138
-                                       --  zlib.h:138
-   Z_BUF_ERROR : constant := -5;       --  zlib.h:139
-                                       --  zlib.h:139
-   Z_VERSION_ERROR : constant := -6;      --  zlib.h:140
-                                          --  zlib.h:140
-   Z_NO_COMPRESSION : constant := 8#0000#;   --  zlib.h:145
-                                             --  zlib.h:145
-   Z_BEST_SPEED : constant := 1;       --  zlib.h:146
-                                       --  zlib.h:146
-   Z_BEST_COMPRESSION : constant := 9;       --  zlib.h:147
-                                             --  zlib.h:147
-   Z_DEFAULT_COMPRESSION : constant := -1;      --  zlib.h:148
-                                                --  zlib.h:148
-   Z_FILTERED : constant := 1;      --  zlib.h:151
-                                    --  zlib.h:151
-   Z_HUFFMAN_ONLY : constant := 2;        --  zlib.h:152
-                                          --  zlib.h:152
-   Z_DEFAULT_STRATEGY : constant := 8#0000#; --  zlib.h:153
-                                             --  zlib.h:153
-   Z_BINARY : constant := 8#0000#;  --  zlib.h:156
-                                    --  zlib.h:156
-   Z_ASCII : constant := 1;      --  zlib.h:157
-                                 --  zlib.h:157
-   Z_UNKNOWN : constant := 2;       --  zlib.h:158
-                                    --  zlib.h:158
-   Z_DEFLATED : constant := 8;      --  zlib.h:161
-                                    --  zlib.h:161
-   Z_NULL : constant := 8#0000#; --  zlib.h:164
-                                 --  for initializing zalloc, zfree, opaque
-                                 --  zlib.h:164
-   type gzFile is new Voidp;                  --  zlib.h:646
-
-   type Z_Stream is private;
-
-   type Z_Streamp is access all Z_Stream;     --  zlib.h:89
-
-   type alloc_func is access function
-     (Opaque : Voidp;
-      Items  : UInt;
-      Size   : UInt)
-      return Voidp; --  zlib.h:63
-
-   type free_func is access procedure (opaque : Voidp; address : Voidp);
-
-   function zlibVersion return Chars_Ptr;
-
-   function Deflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function DeflateEnd (strm : Z_Streamp) return Int;
-
-   function Inflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function InflateEnd (strm : Z_Streamp) return Int;
-
-   function deflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int;
-
-   function deflateCopy (dest : Z_Streamp; source : Z_Streamp) return Int;
-   --  zlib.h:478
-
-   function deflateReset (strm : Z_Streamp) return Int; -- zlib.h:495
-
-   function deflateParams
-     (strm     : Z_Streamp;
-      level    : Int;
-      strategy : Int)
-      return     Int;       -- zlib.h:506
-
-   function inflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int; --  zlib.h:548
-
-   function inflateSync (strm : Z_Streamp) return Int;  --  zlib.h:565
-
-   function inflateReset (strm : Z_Streamp) return Int; --  zlib.h:580
-
-   function compress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;           -- zlib.h:601
-
-   function compress2
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong;
-      level     : Int)
-      return      Int;          -- zlib.h:615
-
-   function uncompress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;
-
-   function gzopen (path : Chars_Ptr; mode : Chars_Ptr) return gzFile;
-
-   function gzdopen (fd : Int; mode : Chars_Ptr) return gzFile;
-
-   function gzsetparams
-     (file     : gzFile;
-      level    : Int;
-      strategy : Int)
-      return     Int;
-
-   function gzread
-     (file : gzFile;
-      buf  : Voidp;
-      len  : UInt)
-      return Int;
-
-   function gzwrite
-     (file : in gzFile;
-      buf  : in Voidp;
-      len  : in UInt)
-      return Int;
-
-   function gzprintf (file : in gzFile; format : in Chars_Ptr) return Int;
-
-   function gzputs (file : in gzFile; s : in Chars_Ptr) return Int;
-
-   function gzgets
-     (file : gzFile;
-      buf  : Chars_Ptr;
-      len  : Int)
-      return Chars_Ptr;
-
-   function gzputc (file : gzFile; char : Int) return Int;
-
-   function gzgetc (file : gzFile) return Int;
-
-   function gzflush (file : gzFile; flush : Int) return Int;
-
-   function gzseek
-     (file   : gzFile;
-      offset : Int;
-      whence : Int)
-      return   Int;
-
-   function gzrewind (file : gzFile) return Int;
-
-   function gztell (file : gzFile) return Int;
-
-   function gzeof (file : gzFile) return Int;
-
-   function gzclose (file : gzFile) return Int;
-
-   function gzerror (file : gzFile; errnum : Int_Access) return Chars_Ptr;
-
-   function adler32
-     (adler : ULong;
-      buf   : Byte_Access;
-      len   : UInt)
-      return  ULong;
-
-   function crc32
-     (crc  : ULong;
-      buf  : Byte_Access;
-      len  : UInt)
-      return ULong;
-
-   function deflateInit
-     (strm        : Z_Streamp;
-      level       : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function deflateInit2
-     (strm        : Z_Streamp;
-      level       : Int;
-      method      : Int;
-      windowBits  : Int;
-      memLevel    : Int;
-      strategy    : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int;
-   pragma Inline (Deflate_Init);
-
-   function inflateInit
-     (strm        : Z_Streamp;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function inflateInit2
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-
-   function inflateBackInit
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      window      : in Byte_Access;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-   --  Size of window have to be 2**windowBits.
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int;
-   pragma Inline (Inflate_Init);
-
-   function zError (err : Int) return Chars_Ptr;
-
-   function inflateSyncPoint (z : Z_Streamp) return Int;
-
-   function get_crc_table return ULong_Access;
-
-   --  Interface to the available fields of the z_stream structure.
-   --  The application must update next_in and avail_in when avail_in has
-   --  dropped to zero. It must update next_out and avail_out when avail_out
-   --  has dropped to zero. The application must initialize zalloc, zfree and
-   --  opaque before calling the init function.
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_In);
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_Out);
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in Voidp;
-      Alloc  : in alloc_func;
-      Free   : in free_func);
-   pragma Inline (Set_Mem_Func);
-
-   function Last_Error_Message (Strm : in Z_Stream) return String;
-   pragma Inline (Last_Error_Message);
-
-   function Avail_Out (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_Out);
-
-   function Avail_In (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_In);
-
-   function Total_In (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_In);
-
-   function Total_Out (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_Out);
-
-   function inflateCopy
-     (dest   : in Z_Streamp;
-      Source : in Z_Streamp)
-      return Int;
-
-   function compressBound (Source_Len : in ULong) return ULong;
-
-   function deflateBound
-     (Strm       : in Z_Streamp;
-      Source_Len : in ULong)
-      return     ULong;
-
-   function gzungetc (C : in Int; File : in  gzFile) return Int;
-
-   function zlibCompileFlags return ULong;
-
-private
-
-   type Z_Stream is record            -- zlib.h:68
-      Next_In   : Voidp      := Nul;  -- next input byte
-      Avail_In  : UInt       := 0;    -- number of bytes available at next_in
-      Total_In  : ULong      := 0;    -- total nb of input bytes read so far
-      Next_Out  : Voidp      := Nul;  -- next output byte should be put there
-      Avail_Out : UInt       := 0;    -- remaining free space at next_out
-      Total_Out : ULong      := 0;    -- total nb of bytes output so far
-      msg       : Chars_Ptr;          -- last error message, NULL if no error
-      state     : Voidp;              -- not visible by applications
-      zalloc    : alloc_func := null; -- used to allocate the internal state
-      zfree     : free_func  := null; -- used to free the internal state
-      opaque    : Voidp;              -- private data object passed to
-                                      --  zalloc and zfree
-      data_type : Int;                -- best guess about the data type:
-                                      --  ascii or binary
-      adler     : ULong;              -- adler32 value of the uncompressed
-                                      --  data
-      reserved  : ULong;              -- reserved for future use
-   end record;
-
-   pragma Convention (C, Z_Stream);
-
-   pragma Import (C, zlibVersion, "zlibVersion");
-   pragma Import (C, Deflate, "deflate");
-   pragma Import (C, DeflateEnd, "deflateEnd");
-   pragma Import (C, Inflate, "inflate");
-   pragma Import (C, InflateEnd, "inflateEnd");
-   pragma Import (C, deflateSetDictionary, "deflateSetDictionary");
-   pragma Import (C, deflateCopy, "deflateCopy");
-   pragma Import (C, deflateReset, "deflateReset");
-   pragma Import (C, deflateParams, "deflateParams");
-   pragma Import (C, inflateSetDictionary, "inflateSetDictionary");
-   pragma Import (C, inflateSync, "inflateSync");
-   pragma Import (C, inflateReset, "inflateReset");
-   pragma Import (C, compress, "compress");
-   pragma Import (C, compress2, "compress2");
-   pragma Import (C, uncompress, "uncompress");
-   pragma Import (C, gzopen, "gzopen");
-   pragma Import (C, gzdopen, "gzdopen");
-   pragma Import (C, gzsetparams, "gzsetparams");
-   pragma Import (C, gzread, "gzread");
-   pragma Import (C, gzwrite, "gzwrite");
-   pragma Import (C, gzprintf, "gzprintf");
-   pragma Import (C, gzputs, "gzputs");
-   pragma Import (C, gzgets, "gzgets");
-   pragma Import (C, gzputc, "gzputc");
-   pragma Import (C, gzgetc, "gzgetc");
-   pragma Import (C, gzflush, "gzflush");
-   pragma Import (C, gzseek, "gzseek");
-   pragma Import (C, gzrewind, "gzrewind");
-   pragma Import (C, gztell, "gztell");
-   pragma Import (C, gzeof, "gzeof");
-   pragma Import (C, gzclose, "gzclose");
-   pragma Import (C, gzerror, "gzerror");
-   pragma Import (C, adler32, "adler32");
-   pragma Import (C, crc32, "crc32");
-   pragma Import (C, deflateInit, "deflateInit_");
-   pragma Import (C, inflateInit, "inflateInit_");
-   pragma Import (C, deflateInit2, "deflateInit2_");
-   pragma Import (C, inflateInit2, "inflateInit2_");
-   pragma Import (C, zError, "zError");
-   pragma Import (C, inflateSyncPoint, "inflateSyncPoint");
-   pragma Import (C, get_crc_table, "get_crc_table");
-
-   --  since zlib 1.2.0:
-
-   pragma Import (C, inflateCopy, "inflateCopy");
-   pragma Import (C, compressBound, "compressBound");
-   pragma Import (C, deflateBound, "deflateBound");
-   pragma Import (C, gzungetc, "gzungetc");
-   pragma Import (C, zlibCompileFlags, "zlibCompileFlags");
-
-   pragma Import (C, inflateBackInit, "inflateBackInit_");
-
-   --  I stopped binding the inflateBack routines, because realize that
-   --  it does not support zlib and gzip headers for now, and have no
-   --  symmetric deflateBack routines.
-   --  ZLib-Ada is symmetric regarding deflate/inflate data transformation
-   --  and has a similar generic callback interface for the
-   --  deflate/inflate transformation based on the regular Deflate/Inflate
-   --  routines.
-
-   --  pragma Import (C, inflateBack, "inflateBack");
-   --  pragma Import (C, inflateBackEnd, "inflateBackEnd");
-
-end ZLib.Thin;
diff --git a/contrib/zlib/contrib/ada/zlib.adb b/contrib/zlib/contrib/ada/zlib.adb
deleted file mode 100644
index 8b6fd686a..000000000
--- a/contrib/zlib/contrib/ada/zlib.adb
+++ /dev/null
@@ -1,701 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib.adb,v 1.31 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Exceptions;
-with Ada.Unchecked_Conversion;
-with Ada.Unchecked_Deallocation;
-
-with Interfaces.C.Strings;
-
-with ZLib.Thin;
-
-package body ZLib is
-
-   use type Thin.Int;
-
-   type Z_Stream is new Thin.Z_Stream;
-
-   type Return_Code_Enum is
-      (OK,
-       STREAM_END,
-       NEED_DICT,
-       ERRNO,
-       STREAM_ERROR,
-       DATA_ERROR,
-       MEM_ERROR,
-       BUF_ERROR,
-       VERSION_ERROR);
-
-   type Flate_Step_Function is access
-     function (Strm : in Thin.Z_Streamp; Flush : in Thin.Int) return Thin.Int;
-   pragma Convention (C, Flate_Step_Function);
-
-   type Flate_End_Function is access
-      function (Ctrm : in Thin.Z_Streamp) return Thin.Int;
-   pragma Convention (C, Flate_End_Function);
-
-   type Flate_Type is record
-      Step : Flate_Step_Function;
-      Done : Flate_End_Function;
-   end record;
-
-   subtype Footer_Array is Stream_Element_Array (1 .. 8);
-
-   Simple_GZip_Header : constant Stream_Element_Array (1 .. 10)
-     := (16#1f#, 16#8b#,                 --  Magic header
-         16#08#,                         --  Z_DEFLATED
-         16#00#,                         --  Flags
-         16#00#, 16#00#, 16#00#, 16#00#, --  Time
-         16#00#,                         --  XFlags
-         16#03#                          --  OS code
-        );
-   --  The simplest gzip header is not for informational, but just for
-   --  gzip format compatibility.
-   --  Note that some code below is using assumption
-   --  Simple_GZip_Header'Last > Footer_Array'Last, so do not make
-   --  Simple_GZip_Header'Last <= Footer_Array'Last.
-
-   Return_Code : constant array (Thin.Int range <>) of Return_Code_Enum
-     := (0 => OK,
-         1 => STREAM_END,
-         2 => NEED_DICT,
-        -1 => ERRNO,
-        -2 => STREAM_ERROR,
-        -3 => DATA_ERROR,
-        -4 => MEM_ERROR,
-        -5 => BUF_ERROR,
-        -6 => VERSION_ERROR);
-
-   Flate : constant array (Boolean) of Flate_Type
-     := (True  => (Step => Thin.Deflate'Access,
-                   Done => Thin.DeflateEnd'Access),
-         False => (Step => Thin.Inflate'Access,
-                   Done => Thin.InflateEnd'Access));
-
-   Flush_Finish : constant array (Boolean) of Flush_Mode
-     := (True => Finish, False => No_Flush);
-
-   procedure Raise_Error (Stream : in Z_Stream);
-   pragma Inline (Raise_Error);
-
-   procedure Raise_Error (Message : in String);
-   pragma Inline (Raise_Error);
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int);
-
-   procedure Free is new Ada.Unchecked_Deallocation
-      (Z_Stream, Z_Stream_Access);
-
-   function To_Thin_Access is new Ada.Unchecked_Conversion
-     (Z_Stream_Access, Thin.Z_Streamp);
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Separate translate routine for make gzip header.
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  translate routine without additional headers.
-
-   -----------------
-   -- Check_Error --
-   -----------------
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int) is
-      use type Thin.Int;
-   begin
-      if Code /= Thin.Z_OK then
-         Raise_Error
-            (Return_Code_Enum'Image (Return_Code (Code))
-              & ": " & Last_Error_Message (Stream));
-      end if;
-   end Check_Error;
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False)
-   is
-      Code : Thin.Int;
-   begin
-      if not Ignore_Error and then not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      Code := Flate (Filter.Compression).Done (To_Thin_Access (Filter.Strm));
-
-      if Ignore_Error or else Code = Thin.Z_OK then
-         Free (Filter.Strm);
-      else
-         declare
-            Error_Message : constant String
-              := Last_Error_Message (Filter.Strm.all);
-         begin
-            Free (Filter.Strm);
-            Ada.Exceptions.Raise_Exception
-               (ZLib_Error'Identity,
-                Return_Code_Enum'Image (Return_Code (Code))
-                  & ": " & Error_Message);
-         end;
-      end if;
-   end Close;
-
-   -----------
-   -- CRC32 --
-   -----------
-
-   function CRC32
-     (CRC  : in Unsigned_32;
-      Data : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32
-   is
-      use Thin;
-   begin
-      return Unsigned_32 (crc32 (ULong (CRC),
-                                 Data'Address,
-                                 Data'Length));
-   end CRC32;
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array) is
-   begin
-      CRC := CRC32 (CRC, Data);
-   end CRC32;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      --  We allow ZLib to make header only in case of default header type.
-      --  Otherwise we would either do header by ourselfs, or do not do
-      --  header at all.
-
-      if Header = None or else Header = GZip then
-         Win_Bits := -Win_Bits;
-      end if;
-
-      --  For the GZip CRC calculation and make headers.
-
-      if Header = GZip then
-         Filter.CRC    := 0;
-         Filter.Offset := Simple_GZip_Header'First;
-      else
-         Filter.Offset := Simple_GZip_Header'Last + 1;
-      end if;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := True;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Deflate_Init
-           (To_Thin_Access (Filter.Strm),
-            Level      => Thin.Int (Level),
-            method     => Thin.Int (Method),
-            windowBits => Win_Bits,
-            memLevel   => Thin.Int (Memory_Level),
-            strategy   => Thin.Int (Strategy)) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Deflate_Init;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      No_Data : Stream_Element_Array := (1 .. 0 => 0);
-      Last    : Stream_Element_Offset;
-   begin
-      Translate (Filter, No_Data, Last, Out_Data, Out_Last, Flush);
-   end Flush;
-
-   -----------------------
-   -- Generic_Translate --
-   -----------------------
-
-   procedure Generic_Translate
-     (Filter          : in out ZLib.Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size)
-   is
-      In_Buffer  : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (In_Buffer_Size));
-      Out_Buffer : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (Out_Buffer_Size));
-      Last       : Stream_Element_Offset;
-      In_Last    : Stream_Element_Offset;
-      In_First   : Stream_Element_Offset;
-      Out_Last   : Stream_Element_Offset;
-   begin
-      Main : loop
-         Data_In (In_Buffer, Last);
-
-         In_First := In_Buffer'First;
-
-         loop
-            Translate
-              (Filter   => Filter,
-               In_Data  => In_Buffer (In_First .. Last),
-               In_Last  => In_Last,
-               Out_Data => Out_Buffer,
-               Out_Last => Out_Last,
-               Flush    => Flush_Finish (Last < In_Buffer'First));
-
-            if Out_Buffer'First <= Out_Last then
-               Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));
-            end if;
-
-            exit Main when Stream_End (Filter);
-
-            --  The end of in buffer.
-
-            exit when In_Last = Last;
-
-            In_First := In_Last + 1;
-         end loop;
-      end loop Main;
-
-   end Generic_Translate;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-
-      procedure Check_Version;
-      --  Check the latest header types compatibility.
-
-      procedure Check_Version is
-      begin
-         if Version <= "1.1.4" then
-            Raise_Error
-              ("Inflate header type " & Header_Type'Image (Header)
-               & " incompatible with ZLib version " & Version);
-         end if;
-      end Check_Version;
-
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      case Header is
-         when None =>
-            Check_Version;
-
-            --  Inflate data without headers determined
-            --  by negative Win_Bits.
-
-            Win_Bits := -Win_Bits;
-         when GZip =>
-            Check_Version;
-
-            --  Inflate gzip data defined by flag 16.
-
-            Win_Bits := Win_Bits + 16;
-         when Auto =>
-            Check_Version;
-
-            --  Inflate with automatic detection
-            --  of gzip or native header defined by flag 32.
-
-            Win_Bits := Win_Bits + 32;
-         when Default => null;
-      end case;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := False;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Inflate_Init
-         (To_Thin_Access (Filter.Strm), Win_Bits) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Inflate_Init;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Filter : in Filter_Type) return Boolean is
-   begin
-      return Filter.Strm /= null;
-   end Is_Open;
-
-   -----------------
-   -- Raise_Error --
-   -----------------
-
-   procedure Raise_Error (Message : in String) is
-   begin
-      Ada.Exceptions.Raise_Exception (ZLib_Error'Identity, Message);
-   end Raise_Error;
-
-   procedure Raise_Error (Stream : in Z_Stream) is
-   begin
-      Raise_Error (Last_Error_Message (Stream));
-   end Raise_Error;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      In_Last    : Stream_Element_Offset;
-      Item_First : Ada.Streams.Stream_Element_Offset := Item'First;
-      V_Flush    : Flush_Mode := Flush;
-
-   begin
-      pragma Assert (Rest_First in Buffer'First .. Buffer'Last + 1);
-      pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);
-
-      loop
-         if Rest_Last = Buffer'First - 1 then
-            V_Flush := Finish;
-
-         elsif Rest_First > Rest_Last then
-            Read (Buffer, Rest_Last);
-            Rest_First := Buffer'First;
-
-            if Rest_Last < Buffer'First then
-               V_Flush := Finish;
-            end if;
-         end if;
-
-         Translate
-           (Filter   => Filter,
-            In_Data  => Buffer (Rest_First .. Rest_Last),
-            In_Last  => In_Last,
-            Out_Data => Item (Item_First .. Item'Last),
-            Out_Last => Last,
-            Flush    => V_Flush);
-
-         Rest_First := In_Last + 1;
-
-         exit when Stream_End (Filter)
-           or else Last = Item'Last
-           or else (Last >= Item'First and then Allow_Read_Some);
-
-         Item_First := Last + 1;
-      end loop;
-   end Read;
-
-   ----------------
-   -- Stream_End --
-   ----------------
-
-   function Stream_End (Filter : in Filter_Type) return Boolean is
-   begin
-      if Filter.Header = GZip and Filter.Compression then
-         return Filter.Stream_End
-            and then Filter.Offset = Footer_Array'Last + 1;
-      else
-         return Filter.Stream_End;
-      end if;
-   end Stream_End;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_In (To_Thin_Access (Filter.Strm).all));
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_Out (To_Thin_Access (Filter.Strm).all));
-   end Total_Out;
-
-   ---------------
-   -- Translate --
-   ---------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode) is
-   begin
-      if Filter.Header = GZip and then Filter.Compression then
-         Translate_GZip
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      else
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      end if;
-   end Translate;
-
-   --------------------
-   -- Translate_Auto --
-   --------------------
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      use type Thin.Int;
-      Code : Thin.Int;
-
-   begin
-      if not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      if Out_Data'Length = 0 and then In_Data'Length = 0 then
-         raise Constraint_Error;
-      end if;
-
-      Set_Out (Filter.Strm.all, Out_Data'Address, Out_Data'Length);
-      Set_In  (Filter.Strm.all, In_Data'Address, In_Data'Length);
-
-      Code := Flate (Filter.Compression).Step
-        (To_Thin_Access (Filter.Strm),
-         Thin.Int (Flush));
-
-      if Code = Thin.Z_STREAM_END then
-         Filter.Stream_End := True;
-      else
-         Check_Error (Filter.Strm.all, Code);
-      end if;
-
-      In_Last  := In_Data'Last
-         - Stream_Element_Offset (Avail_In (Filter.Strm.all));
-      Out_Last := Out_Data'Last
-         - Stream_Element_Offset (Avail_Out (Filter.Strm.all));
-   end Translate_Auto;
-
-   --------------------
-   -- Translate_GZip --
-   --------------------
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      Out_First : Stream_Element_Offset;
-
-      procedure Add_Data (Data : in Stream_Element_Array);
-      --  Add data to stream from the Filter.Offset till necessary,
-      --  used for add gzip headr/footer.
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32);
-      pragma Inline (Put_32);
-
-      --------------
-      -- Add_Data --
-      --------------
-
-      procedure Add_Data (Data : in Stream_Element_Array) is
-         Data_First : Stream_Element_Offset renames Filter.Offset;
-         Data_Last  : Stream_Element_Offset;
-         Data_Len   : Stream_Element_Offset; --  -1
-         Out_Len    : Stream_Element_Offset; --  -1
-      begin
-         Out_First := Out_Last + 1;
-
-         if Data_First > Data'Last then
-            return;
-         end if;
-
-         Data_Len  := Data'Last     - Data_First;
-         Out_Len   := Out_Data'Last - Out_First;
-
-         if Data_Len <= Out_Len then
-            Out_Last  := Out_First  + Data_Len;
-            Data_Last := Data'Last;
-         else
-            Out_Last  := Out_Data'Last;
-            Data_Last := Data_First + Out_Len;
-         end if;
-
-         Out_Data (Out_First .. Out_Last) := Data (Data_First .. Data_Last);
-
-         Data_First := Data_Last + 1;
-         Out_First  := Out_Last + 1;
-      end Add_Data;
-
-      ------------
-      -- Put_32 --
-      ------------
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32)
-      is
-         D : Unsigned_32 := Data;
-      begin
-         for J in Item'First .. Item'First + 3 loop
-            Item (J) := Stream_Element (D and 16#FF#);
-            D := Shift_Right (D, 8);
-         end loop;
-      end Put_32;
-
-   begin
-      Out_Last := Out_Data'First - 1;
-
-      if not Filter.Stream_End then
-         Add_Data (Simple_GZip_Header);
-
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data (Out_First .. Out_Data'Last),
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         CRC32 (Filter.CRC, In_Data (In_Data'First .. In_Last));
-      end if;
-
-      if Filter.Stream_End and then Out_Last <= Out_Data'Last then
-         --  This detection method would work only when
-         --  Simple_GZip_Header'Last > Footer_Array'Last
-
-         if Filter.Offset = Simple_GZip_Header'Last + 1 then
-            Filter.Offset := Footer_Array'First;
-         end if;
-
-         declare
-            Footer : Footer_Array;
-         begin
-            Put_32 (Footer, Filter.CRC);
-            Put_32 (Footer (Footer'First + 4 .. Footer'Last),
-                    Unsigned_32 (Total_In (Filter)));
-            Add_Data (Footer);
-         end;
-      end if;
-   end Translate_GZip;
-
-   -------------
-   -- Version --
-   -------------
-
-   function Version return String is
-   begin
-      return Interfaces.C.Strings.Value (Thin.zlibVersion);
-   end Version;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Filter : in out Filter_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      Buffer   : Stream_Element_Array (1 .. Buffer_Size);
-      In_Last  : Stream_Element_Offset;
-      Out_Last : Stream_Element_Offset;
-      In_First : Stream_Element_Offset := Item'First;
-   begin
-      if Item'Length = 0 and Flush = No_Flush then
-         return;
-      end if;
-
-      loop
-         Translate
-           (Filter   => Filter,
-            In_Data  => Item (In_First .. Item'Last),
-            In_Last  => In_Last,
-            Out_Data => Buffer,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         if Out_Last >= Buffer'First then
-            Write (Buffer (1 .. Out_Last));
-         end if;
-
-         exit when In_Last = Item'Last or Stream_End (Filter);
-
-         In_First := In_Last + 1;
-      end loop;
-   end Write;
-
-end ZLib;
diff --git a/contrib/zlib/contrib/ada/zlib.ads b/contrib/zlib/contrib/ada/zlib.ads
deleted file mode 100644
index 79ffc4095..000000000
--- a/contrib/zlib/contrib/ada/zlib.ads
+++ /dev/null
@@ -1,328 +0,0 @@
-------------------------------------------------------------------------------
---                      ZLib for Ada thick binding.                         --
---                                                                          --
---              Copyright (C) 2002-2004 Dmitriy Anisimkov                   --
---                                                                          --
---  This library is free software; you can redistribute it and/or modify    --
---  it under the terms of the GNU General Public License as published by    --
---  the Free Software Foundation; either version 2 of the License, or (at   --
---  your option) any later version.                                         --
---                                                                          --
---  This library is distributed in the hope that it will be useful, but     --
---  WITHOUT ANY WARRANTY; without even the implied warranty of              --
---  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --
---  General Public License for more details.                                --
---                                                                          --
---  You should have received a copy of the GNU General Public License       --
---  along with this library; if not, write to the Free Software Foundation, --
---  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --
---                                                                          --
---  As a special exception, if other files instantiate generics from this   --
---  unit, or you link this unit with other files to produce an executable,  --
---  this  unit  does not  by itself cause  the resulting executable to be   --
---  covered by the GNU General Public License. This exception does not      --
---  however invalidate any other reasons why the executable file  might be  --
---  covered by the  GNU Public License.                                     --
-------------------------------------------------------------------------------
-
---  $Id: zlib.ads,v 1.26 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Streams;
-
-with Interfaces;
-
-package ZLib is
-
-   ZLib_Error   : exception;
-   Status_Error : exception;
-
-   type Compression_Level is new Integer range -1 .. 9;
-
-   type Flush_Mode is private;
-
-   type Compression_Method is private;
-
-   type Window_Bits_Type is new Integer range 8 .. 15;
-
-   type Memory_Level_Type is new Integer range 1 .. 9;
-
-   type Unsigned_32 is new Interfaces.Unsigned_32;
-
-   type Strategy_Type is private;
-
-   type Header_Type is (None, Auto, Default, GZip);
-   --  Header type usage have a some limitation for inflate.
-   --  See comment for Inflate_Init.
-
-   subtype Count is Ada.Streams.Stream_Element_Count;
-
-   Default_Memory_Level : constant Memory_Level_Type := 8;
-   Default_Window_Bits  : constant Window_Bits_Type  := 15;
-
-   ----------------------------------
-   -- Compression method constants --
-   ----------------------------------
-
-   Deflated : constant Compression_Method;
-   --  Only one method allowed in this ZLib version
-
-   ---------------------------------
-   -- Compression level constants --
-   ---------------------------------
-
-   No_Compression      : constant Compression_Level := 0;
-   Best_Speed          : constant Compression_Level := 1;
-   Best_Compression    : constant Compression_Level := 9;
-   Default_Compression : constant Compression_Level := -1;
-
-   --------------------------
-   -- Flush mode constants --
-   --------------------------
-
-   No_Flush      : constant Flush_Mode;
-   --  Regular way for compression, no flush
-
-   Partial_Flush : constant Flush_Mode;
-   --  Will be removed, use Z_SYNC_FLUSH instead
-
-   Sync_Flush    : constant Flush_Mode;
-   --  All pending output is flushed to the output buffer and the output
-   --  is aligned on a byte boundary, so that the decompressor can get all
-   --  input data available so far. (In particular avail_in is zero after the
-   --  call if enough output space has been provided  before the call.)
-   --  Flushing may degrade compression for some compression algorithms and so
-   --  it should be used only when necessary.
-
-   Block_Flush   : constant Flush_Mode;
-   --  Z_BLOCK requests that inflate() stop
-   --  if and when it get to the next deflate block boundary. When decoding the
-   --  zlib or gzip format, this will cause inflate() to return immediately
-   --  after the header and before the first block. When doing a raw inflate,
-   --  inflate() will go ahead and process the first block, and will return
-   --  when it gets to the end of that block, or when it runs out of data.
-
-   Full_Flush    : constant Flush_Mode;
-   --  All output is flushed as with SYNC_FLUSH, and the compression state
-   --  is reset so that decompression can restart from this point if previous
-   --  compressed data has been damaged or if random access is desired. Using
-   --  Full_Flush too often can seriously degrade the compression.
-
-   Finish        : constant Flush_Mode;
-   --  Just for tell the compressor that input data is complete.
-
-   ------------------------------------
-   -- Compression strategy constants --
-   ------------------------------------
-
-   --  RLE stategy could be used only in version 1.2.0 and later.
-
-   Filtered         : constant Strategy_Type;
-   Huffman_Only     : constant Strategy_Type;
-   RLE              : constant Strategy_Type;
-   Default_Strategy : constant Strategy_Type;
-
-   Default_Buffer_Size : constant := 4096;
-
-   type Filter_Type is tagged limited private;
-   --  The filter is for compression and for decompression.
-   --  The usage of the type is depend of its initialization.
-
-   function Version return String;
-   pragma Inline (Version);
-   --  Return string representation of the ZLib version.
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default);
-   --  Compressor initialization.
-   --  When Header parameter is Auto or Default, then default zlib header
-   --  would be provided for compressed data.
-   --  When Header is GZip, then gzip header would be set instead of
-   --  default header.
-   --  When Header is None, no header would be set for compressed data.
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default);
-   --  Decompressor initialization.
-   --  Default header type mean that ZLib default header is expecting in the
-   --  input compressed stream.
-   --  Header type None mean that no header is expecting in the input stream.
-   --  GZip header type mean that GZip header is expecting in the
-   --  input compressed stream.
-   --  Auto header type mean that header type (GZip or Native) would be
-   --  detected automatically in the input stream.
-   --  Note that header types parameter values None, GZip and Auto are
-   --  supported for inflate routine only in ZLib versions 1.2.0.2 and later.
-   --  Deflate_Init is supporting all header types.
-
-   function Is_Open (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Is_Open);
-   --  Is the filter opened for compression or decompression.
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False);
-   --  Closing the compression or decompressor.
-   --  If stream is closing before the complete and Ignore_Error is False,
-   --  The exception would be raised.
-
-   generic
-      with procedure Data_In
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      with procedure Data_Out
-        (Item : in Ada.Streams.Stream_Element_Array);
-   procedure Generic_Translate
-     (Filter          : in out Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size);
-   --  Compress/decompress data fetch from Data_In routine and pass the result
-   --  to the Data_Out routine. User should provide Data_In and Data_Out
-   --  for compression/decompression data flow.
-   --  Compression or decompression depend on Filter initialization.
-
-   function Total_In (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_In);
-   --  Returns total number of input bytes read so far
-
-   function Total_Out (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_Out);
-   --  Returns total number of bytes output so far
-
-   function CRC32
-     (CRC    : in Unsigned_32;
-      Data   : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32;
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array);
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   -------------------------------------------------
-   --  Below is more complex low level routines.  --
-   -------------------------------------------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Compress/decompress the In_Data buffer and place the result into
-   --  Out_Data. In_Last is the index of last element from In_Data accepted by
-   --  the Filter. Out_Last is the last element of the received data from
-   --  Filter. To tell the filter that incoming data are complete put the
-   --  Flush parameter to Finish.
-
-   function Stream_End (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Stream_End);
-   --  Return the true when the stream is complete.
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   pragma Inline (Flush);
-   --  Flushing the data from the compressor.
-
-   generic
-      with procedure Write
-        (Item : in Ada.Streams.Stream_Element_Array);
-      --  User should provide this routine for accept
-      --  compressed/decompressed data.
-
-      Buffer_Size : in Ada.Streams.Stream_Element_Offset
-         := Default_Buffer_Size;
-      --  Buffer size for Write user routine.
-
-   procedure Write
-     (Filter  : in out Filter_Type;
-      Item    : in     Ada.Streams.Stream_Element_Array;
-      Flush   : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from Item to the generic parameter procedure
-   --  Write. Output buffer size could be set in Buffer_Size generic parameter.
-
-   generic
-      with procedure Read
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      --  User should provide data for compression/decompression
-      --  thru this routine.
-
-      Buffer : in out Ada.Streams.Stream_Element_Array;
-      --  Buffer for keep remaining data from the previous
-      --  back read.
-
-      Rest_First, Rest_Last : in out Ada.Streams.Stream_Element_Offset;
-      --  Rest_First have to be initialized to Buffer'Last + 1
-      --  Rest_Last have to be initialized to Buffer'Last
-      --  before usage.
-
-      Allow_Read_Some : in Boolean := False;
-      --  Is it allowed to return Last < Item'Last before end of data.
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from generic parameter procedure Read to the
-   --  Item. User should provide Buffer and initialized Rest_First, Rest_Last
-   --  indicators. If Allow_Read_Some is True, Read routines could return
-   --  Last < Item'Last only at end of stream.
-
-private
-
-   use Ada.Streams;
-
-   pragma Assert (Ada.Streams.Stream_Element'Size    =    8);
-   pragma Assert (Ada.Streams.Stream_Element'Modulus = 2**8);
-
-   type Flush_Mode is new Integer range 0 .. 5;
-
-   type Compression_Method is new Integer range 8 .. 8;
-
-   type Strategy_Type is new Integer range 0 .. 3;
-
-   No_Flush      : constant Flush_Mode := 0;
-   Partial_Flush : constant Flush_Mode := 1;
-   Sync_Flush    : constant Flush_Mode := 2;
-   Full_Flush    : constant Flush_Mode := 3;
-   Finish        : constant Flush_Mode := 4;
-   Block_Flush   : constant Flush_Mode := 5;
-
-   Filtered         : constant Strategy_Type := 1;
-   Huffman_Only     : constant Strategy_Type := 2;
-   RLE              : constant Strategy_Type := 3;
-   Default_Strategy : constant Strategy_Type := 0;
-
-   Deflated : constant Compression_Method := 8;
-
-   type Z_Stream;
-
-   type Z_Stream_Access is access all Z_Stream;
-
-   type Filter_Type is tagged limited record
-      Strm        : Z_Stream_Access;
-      Compression : Boolean;
-      Stream_End  : Boolean;
-      Header      : Header_Type;
-      CRC         : Unsigned_32;
-      Offset      : Stream_Element_Offset;
-      --  Offset for gzip header/footer output.
-   end record;
-
-end ZLib;
diff --git a/contrib/zlib/contrib/ada/zlib.gpr b/contrib/zlib/contrib/ada/zlib.gpr
deleted file mode 100644
index 296b22aa9..000000000
--- a/contrib/zlib/contrib/ada/zlib.gpr
+++ /dev/null
@@ -1,20 +0,0 @@
-project Zlib is
-
-   for Languages use ("Ada");
-   for Source_Dirs use (".");
-   for Object_Dir use ".";
-   for Main use ("test.adb", "mtest.adb", "read.adb", "buffer_demo");
-
-   package Compiler is
-      for Default_Switches ("ada") use ("-gnatwcfilopru", "-gnatVcdfimorst", "-gnatyabcefhiklmnoprst");
-   end Compiler;
-
-   package Linker is
-      for Default_Switches ("ada") use ("-lz");
-   end Linker;
-
-   package Builder is
-      for Default_Switches ("ada") use ("-s", "-gnatQ");
-   end Builder;
-
-end Zlib;
diff --git a/contrib/zlib/contrib/amd64/amd64-match.S b/contrib/zlib/contrib/amd64/amd64-match.S
deleted file mode 100644
index 81d4a1c94..000000000
--- a/contrib/zlib/contrib/amd64/amd64-match.S
+++ /dev/null
@@ -1,452 +0,0 @@
-/*
- * match.S -- optimized version of longest_match()
- * based on the similar work by Gilles Vollant, and Brian Raiter, written 1998
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the BSD License. Use by owners of Che Guevarra
- * parafernalia is prohibited, where possible, and highly discouraged
- * elsewhere.
- */
-
-#ifndef NO_UNDERLINE
-#	define	match_init	_match_init
-#	define	longest_match	_longest_match
-#endif
-
-#define	scanend		ebx
-#define	scanendw	bx
-#define	chainlenwmask	edx /* high word: current chain len low word: s->wmask */
-#define	curmatch	rsi
-#define	curmatchd	esi
-#define	windowbestlen	r8
-#define	scanalign	r9
-#define	scanalignd	r9d
-#define	window		r10
-#define	bestlen		r11
-#define	bestlend	r11d
-#define	scanstart	r12d
-#define	scanstartw	r12w
-#define scan		r13
-#define nicematch	r14d
-#define	limit		r15
-#define	limitd		r15d
-#define prev		rcx
-
-/*
- * The 258 is a "magic number, not a parameter -- changing it
- * breaks the hell loose
- */
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-#define	LocalVarsSize	(112)
-#define _chainlenwmask	( 8-LocalVarsSize)(%rsp)
-#define _windowbestlen	(16-LocalVarsSize)(%rsp)
-#define save_r14        (24-LocalVarsSize)(%rsp)
-#define save_rsi        (32-LocalVarsSize)(%rsp)
-#define save_rbx        (40-LocalVarsSize)(%rsp)
-#define save_r12        (56-LocalVarsSize)(%rsp)
-#define save_r13        (64-LocalVarsSize)(%rsp)
-#define save_r15        (80-LocalVarsSize)(%rsp)
-
-
-.globl	match_init, longest_match
-
-/*
- * On AMD64 the first argument of a function (in our case -- the pointer to
- * deflate_state structure) is passed in %rdi, hence our offsets below are
- * all off of that.
- */
-
-/* you can check the structure offset by running
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "deflate.h"
-
-void print_depl()
-{
-deflate_state ds;
-deflate_state *s=&ds;
-printf("size pointer=%u\n",(int)sizeof(void*));
-
-printf("#define dsWSize         (%3u)(%%rdi)\n",(int)(((char*)&(s->w_size))-((char*)s)));
-printf("#define dsWMask         (%3u)(%%rdi)\n",(int)(((char*)&(s->w_mask))-((char*)s)));
-printf("#define dsWindow        (%3u)(%%rdi)\n",(int)(((char*)&(s->window))-((char*)s)));
-printf("#define dsPrev          (%3u)(%%rdi)\n",(int)(((char*)&(s->prev))-((char*)s)));
-printf("#define dsMatchLen      (%3u)(%%rdi)\n",(int)(((char*)&(s->match_length))-((char*)s)));
-printf("#define dsPrevMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->prev_match))-((char*)s)));
-printf("#define dsStrStart      (%3u)(%%rdi)\n",(int)(((char*)&(s->strstart))-((char*)s)));
-printf("#define dsMatchStart    (%3u)(%%rdi)\n",(int)(((char*)&(s->match_start))-((char*)s)));
-printf("#define dsLookahead     (%3u)(%%rdi)\n",(int)(((char*)&(s->lookahead))-((char*)s)));
-printf("#define dsPrevLen       (%3u)(%%rdi)\n",(int)(((char*)&(s->prev_length))-((char*)s)));
-printf("#define dsMaxChainLen   (%3u)(%%rdi)\n",(int)(((char*)&(s->max_chain_length))-((char*)s)));
-printf("#define dsGoodMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->good_match))-((char*)s)));
-printf("#define dsNiceMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->nice_match))-((char*)s)));
-}
-
-*/
-
-
-/*
-  to compile for XCode 3.2 on MacOSX x86_64
-  - run "gcc -g -c -DXCODE_MAC_X64_STRUCTURE amd64-match.S"
- */
-
-
-#ifndef CURRENT_LINX_XCODE_MAC_X64_STRUCTURE
-#define dsWSize		( 68)(%rdi)
-#define dsWMask		( 76)(%rdi)
-#define dsWindow	( 80)(%rdi)
-#define dsPrev		( 96)(%rdi)
-#define dsMatchLen	(144)(%rdi)
-#define dsPrevMatch	(148)(%rdi)
-#define dsStrStart	(156)(%rdi)
-#define dsMatchStart	(160)(%rdi)
-#define dsLookahead	(164)(%rdi)
-#define dsPrevLen	(168)(%rdi)
-#define dsMaxChainLen	(172)(%rdi)
-#define dsGoodMatch	(188)(%rdi)
-#define dsNiceMatch	(192)(%rdi)
-
-#else 
-
-#ifndef STRUCT_OFFSET
-#	define STRUCT_OFFSET	(0)
-#endif
-
-
-#define dsWSize		( 56 + STRUCT_OFFSET)(%rdi)
-#define dsWMask		( 64 + STRUCT_OFFSET)(%rdi)
-#define dsWindow	( 72 + STRUCT_OFFSET)(%rdi)
-#define dsPrev		( 88 + STRUCT_OFFSET)(%rdi)
-#define dsMatchLen	(136 + STRUCT_OFFSET)(%rdi)
-#define dsPrevMatch	(140 + STRUCT_OFFSET)(%rdi)
-#define dsStrStart	(148 + STRUCT_OFFSET)(%rdi)
-#define dsMatchStart	(152 + STRUCT_OFFSET)(%rdi)
-#define dsLookahead	(156 + STRUCT_OFFSET)(%rdi)
-#define dsPrevLen	(160 + STRUCT_OFFSET)(%rdi)
-#define dsMaxChainLen	(164 + STRUCT_OFFSET)(%rdi)
-#define dsGoodMatch	(180 + STRUCT_OFFSET)(%rdi)
-#define dsNiceMatch	(184 + STRUCT_OFFSET)(%rdi)
-
-#endif
-
-
-
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-
-longest_match:
-/*
- * Retrieve the function arguments. %curmatch will hold cur_match
- * throughout the entire function (passed via rsi on amd64).
- * rdi will hold the pointer to the deflate_state (first arg on amd64)
- */
-		mov     %rsi, save_rsi
-		mov     %rbx, save_rbx
-		mov	%r12, save_r12
-		mov     %r13, save_r13
-		mov     %r14, save_r14
-		mov     %r15, save_r15
-
-/* uInt wmask = s->w_mask;						*/
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
-
-		movl	dsPrevLen, %eax
-		movl	dsGoodMatch, %ebx
-		cmpl	%ebx, %eax
-		movl	dsWMask, %eax
-		movl	dsMaxChainLen, %chainlenwmask
-		jl	LastMatchGood
-		shrl	$2, %chainlenwmask
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the wmask	*/
-/* value, which it will always accompany.				*/
-
-		decl	%chainlenwmask
-		shll	$16, %chainlenwmask
-		orl	%eax, %chainlenwmask
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch, %eax
-		movl	dsLookahead, %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, %nicematch
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		mov	dsWindow, %window
-		movl	dsStrStart, %limitd
-		lea	(%limit, %window), %scan
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		mov	%scan, %scanalign
-		negl	%scanalignd
-		andl	$3, %scanalignd
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize, %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		xorl	%ecx, %ecx
-		subl	%eax, %limitd
-		cmovng	%ecx, %limitd
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen, %bestlend
-
-/* Store the sum of s->window + best_len in %windowbestlen locally, and in memory.	*/
-
-		lea	(%window, %bestlen), %windowbestlen
-		mov	%windowbestlen, _windowbestlen
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-/* Posf *prev = s->prev;						*/
-
-		movzwl	(%scan), %scanstart
-		movzwl	-1(%scan, %bestlen), %scanend
-		mov	dsPrev, %prev
-
-/* Jump into the main loop.						*/
-
-		movl	%chainlenwmask, _chainlenwmask
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- */
-LookupLoop:
-		andl	%chainlenwmask, %curmatchd
-		movzwl	(%prev, %curmatch, 2), %curmatchd
-		cmpl	%limitd, %curmatchd
-		jbe	LeaveNow
-		subl	$0x00010000, %chainlenwmask
-		js	LeaveNow
-LoopEntry:	cmpw	-1(%windowbestlen, %curmatch), %scanendw
-		jne	LookupLoop
-		cmpw	%scanstartw, (%window, %curmatch)
-		jne	LookupLoop
-
-/* Store the current value of chainlen.					*/
-		movl	%chainlenwmask, _chainlenwmask
-
-/* %scan is the string under scrutiny, and %prev to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		mov	$(-MAX_MATCH_8), %rdx
-		lea	(%curmatch, %window), %windowbestlen
-		lea	MAX_MATCH_8(%windowbestlen, %scanalign), %windowbestlen
-		lea	MAX_MATCH_8(%scan, %scanalign), %prev
-
-/* the prefetching below makes very little difference... */
-		prefetcht1	(%windowbestlen, %rdx)
-		prefetcht1	(%prev, %rdx)
-
-/*
- * Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %rdx so that it is offset to the exact byte that mismatched.
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance -- unrolling it, for example, makes no difference.
- */
-
-#undef USE_SSE	/* works, but is 6-7% slower, than non-SSE... */
-
-LoopCmps:
-#ifdef USE_SSE
-		/* Preload the SSE registers */
-		movdqu	  (%windowbestlen, %rdx), %xmm1
-		movdqu	  (%prev, %rdx), %xmm2
-		pcmpeqb	%xmm2, %xmm1
-		movdqu	16(%windowbestlen, %rdx), %xmm3
-		movdqu	16(%prev, %rdx), %xmm4
-		pcmpeqb	%xmm4, %xmm3
-		movdqu	32(%windowbestlen, %rdx), %xmm5
-		movdqu	32(%prev, %rdx), %xmm6
-		pcmpeqb	%xmm6, %xmm5
-		movdqu	48(%windowbestlen, %rdx), %xmm7
-		movdqu	48(%prev, %rdx), %xmm8
-		pcmpeqb	%xmm8, %xmm7
-
-		/* Check the comparisions' results */
-		pmovmskb %xmm1, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		/* this is the only iteration of the loop with a possibility of having
-		   incremented rdx by 0x108 (each loop iteration add 16*4 = 0x40 
-		   and (0x40*4)+8=0x108 */
-		add	$8, %rdx
-		jz LenMaximum
-		add	$8, %rdx
-
-		
-		pmovmskb %xmm3, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		
-		add	$16, %rdx
-
-
-		pmovmskb %xmm5, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		add	$16, %rdx
-
-
-		pmovmskb %xmm7, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		add	$16, %rdx
-		
-		jmp	LoopCmps
-LeaveLoopCmps:	add	%rax, %rdx
-#else
-		mov	(%windowbestlen, %rdx), %rax
-		xor	(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps
-		
-		mov	8(%windowbestlen, %rdx), %rax
-		xor	8(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps8
-
-		mov	16(%windowbestlen, %rdx), %rax
-		xor	16(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps16
-				
-		add	$24, %rdx
-		jnz	LoopCmps
-		jmp	LenMaximum
-#	if 0
-/*
- * This three-liner is tantalizingly simple, but bsf is a slow instruction,
- * and the complicated alternative down below is quite a bit faster. Sad...
- */
-
-LeaveLoopCmps:	bsf	%rax, %rax /* find the first non-zero bit */
-		shrl	$3, %eax /* divide by 8 to get the byte */
-		add	%rax, %rdx
-#	else
-LeaveLoopCmps16:
-		add	$8, %rdx
-LeaveLoopCmps8:
-		add	$8, %rdx
-LeaveLoopCmps:	testl   $0xFFFFFFFF, %eax /* Check the first 4 bytes */
-		jnz     Check16
-		add     $4, %rdx
-		shr     $32, %rax
-Check16:        testw   $0xFFFF, %ax
-		jnz     LenLower
-		add	$2, %rdx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adc	$0, %rdx
-#	endif
-#endif
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%prev, %rdx), %rax
-		sub	%scan, %rax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		cmpl	%bestlend, %eax
-		jg	LongerMatch
-		mov	_windowbestlen, %windowbestlen
-		mov	dsPrev, %prev
-		movl	_chainlenwmask, %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:
-		movl	%eax, %bestlend
-		movl	%curmatchd, dsMatchStart
-		cmpl	%nicematch, %eax
-		jge	LeaveNow
-
-		lea	(%window, %bestlen), %windowbestlen
-		mov	%windowbestlen, _windowbestlen
-
-		movzwl	-1(%scan, %rax), %scanend
-		mov	dsPrev, %prev
-		movl	_chainlenwmask, %chainlenwmask
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:
-		movl	$MAX_MATCH, %bestlend
-		movl	%curmatchd, dsMatchStart
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	dsLookahead, %eax
-		cmpl	%eax, %bestlend
-		cmovngl	%bestlend, %eax
-LookaheadRet:
-
-/* Restore the registers and return from whence we came.			*/
-
-	mov	save_rsi, %rsi
-	mov	save_rbx, %rbx
-	mov	save_r12, %r12
-	mov	save_r13, %r13
-	mov	save_r14, %r14
-	mov	save_r15, %r15
-
-	ret
-
-match_init:	ret
diff --git a/contrib/zlib/contrib/asm686/README.686 b/contrib/zlib/contrib/asm686/README.686
deleted file mode 100644
index a0bf3bea4..000000000
--- a/contrib/zlib/contrib/asm686/README.686
+++ /dev/null
@@ -1,51 +0,0 @@
-This is a patched version of zlib, modified to use
-Pentium-Pro-optimized assembly code in the deflation algorithm. The
-files changed/added by this patch are:
-
-README.686
-match.S
-
-The speedup that this patch provides varies, depending on whether the
-compiler used to build the original version of zlib falls afoul of the
-PPro's speed traps. My own tests show a speedup of around 10-20% at
-the default compression level, and 20-30% using -9, against a version
-compiled using gcc 2.7.2.3. Your mileage may vary.
-
-Note that this code has been tailored for the PPro/PII in particular,
-and will not perform particuarly well on a Pentium.
-
-If you are using an assembler other than GNU as, you will have to
-translate match.S to use your assembler's syntax. (Have fun.)
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 1998
-
-
-Added for zlib 1.1.3:
-
-The patches come from
-http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-To compile zlib with this asm file, copy match.S to the zlib directory
-then do:
-
-CFLAGS="-O3 -DASMV" ./configure
-make OBJA=match.o
-
-
-Update:
-
-I've been ignoring these assembly routines for years, believing that
-gcc's generated code had caught up with it sometime around gcc 2.95
-and the major rearchitecting of the Pentium 4. However, I recently
-learned that, despite what I believed, this code still has some life
-in it. On the Pentium 4 and AMD64 chips, it continues to run about 8%
-faster than the code produced by gcc 4.1.
-
-In acknowledgement of its continuing usefulness, I've altered the
-license to match that of the rest of zlib. Share and Enjoy!
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 2007
diff --git a/contrib/zlib/contrib/asm686/match.S b/contrib/zlib/contrib/asm686/match.S
deleted file mode 100644
index fa4210927..000000000
--- a/contrib/zlib/contrib/asm686/match.S
+++ /dev/null
@@ -1,357 +0,0 @@
-/* match.S -- x86 assembly version of the zlib longest_match() function.
- * Optimized for the Intel 686 chips (PPro and later).
- *
- * Copyright (C) 1998, 2007 Brian Raiter <breadbox@muppetlabs.com>
- *
- * This software is provided 'as-is', without any express or implied
- * warranty.  In no event will the author be held liable for any damages
- * arising from the use of this software.
- *
- * Permission is granted to anyone to use this software for any purpose,
- * including commercial applications, and to alter it and redistribute it
- * freely, subject to the following restrictions:
- *
- * 1. The origin of this software must not be misrepresented; you must not
- *    claim that you wrote the original software. If you use this software
- *    in a product, an acknowledgment in the product documentation would be
- *    appreciated but is not required.
- * 2. Altered source versions must be plainly marked as such, and must not be
- *    misrepresented as being the original software.
- * 3. This notice may not be removed or altered from any source distribution.
- */
-
-#ifndef NO_UNDERLINE
-#define	match_init	_match_init
-#define	longest_match	_longest_match
-#endif
-
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-
-#define	chainlenwmask		0	/* high word: current chain len	*/
-					/* low word: s->wmask		*/
-#define	window			4	/* local copy of s->window	*/
-#define	windowbestlen		8	/* s->window + bestlen		*/
-#define	scanstart		16	/* first two bytes of string	*/
-#define	scanend			12	/* last two bytes of string	*/
-#define	scanalign		20	/* dword-misalignment of string	*/
-#define	nicematch		24	/* a good enough match size	*/
-#define	bestlen			28	/* size of best match so far	*/
-#define	scan			32	/* ptr to string wanting match	*/
-
-#define	LocalVarsSize		(36)
-/*	saved ebx		36 */
-/*	saved edi		40 */
-/*	saved esi		44 */
-/*	saved ebp		48 */
-/*	return address		52 */
-#define	deflatestate		56	/* the function arguments	*/
-#define	curmatch		60
-
-/* All the +zlib1222add offsets are due to the addition of fields
- *  in zlib in the deflate_state structure since the asm code was first written
- * (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
- * (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
- * if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
- */
-
-#define zlib1222add		(8)
-
-#define	dsWSize			(36+zlib1222add)
-#define	dsWMask			(44+zlib1222add)
-#define	dsWindow		(48+zlib1222add)
-#define	dsPrev			(56+zlib1222add)
-#define	dsMatchLen		(88+zlib1222add)
-#define	dsPrevMatch		(92+zlib1222add)
-#define	dsStrStart		(100+zlib1222add)
-#define	dsMatchStart		(104+zlib1222add)
-#define	dsLookahead		(108+zlib1222add)
-#define	dsPrevLen		(112+zlib1222add)
-#define	dsMaxChainLen		(116+zlib1222add)
-#define	dsGoodMatch		(132+zlib1222add)
-#define	dsNiceMatch		(136+zlib1222add)
-
-
-.file "match.S"
-
-.globl	match_init, longest_match
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-.cfi_sections	.debug_frame
-
-longest_match:
-
-.cfi_startproc
-/* Save registers that the compiler may be using, and adjust %esp to	*/
-/* make room for our stack frame.					*/
-
-		pushl	%ebp
-		.cfi_def_cfa_offset 8
-		.cfi_offset ebp, -8
-		pushl	%edi
-		.cfi_def_cfa_offset 12
-		pushl	%esi
-		.cfi_def_cfa_offset 16
-		pushl	%ebx
-		.cfi_def_cfa_offset 20
-		subl	$LocalVarsSize, %esp
-		.cfi_def_cfa_offset LocalVarsSize+20
-
-/* Retrieve the function arguments. %ecx will hold cur_match		*/
-/* throughout the entire function. %edx will hold the pointer to the	*/
-/* deflate_state structure during the function's setup (before		*/
-/* entering the main loop).						*/
-
-		movl	deflatestate(%esp), %edx
-		movl	curmatch(%esp), %ecx
-
-/* uInt wmask = s->w_mask;						*/
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
- 
-		movl	dsPrevLen(%edx), %eax
-		movl	dsGoodMatch(%edx), %ebx
-		cmpl	%ebx, %eax
-		movl	dsWMask(%edx), %eax
-		movl	dsMaxChainLen(%edx), %ebx
-		jl	LastMatchGood
-		shrl	$2, %ebx
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the wmask	*/
-/* value, which it will always accompany.				*/
-
-		decl	%ebx
-		shll	$16, %ebx
-		orl	%eax, %ebx
-		movl	%ebx, chainlenwmask(%esp)
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch(%edx), %eax
-		movl	dsLookahead(%edx), %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, nicematch(%esp)
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		movl	dsWindow(%edx), %esi
-		movl	%esi, window(%esp)
-		movl	dsStrStart(%edx), %ebp
-		lea	(%esi,%ebp), %edi
-		movl	%edi, scan(%esp)
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		movl	%edi, %eax
-		negl	%eax
-		andl	$3, %eax
-		movl	%eax, scanalign(%esp)
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize(%edx), %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		subl	%eax, %ebp
-		jg	LimitPositive
-		xorl	%ebp, %ebp
-LimitPositive:
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	%eax, bestlen(%esp)
-
-/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
-
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-/* Posf *prev = s->prev;						*/
-
-		movzwl	(%edi), %ebx
-		movl	%ebx, scanstart(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	%ebx, scanend(%esp)
-		movl	dsPrev(%edx), %edi
-
-/* Jump into the main loop.						*/
-
-		movl	chainlenwmask(%esp), %edx
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- *
- * Within this loop:
- * %ebx = scanend
- * %ecx = curmatch
- * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
- * %esi = windowbestlen - i.e., (window + bestlen)
- * %edi = prev
- * %ebp = limit
- */
-LookupLoop:
-		andl	%edx, %ecx
-		movzwl	(%edi,%ecx,2), %ecx
-		cmpl	%ebp, %ecx
-		jbe	LeaveNow
-		subl	$0x00010000, %edx
-		js	LeaveNow
-LoopEntry:	movzwl	-1(%esi,%ecx), %eax
-		cmpl	%ebx, %eax
-		jnz	LookupLoop
-		movl	window(%esp), %eax
-		movzwl	(%eax,%ecx), %eax
-		cmpl	scanstart(%esp), %eax
-		jnz	LookupLoop
-
-/* Store the current value of chainlen.					*/
-
-		movl	%edx, chainlenwmask(%esp)
-
-/* Point %edi to the string under scrutiny, and %esi to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		movl	window(%esp), %esi
-		movl	scan(%esp), %edi
-		addl	%ecx, %esi
-		movl	scanalign(%esp), %eax
-		movl	$(-MAX_MATCH_8), %edx
-		lea	MAX_MATCH_8(%edi,%eax), %edi
-		lea	MAX_MATCH_8(%esi,%eax), %esi
-
-/* Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %edx so that it is offset to the exact byte that mismatched.
- *
- * We already know at this point that the first three bytes of the
- * strings match each other, and they can be safely passed over before
- * starting the compare loop. So what this code does is skip over 0-3
- * bytes, as much as necessary in order to dword-align the %edi
- * pointer. (%esi will still be misaligned three times out of four.)
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance.
- */
-LoopCmps:
-		movl	(%esi,%edx), %eax
-		xorl	(%edi,%edx), %eax
-		jnz	LeaveLoopCmps
-		movl	4(%esi,%edx), %eax
-		xorl	4(%edi,%edx), %eax
-		jnz	LeaveLoopCmps4
-		addl	$8, %edx
-		jnz	LoopCmps
-		jmp	LenMaximum
-LeaveLoopCmps4:	addl	$4, %edx
-LeaveLoopCmps:	testl	$0x0000FFFF, %eax
-		jnz	LenLower
-		addl	$2, %edx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adcl	$0, %edx
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%edi,%edx), %eax
-		movl	scan(%esp), %edi
-		subl	%edi, %eax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		cmpl	%ebx, %eax
-		jg	LongerMatch
-		movl	windowbestlen(%esp), %esi
-		movl	dsPrev(%edx), %edi
-		movl	scanend(%esp), %ebx
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:	movl	nicematch(%esp), %ebx
-		movl	%eax, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-		cmpl	%ebx, %eax
-		jge	LeaveNow
-		movl	window(%esp), %esi
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	dsPrev(%edx), %edi
-		movl	%ebx, scanend(%esp)
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:	movl	deflatestate(%esp), %edx
-		movl	$MAX_MATCH, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		movl	dsLookahead(%edx), %eax
-		cmpl	%eax, %ebx
-		jg	LookaheadRet
-		movl	%ebx, %eax
-LookaheadRet:
-
-/* Restore the stack and return from whence we came.			*/
-
-		addl	$LocalVarsSize, %esp
-		.cfi_def_cfa_offset 20
-		popl	%ebx
-		.cfi_def_cfa_offset 16
-		popl	%esi
-		.cfi_def_cfa_offset 12
-		popl	%edi
-		.cfi_def_cfa_offset 8
-		popl	%ebp
-		.cfi_def_cfa_offset 4
-.cfi_endproc
-match_init:	ret
diff --git a/contrib/zlib/contrib/blast/README b/contrib/zlib/contrib/blast/README
deleted file mode 100644
index e3a60b3f5..000000000
--- a/contrib/zlib/contrib/blast/README
+++ /dev/null
@@ -1,4 +0,0 @@
-Read blast.h for purpose and usage.
-
-Mark Adler
-madler@alumni.caltech.edu
diff --git a/contrib/zlib/contrib/blast/blast.c b/contrib/zlib/contrib/blast/blast.c
deleted file mode 100644
index e6e659073..000000000
--- a/contrib/zlib/contrib/blast/blast.c
+++ /dev/null
@@ -1,466 +0,0 @@
-/* blast.c
- * Copyright (C) 2003, 2012, 2013 Mark Adler
- * For conditions of distribution and use, see copyright notice in blast.h
- * version 1.3, 24 Aug 2013
- *
- * blast.c decompresses data compressed by the PKWare Compression Library.
- * This function provides functionality similar to the explode() function of
- * the PKWare library, hence the name "blast".
- *
- * This decompressor is based on the excellent format description provided by
- * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the
- * example Ben provided in the post is incorrect.  The distance 110001 should
- * instead be 111000.  When corrected, the example byte stream becomes:
- *
- *    00 04 82 24 25 8f 80 7f
- *
- * which decompresses to "AIAIAIAIAIAIA" (without the quotes).
- */
-
-/*
- * Change history:
- *
- * 1.0  12 Feb 2003     - First version
- * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data
- * 1.2  24 Oct 2012     - Add note about using binary mode in stdio
- *                      - Fix comparisons of differently signed integers
- * 1.3  24 Aug 2013     - Return unused input from blast()
- *                      - Fix test code to correctly report unused input
- *                      - Enable the provision of initial input to blast()
- */
-
-#include <stddef.h>             /* for NULL */
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "blast.h"              /* prototype for blast() */
-
-#define local static            /* for local function definitions */
-#define MAXBITS 13              /* maximum code length */
-#define MAXWIN 4096             /* maximum window size */
-
-/* input and output state */
-struct state {
-    /* input state */
-    blast_in infun;             /* input function provided by user */
-    void *inhow;                /* opaque information passed to infun() */
-    unsigned char *in;          /* next input location */
-    unsigned left;              /* available input at in */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-
-    /* output state */
-    blast_out outfun;           /* output function provided by user */
-    void *outhow;               /* opaque information passed to outfun() */
-    unsigned next;              /* index of next write location in out[] */
-    int first;                  /* true to check distances (for first 4K) */
-    unsigned char out[MAXWIN];  /* output buffer and sliding window */
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    int val;            /* bit accumulator */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        val |= (int)(*(s->in)++) << s->bitcnt;          /* load eight bits */
-        s->left--;
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = val >> need;
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return val & ((1 << need) - 1);
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -9 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.
- *
- * - The first code for the shortest length is all ones.  Subsequent codes of
- *   the same length are simply integer decrements of the previous code.  When
- *   moving up a length, a one bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all zeros.  To support
- *   this ordering, the bits pulled during decoding are inverted to apply the
- *   more "natural" ordering starting with all zeros and incrementing.
- */
-local int decode(struct state *s, struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= (bitbuf & 1) ^ 1;   /* invert code */
-            bitbuf >>= 1;
-            count = *next++;
-            if (code < first + count) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0) break;
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        bitbuf = *(s->in)++;
-        s->left--;
-        if (left > 8) left = 8;
-    }
-    return -9;                          /* ran out of codes */
-}
-
-/*
- * Given a list of repeated code lengths rep[0..n-1], where each byte is a
- * count (high four bits + 1) and a code length (low four bits), generate the
- * list of code lengths.  This compaction reduces the size of the object code.
- * Then given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- */
-local int construct(struct huffman *h, const unsigned char *rep, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-    short length[256];  /* code lengths */
-
-    /* convert compact repeat counts into symbol bit length list */
-    symbol = 0;
-    do {
-        len = *rep++;
-        left = (len >> 4) + 1;
-        len &= 15;
-        do {
-            length[symbol++] = len;
-        } while (--left);
-    } while (--n);
-    n = symbol;
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0) return left;      /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode PKWare Compression Library stream.
- *
- * Format notes:
- *
- * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second
- *   byte is 4, 5, or 6 for the number of extra bits in the distance code.
- *   This is the base-2 logarithm of the dictionary size minus six.
- *
- * - Compressed data is a combination of literals and length/distance pairs
- *   terminated by an end code.  Literals are either Huffman coded or
- *   uncoded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - A bit preceding a literal or length/distance pair indicates which comes
- *   next, 0 for literals, 1 for length/distance.
- *
- * - If literals are uncoded, then the next eight bits are the literal, in the
- *   normal bit order in the stream, i.e. no bit-reversal is needed. Similarly,
- *   no bit reversal is needed for either the length extra bits or the distance
- *   extra bits.
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 518
- *   simply copies the last byte 518 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.
- */
-local int decomp(struct state *s)
-{
-    int lit;            /* true if literals are coded */
-    int dict;           /* log2(dictionary size) - 6 */
-    int symbol;         /* decoded symbol, extra bits for distance */
-    int len;            /* length for copy */
-    unsigned dist;      /* distance for copy */
-    int copy;           /* copy counter */
-    unsigned char *from, *to;   /* copy pointers */
-    static int virgin = 1;                              /* build tables once */
-    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */
-    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */
-    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */
-    static struct huffman litcode = {litcnt, litsym};   /* length code */
-    static struct huffman lencode = {lencnt, lensym};   /* length code */
-    static struct huffman distcode = {distcnt, distsym};/* distance code */
-        /* bit lengths of literal codes */
-    static const unsigned char litlen[] = {
-        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,
-        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,
-        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,
-        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,
-        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,
-        44, 173};
-        /* bit lengths of length codes 0..15 */
-    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};
-        /* bit lengths of distance codes 0..63 */
-    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};
-    static const short base[16] = {     /* base for length codes */
-        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};
-    static const char extra[16] = {     /* extra bits for length codes */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};
-
-    /* set up decoding tables (once--might not be thread-safe) */
-    if (virgin) {
-        construct(&litcode, litlen, sizeof(litlen));
-        construct(&lencode, lenlen, sizeof(lenlen));
-        construct(&distcode, distlen, sizeof(distlen));
-        virgin = 0;
-    }
-
-    /* read header */
-    lit = bits(s, 8);
-    if (lit > 1) return -1;
-    dict = bits(s, 8);
-    if (dict < 4 || dict > 6) return -2;
-
-    /* decode literals and length/distance pairs */
-    do {
-        if (bits(s, 1)) {
-            /* get length */
-            symbol = decode(s, &lencode);
-            len = base[symbol] + bits(s, extra[symbol]);
-            if (len == 519) break;              /* end code */
-
-            /* get distance */
-            symbol = len == 2 ? 2 : dict;
-            dist = decode(s, &distcode) << symbol;
-            dist += bits(s, symbol);
-            dist++;
-            if (s->first && dist > s->next)
-                return -3;              /* distance too far back */
-
-            /* copy length bytes from distance bytes back */
-            do {
-                to = s->out + s->next;
-                from = to - dist;
-                copy = MAXWIN;
-                if (s->next < dist) {
-                    from += copy;
-                    copy = dist;
-                }
-                copy -= s->next;
-                if (copy > len) copy = len;
-                len -= copy;
-                s->next += copy;
-                do {
-                    *to++ = *from++;
-                } while (--copy);
-                if (s->next == MAXWIN) {
-                    if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                    s->next = 0;
-                    s->first = 0;
-                }
-            } while (len != 0);
-        }
-        else {
-            /* get literal and write it */
-            symbol = lit ? decode(s, &litcode) : bits(s, 8);
-            s->out[s->next++] = symbol;
-            if (s->next == MAXWIN) {
-                if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                s->next = 0;
-                s->first = 0;
-            }
-        }
-    } while (1);
-    return 0;
-}
-
-/* See comments in blast.h */
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,
-          unsigned *left, unsigned char **in)
-{
-    struct state s;             /* input/output state */
-    int err;                    /* return value */
-
-    /* initialize input state */
-    s.infun = infun;
-    s.inhow = inhow;
-    if (left != NULL && *left) {
-        s.left = *left;
-        s.in = *in;
-    }
-    else
-        s.left = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* initialize output state */
-    s.outfun = outfun;
-    s.outhow = outhow;
-    s.next = 0;
-    s.first = 1;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */
-        err = 2;                        /*  then skip decomp(), return error */
-    else
-        err = decomp(&s);               /* decompress */
-
-    /* return unused input */
-    if (left != NULL)
-        *left = s.left;
-    if (in != NULL)
-        *in = s.left ? s.in : NULL;
-
-    /* write any leftover output and update the error code if needed */
-    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)
-        err = 1;
-    return err;
-}
-
-#ifdef TEST
-/* Example of how to use blast() */
-#include <stdio.h>
-#include <stdlib.h>
-
-#define CHUNK 16384
-
-local unsigned inf(void *how, unsigned char **buf)
-{
-    static unsigned char hold[CHUNK];
-
-    *buf = hold;
-    return fread(hold, 1, CHUNK, (FILE *)how);
-}
-
-local int outf(void *how, unsigned char *buf, unsigned len)
-{
-    return fwrite(buf, 1, len, (FILE *)how) != len;
-}
-
-/* Decompress a PKWare Compression Library stream from stdin to stdout */
-int main(void)
-{
-    int ret;
-    unsigned left;
-
-    /* decompress to stdout */
-    left = 0;
-    ret = blast(inf, stdin, outf, stdout, &left, NULL);
-    if (ret != 0)
-        fprintf(stderr, "blast error: %d\n", ret);
-
-    /* count any leftover bytes */
-    while (getchar() != EOF)
-        left++;
-    if (left)
-        fprintf(stderr, "blast warning: %u unused bytes of input\n", left);
-
-    /* return blast() error code */
-    return ret;
-}
-#endif
diff --git a/contrib/zlib/contrib/blast/blast.h b/contrib/zlib/contrib/blast/blast.h
deleted file mode 100644
index 6cf65eda1..000000000
--- a/contrib/zlib/contrib/blast/blast.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/* blast.h -- interface for blast.c
-  Copyright (C) 2003, 2012, 2013 Mark Adler
-  version 1.3, 24 Aug 2013
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * blast() decompresses the PKWare Data Compression Library (DCL) compressed
- * format.  It provides the same functionality as the explode() function in
- * that library.  (Note: PKWare overused the "implode" verb, and the format
- * used by their library implode() function is completely different and
- * incompatible with the implode compression method supported by PKZIP.)
- *
- * The binary mode for stdio functions should be used to assure that the
- * compressed data is not corrupted when read or written.  For example:
- * fopen(..., "rb") and fopen(..., "wb").
- */
-
-
-typedef unsigned (*blast_in)(void *how, unsigned char **buf);
-typedef int (*blast_out)(void *how, unsigned char *buf, unsigned len);
-/* Definitions for input/output functions passed to blast().  See below for
- * what the provided functions need to do.
- */
-
-
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,
-          unsigned *left, unsigned char **in);
-/* Decompress input to output using the provided infun() and outfun() calls.
- * On success, the return value of blast() is zero.  If there is an error in
- * the source data, i.e. it is not in the proper format, then a negative value
- * is returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.
- *
- * The input function is invoked: len = infun(how, &buf), where buf is set by
- * infun() to point to the input buffer, and infun() returns the number of
- * available bytes there.  If infun() returns zero, then blast() returns with
- * an input error.  (blast() only asks for input if it needs it.)  inhow is for
- * use by the application to pass an input descriptor to infun(), if desired.
- *
- * If left and in are not NULL and *left is not zero when blast() is called,
- * then the *left bytes are *in are consumed for input before infun() is used.
- *
- * The output function is invoked: err = outfun(how, buf, len), where the bytes
- * to be written are buf[0..len-1].  If err is not zero, then blast() returns
- * with an output error.  outfun() is always called with len <= 4096.  outhow
- * is for use by the application to pass an output descriptor to outfun(), if
- * desired.
- *
- * If there is any unused input, *left is set to the number of bytes that were
- * read and *in points to them.  Otherwise *left is set to zero and *in is set
- * to NULL.  If left or in are NULL, then they are not set.
- *
- * The return codes are:
- *
- *   2:  ran out of input before completing decompression
- *   1:  output error before completing decompression
- *   0:  successful decompression
- *  -1:  literal flag not zero or one
- *  -2:  dictionary size not in 4..6
- *  -3:  distance is too far back
- *
- * At the bottom of blast.c is an example program that uses blast() that can be
- * compiled to produce a command-line decompression filter by defining TEST.
- */
diff --git a/contrib/zlib/contrib/blast/test.pk b/contrib/zlib/contrib/blast/test.pk
deleted file mode 100644
index be10b2bbb251759ffdf6da49fadd1a3f137a54c1..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 8
PcmZQzX;M+`Z>R?V2c!aC

diff --git a/contrib/zlib/contrib/blast/test.txt b/contrib/zlib/contrib/blast/test.txt
deleted file mode 100644
index 159002de5..000000000
--- a/contrib/zlib/contrib/blast/test.txt
+++ /dev/null
@@ -1 +0,0 @@
-AIAIAIAIAIAIA
diff --git a/contrib/zlib/contrib/delphi/ZLib.pas b/contrib/zlib/contrib/delphi/ZLib.pas
deleted file mode 100644
index 060e19911..000000000
--- a/contrib/zlib/contrib/delphi/ZLib.pas
+++ /dev/null
@@ -1,557 +0,0 @@
-{*******************************************************}
-{                                                       }
-{       Borland Delphi Supplemental Components          }
-{       ZLIB Data Compression Interface Unit            }
-{                                                       }
-{       Copyright (c) 1997,99 Borland Corporation       }
-{                                                       }
-{*******************************************************}
-
-{ Updated for zlib 1.2.x by Cosmin Truta <cosmint@cs.ubbcluj.ro> }
-
-unit ZLib;
-
-interface
-
-uses SysUtils, Classes;
-
-type
-  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-  TFree = procedure (AppData, Block: Pointer); cdecl;
-
-  // Internal structure.  Ignore.
-  TZStreamRec = packed record
-    next_in: PChar;       // next input byte
-    avail_in: Integer;    // number of bytes available at next_in
-    total_in: Longint;    // total nb of input bytes read so far
-
-    next_out: PChar;      // next output byte should be put here
-    avail_out: Integer;   // remaining free space at next_out
-    total_out: Longint;   // total nb of bytes output so far
-
-    msg: PChar;           // last error message, NULL if no error
-    internal: Pointer;    // not visible by applications
-
-    zalloc: TAlloc;       // used to allocate the internal state
-    zfree: TFree;         // used to free the internal state
-    AppData: Pointer;     // private data object passed to zalloc and zfree
-
-    data_type: Integer;   // best guess about the data type: ascii or binary
-    adler: Longint;       // adler32 value of the uncompressed data
-    reserved: Longint;    // reserved for future use
-  end;
-
-  // Abstract ancestor class
-  TCustomZlibStream = class(TStream)
-  private
-    FStrm: TStream;
-    FStrmPos: Integer;
-    FOnProgress: TNotifyEvent;
-    FZRec: TZStreamRec;
-    FBuffer: array [Word] of Char;
-  protected
-    procedure Progress(Sender: TObject); dynamic;
-    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;
-    constructor Create(Strm: TStream);
-  end;
-
-{ TCompressionStream compresses data on the fly as data is written to it, and
-  stores the compressed data to another stream.
-
-  TCompressionStream is write-only and strictly sequential. Reading from the
-  stream will raise an exception. Using Seek to move the stream pointer
-  will raise an exception.
-
-  Output data is cached internally, written to the output stream only when
-  the internal output buffer is full.  All pending output data is flushed
-  when the stream is destroyed.
-
-  The Position property returns the number of uncompressed bytes of
-  data that have been written to the stream so far.
-
-  CompressionRate returns the on-the-fly percentage by which the original
-  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100
-  If raw data size = 100 and compressed data size = 25, the CompressionRate
-  is 75%
-
-  The OnProgress event is called each time the output buffer is filled and
-  written to the output stream.  This is useful for updating a progress
-  indicator when you are writing a large chunk of data to the compression
-  stream in a single call.}
-
-
-  TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  TCompressionStream = class(TCustomZlibStream)
-  private
-    function GetCompressionRate: Single;
-  public
-    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property CompressionRate: Single read GetCompressionRate;
-    property OnProgress;
-  end;
-
-{ TDecompressionStream decompresses data on the fly as data is read from it.
-
-  Compressed data comes from a separate source stream.  TDecompressionStream
-  is read-only and unidirectional; you can seek forward in the stream, but not
-  backwards.  The special case of setting the stream position to zero is
-  allowed.  Seeking forward decompresses data until the requested position in
-  the uncompressed data has been reached.  Seeking backwards, seeking relative
-  to the end of the stream, requesting the size of the stream, and writing to
-  the stream will raise an exception.
-
-  The Position property returns the number of bytes of uncompressed data that
-  have been read from the stream so far.
-
-  The OnProgress event is called each time the internal input buffer of
-  compressed data is exhausted and the next block is read from the input stream.
-  This is useful for updating a progress indicator when you are reading a
-  large chunk of data from the decompression stream in a single call.}
-
-  TDecompressionStream = class(TCustomZlibStream)
-  public
-    constructor Create(Source: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property OnProgress;
-  end;
-
-
-
-{ CompressBuf compresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-
-
-{ DecompressBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-       OutEstimate = zero, or est. size of the decompressed data
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
- OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-
-{ DecompressToUserBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to user-allocated buffer to contain decompressed data
-       BufSize = number of bytes in OutBuf   }
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-
-const
-  zlib_version = '1.2.11';
-
-type
-  EZlibError = class(Exception);
-  ECompressionError = class(EZlibError);
-  EDecompressionError = class(EZlibError);
-
-implementation
-
-uses ZLibConst;
-
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-
-  Z_OK            = 0;
-  Z_STREAM_END    = 1;
-  Z_NEED_DICT     = 2;
-  Z_ERRNO         = (-1);
-  Z_STREAM_ERROR  = (-2);
-  Z_DATA_ERROR    = (-3);
-  Z_MEM_ERROR     = (-4);
-  Z_BUF_ERROR     = (-5);
-  Z_VERSION_ERROR = (-6);
-
-  Z_NO_COMPRESSION       =   0;
-  Z_BEST_SPEED           =   1;
-  Z_BEST_COMPRESSION     =   9;
-  Z_DEFAULT_COMPRESSION  = (-1);
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-procedure adler32; external;
-procedure compressBound; external;
-procedure crc32; external;
-procedure deflateInit2_; external;
-procedure deflateParams; external;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  Result := AllocMem(Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-
-
-// deflate compresses data
-function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;
-  recsize: Integer): Integer; external;
-function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function deflateEnd(var strm: TZStreamRec): Integer; external;
-
-// inflate decompresses data
-function inflateInit_(var strm: TZStreamRec; version: PChar;
-  recsize: Integer): Integer; external;
-function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function inflateEnd(var strm: TZStreamRec): Integer; external;
-function inflateReset(var strm: TZStreamRec): Integer; external;
-
-
-function zlibAllocMem(AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-begin
-//  GetMem(Result, Items*Size);
-  Result := AllocMem(Items * Size);
-end;
-
-procedure zlibFreeMem(AppData, Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-{function zlibCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EZlibError.Create('error');    //!!
-end;}
-
-function CCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise ECompressionError.Create('error'); //!!
-end;
-
-function DCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EDecompressionError.Create('error');  //!!
-end;
-
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));
-    try
-      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, 256);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := 256;
-      end;
-    finally
-      CCheck(deflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
-  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-  BufInc: Integer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  BufInc := (InBytes + 255) and not 255;
-  if OutEstimate = 0 then
-    OutBytes := BufInc
-  else
-    OutBytes := OutEstimate;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-    try
-      while DCheck(inflate(strm, Z_NO_FLUSH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, BufInc);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := BufInc;
-      end;
-    finally
-      DCheck(inflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-var
-  strm: TZStreamRec;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  strm.next_in := InBuf;
-  strm.avail_in := InBytes;
-  strm.next_out := OutBuf;
-  strm.avail_out := BufSize;
-  DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-  try
-    if DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END then
-      raise EZlibError.CreateRes(@sTargetBufferTooSmall);
-  finally
-    DCheck(inflateEnd(strm));
-  end;
-end;
-
-// TCustomZlibStream
-
-constructor TCustomZLibStream.Create(Strm: TStream);
-begin
-  inherited Create;
-  FStrm := Strm;
-  FStrmPos := Strm.Position;
-  FZRec.zalloc := zlibAllocMem;
-  FZRec.zfree := zlibFreeMem;
-end;
-
-procedure TCustomZLibStream.Progress(Sender: TObject);
-begin
-  if Assigned(FOnProgress) then FOnProgress(Sender);
-end;
-
-
-// TCompressionStream
-
-constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;
-  Dest: TStream);
-const
-  Levels: array [TCompressionLevel] of ShortInt =
-    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);
-begin
-  inherited Create(Dest);
-  FZRec.next_out := FBuffer;
-  FZRec.avail_out := sizeof(FBuffer);
-  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));
-end;
-
-destructor TCompressionStream.Destroy;
-begin
-  FZRec.next_in := nil;
-  FZRec.avail_in := 0;
-  try
-    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)
-      and (FZRec.avail_out = 0) do
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-    end;
-    if FZRec.avail_out < sizeof(FBuffer) then
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);
-  finally
-    deflateEnd(FZRec);
-  end;
-  inherited Destroy;
-end;
-
-function TCompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_in := @Buffer;
-  FZRec.avail_in := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_in > 0) do
-  begin
-    CCheck(deflate(FZRec, 0));
-    if FZRec.avail_out = 0 then
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-  end;
-  Result := Count;
-end;
-
-function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-begin
-  if (Offset = 0) and (Origin = soFromCurrent) then
-    Result := FZRec.total_in
-  else
-    raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.GetCompressionRate: Single;
-begin
-  if FZRec.total_in = 0 then
-    Result := 0
-  else
-    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;
-end;
-
-
-// TDecompressionStream
-
-constructor TDecompressionStream.Create(Source: TStream);
-begin
-  inherited Create(Source);
-  FZRec.next_in := FBuffer;
-  FZRec.avail_in := 0;
-  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));
-end;
-
-destructor TDecompressionStream.Destroy;
-begin
-  FStrm.Seek(-FZRec.avail_in, 1);
-  inflateEnd(FZRec);
-  inherited Destroy;
-end;
-
-function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_out := @Buffer;
-  FZRec.avail_out := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_out > 0) do
-  begin
-    if FZRec.avail_in = 0 then
-    begin
-      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));
-      if FZRec.avail_in = 0 then
-      begin
-        Result := Count - FZRec.avail_out;
-        Exit;
-      end;
-      FZRec.next_in := FBuffer;
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-    CCheck(inflate(FZRec, 0));
-  end;
-  Result := Count;
-end;
-
-function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-var
-  I: Integer;
-  Buf: array [0..4095] of Char;
-begin
-  if (Offset = 0) and (Origin = soFromBeginning) then
-  begin
-    DCheck(inflateReset(FZRec));
-    FZRec.next_in := FBuffer;
-    FZRec.avail_in := 0;
-    FStrm.Position := 0;
-    FStrmPos := 0;
-  end
-  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or
-          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then
-  begin
-    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);
-    if Offset > 0 then
-    begin
-      for I := 1 to Offset div sizeof(Buf) do
-        ReadBuffer(Buf, sizeof(Buf));
-      ReadBuffer(Buf, Offset mod sizeof(Buf));
-    end;
-  end
-  else
-    raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-  Result := FZRec.total_out;
-end;
-
-
-end.
diff --git a/contrib/zlib/contrib/delphi/ZLibConst.pas b/contrib/zlib/contrib/delphi/ZLibConst.pas
deleted file mode 100644
index cdfe13671..000000000
--- a/contrib/zlib/contrib/delphi/ZLibConst.pas
+++ /dev/null
@@ -1,11 +0,0 @@
-unit ZLibConst;
-
-interface
-
-resourcestring
-  sTargetBufferTooSmall = 'ZLib error: target buffer may be too small';
-  sInvalidStreamOp = 'Invalid stream operation';
-
-implementation
-
-end.
diff --git a/contrib/zlib/contrib/delphi/readme.txt b/contrib/zlib/contrib/delphi/readme.txt
deleted file mode 100644
index 2dc9a8bba..000000000
--- a/contrib/zlib/contrib/delphi/readme.txt
+++ /dev/null
@@ -1,76 +0,0 @@
-
-Overview
-========
-
-This directory contains an update to the ZLib interface unit,
-distributed by Borland as a Delphi supplemental component.
-
-The original ZLib unit is Copyright (c) 1997,99 Borland Corp.,
-and is based on zlib version 1.0.4.  There are a series of bugs
-and security problems associated with that old zlib version, and
-we recommend the users to update their ZLib unit.
-
-
-Summary of modifications
-========================
-
-- Improved makefile, adapted to zlib version 1.2.1.
-
-- Some field types from TZStreamRec are changed from Integer to
-  Longint, for consistency with the zlib.h header, and for 64-bit
-  readiness.
-
-- The zlib_version constant is updated.
-
-- The new Z_RLE strategy has its corresponding symbolic constant.
-
-- The allocation and deallocation functions and function types
-  (TAlloc, TFree, zlibAllocMem and zlibFreeMem) are now cdecl,
-  and _malloc and _free are added as C RTL stubs.  As a result,
-  the original C sources of zlib can be compiled out of the box,
-  and linked to the ZLib unit.
-
-
-Suggestions for improvements
-============================
-
-Currently, the ZLib unit provides only a limited wrapper around
-the zlib library, and much of the original zlib functionality is
-missing.  Handling compressed file formats like ZIP/GZIP or PNG
-cannot be implemented without having this functionality.
-Applications that handle these formats are either using their own,
-duplicated code, or not using the ZLib unit at all.
-
-Here are a few suggestions:
-
-- Checksum class wrappers around adler32() and crc32(), similar
-  to the Java classes that implement the java.util.zip.Checksum
-  interface.
-
-- The ability to read and write raw deflate streams, without the
-  zlib stream header and trailer.  Raw deflate streams are used
-  in the ZIP file format.
-
-- The ability to read and write gzip streams, used in the GZIP
-  file format, and normally produced by the gzip program.
-
-- The ability to select a different compression strategy, useful
-  to PNG and MNG image compression, and to multimedia compression
-  in general.  Besides the compression level
-
-    TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  which, in fact, could have used the 'z' prefix and avoided
-  TColor-like symbols
-
-    TCompressionLevel = (zcNone, zcFastest, zcDefault, zcMax);
-
-  there could be a compression strategy
-
-    TCompressionStrategy = (zsDefault, zsFiltered, zsHuffmanOnly, zsRle);
-
-- ZIP and GZIP stream handling via TStreams.
-
-
---
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff --git a/contrib/zlib/contrib/delphi/zlibd32.mak b/contrib/zlib/contrib/delphi/zlibd32.mak
deleted file mode 100644
index 9bb00b7cc..000000000
--- a/contrib/zlib/contrib/delphi/zlibd32.mak
+++ /dev/null
@@ -1,99 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib.build b/contrib/zlib/contrib/dotzlib/DotZLib.build
deleted file mode 100644
index e69630cec..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib.build
+++ /dev/null
@@ -1,33 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8" ?>
-<project name="DotZLib" default="build" basedir="./DotZLib">
-	<description>A .Net wrapper library around ZLib1.dll</description>
-
-	<property name="nunit.location" value="c:/program files/NUnit V2.1/bin" />
-	<property name="build.root" value="bin" />
-
-	<property name="debug" value="true" />
-	<property name="nunit" value="true" />
-
-	<property name="build.folder" value="${build.root}/debug/" if="${debug}" />
-	<property name="build.folder" value="${build.root}/release/" unless="${debug}" />
-
-	<target name="clean" description="Remove all generated files">
-		<delete dir="${build.root}" failonerror="false" />
-	</target>
-
-	<target name="build" description="compiles the source code">
-
-		<mkdir dir="${build.folder}" />
-		<csc target="library" output="${build.folder}DotZLib.dll" debug="${debug}">
-			<references basedir="${nunit.location}">
-				<includes if="${nunit}" name="nunit.framework.dll" />
-			</references>
-			<sources>
-				<includes name="*.cs" />
-				<excludes name="UnitTests.cs" unless="${nunit}" />
-			</sources>
-			<arg value="/d:nunit" if="${nunit}" />
-		</csc>
-	</target>
-
-</project>
\ No newline at end of file
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib.chm b/contrib/zlib/contrib/dotzlib/DotZLib.chm
deleted file mode 100644
index f214a444aebb20950fb3e8499b36731e1f12be95..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 72726
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
YloM(DzZd`p3;_ecfG}VT82kqS5Dd#@CIA2c

diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs b/contrib/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs
deleted file mode 100644
index 724c5347f..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-//
-// General Information about an assembly is controlled through the following
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-//
-[assembly: AssemblyTitle("DotZLib")]
-[assembly: AssemblyDescription(".Net bindings for ZLib compression dll 1.2.x")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Henrik Ravn")]
-[assembly: AssemblyProduct("")]
-[assembly: AssemblyCopyright("(c) 2004 by Henrik Ravn")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-//
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Revision and Build Numbers
-// by using the '*' as shown below:
-
-[assembly: AssemblyVersion("1.0.*")]
-
-//
-// In order to sign your assembly you must specify a key to use. Refer to the
-// Microsoft .NET Framework documentation for more information on assembly signing.
-//
-// Use the attributes below to control which key is used for signing.
-//
-// Notes:
-//   (*) If no key is specified, the assembly is not signed.
-//   (*) KeyName refers to a key that has been installed in the Crypto Service
-//       Provider (CSP) on your machine. KeyFile refers to a file which contains
-//       a key.
-//   (*) If the KeyFile and the KeyName values are both specified, the
-//       following processing occurs:
-//       (1) If the KeyName can be found in the CSP, that key is used.
-//       (2) If the KeyName does not exist and the KeyFile does exist, the key
-//           in the KeyFile is installed into the CSP and used.
-//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
-//       When specifying the KeyFile, the location of the KeyFile should be
-//       relative to the project output directory which is
-//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
-//       located in the project directory, you would specify the AssemblyKeyFile
-//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
-//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
-//       documentation for more information on this.
-//
-[assembly: AssemblyDelaySign(false)]
-[assembly: AssemblyKeyFile("")]
-[assembly: AssemblyKeyName("")]
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs b/contrib/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs
deleted file mode 100644
index cd1ef44eb..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs
+++ /dev/null
@@ -1,202 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-    #region ChecksumGeneratorBase
-    /// <summary>
-    /// Implements the common functionality needed for all <see cref="ChecksumGenerator"/>s
-    /// </summary>
-    /// <example></example>
-    public abstract class ChecksumGeneratorBase : ChecksumGenerator
-    {
-        /// <summary>
-        /// The value of the current checksum
-        /// </summary>
-        protected uint _current;
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator base - the current checksum is
-        /// set to zero
-        /// </summary>
-        public ChecksumGeneratorBase()
-        {
-            _current = 0;
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator basewith a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public ChecksumGeneratorBase(uint initialValue)
-        {
-            _current = initialValue;
-        }
-
-        /// <summary>
-        /// Resets the current checksum to zero
-        /// </summary>
-        public void Reset() { _current = 0; }
-
-        /// <summary>
-        /// Gets the current checksum value
-        /// </summary>
-        public uint Value { get { return _current; } }
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        /// <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one.
-        /// This is therefore the only method a derived class has to implement</remarks>
-        public abstract void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes.
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        public void Update(byte[] data)
-        {
-            Update(data, 0, data.Length);
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        public void Update(string data)
-        {
-			Update(Encoding.UTF8.GetBytes(data));
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        public void Update(string data, Encoding encoding)
-        {
-            Update(encoding.GetBytes(data));
-        }
-
-    }
-    #endregion
-
-    #region CRC32
-    /// <summary>
-    /// Implements a CRC32 checksum generator
-    /// </summary>
-    public sealed class CRC32Checksum : ChecksumGeneratorBase
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint crc32(uint crc, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator
-        /// </summary>
-        public CRC32Checksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public CRC32Checksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = crc32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-    #region Adler
-    /// <summary>
-    /// Implements a checksum generator that computes the Adler checksum on data
-    /// </summary>
-    public sealed class AdlerChecksum : ChecksumGeneratorBase
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint adler32(uint adler, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator
-        /// </summary>
-        public AdlerChecksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public AdlerChecksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = adler32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs b/contrib/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs
deleted file mode 100644
index e7a88b9f4..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-
-namespace DotZLib
-{
-
-	/// <summary>
-	/// This class implements a circular buffer
-	/// </summary>
-	internal class CircularBuffer
-	{
-        #region Private data
-        private int _capacity;
-        private int _head;
-        private int _tail;
-        private int _size;
-        private byte[] _buffer;
-        #endregion
-
-        public CircularBuffer(int capacity)
-        {
-            Debug.Assert( capacity > 0 );
-            _buffer = new byte[capacity];
-            _capacity = capacity;
-            _head = 0;
-            _tail = 0;
-            _size = 0;
-        }
-
-        public int Size { get { return _size; } }
-
-        public int Put(byte[] source, int offset, int count)
-        {
-            Debug.Assert( count > 0 );
-            int trueCount = Math.Min(count, _capacity - Size);
-            for (int i = 0; i < trueCount; ++i)
-                _buffer[(_tail+i) % _capacity] = source[offset+i];
-            _tail += trueCount;
-            _tail %= _capacity;
-            _size += trueCount;
-            return trueCount;
-        }
-
-        public bool Put(byte b)
-        {
-            if (Size == _capacity) // no room
-                return false;
-            _buffer[_tail++] = b;
-            _tail %= _capacity;
-            ++_size;
-            return true;
-        }
-
-        public int Get(byte[] destination, int offset, int count)
-        {
-            int trueCount = Math.Min(count,Size);
-            for (int i = 0; i < trueCount; ++i)
-                destination[offset + i] = _buffer[(_head+i) % _capacity];
-            _head += trueCount;
-            _head %= _capacity;
-            _size -= trueCount;
-            return trueCount;
-        }
-
-        public int Get()
-        {
-            if (Size == 0)
-                return -1;
-
-            int result = (int)_buffer[_head++ % _capacity];
-            --_size;
-            return result;
-        }
-
-    }
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/CodecBase.cs b/contrib/zlib/contrib/dotzlib/DotZLib/CodecBase.cs
deleted file mode 100644
index 6ef6d8fab..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/CodecBase.cs
+++ /dev/null
@@ -1,198 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements the common functionality needed for all <see cref="Codec"/>s
-	/// </summary>
-	public abstract class CodecBase : Codec, IDisposable
-	{
-
-        #region Data members
-
-        /// <summary>
-        /// Instance of the internal zlib buffer structure that is
-        /// passed to all functions in the zlib dll
-        /// </summary>
-        internal ZStream _ztream = new ZStream();
-
-        /// <summary>
-        /// True if the object instance has been disposed, false otherwise
-        /// </summary>
-        protected bool _isDisposed = false;
-
-        /// <summary>
-        /// The size of the internal buffers
-        /// </summary>
-        protected const int kBufferSize = 16384;
-
-        private byte[] _outBuffer = new byte[kBufferSize];
-        private byte[] _inBuffer = new byte[kBufferSize];
-
-        private GCHandle _hInput;
-        private GCHandle _hOutput;
-
-        private uint _checksum = 0;
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the <c>CodeBase</c> class.
-        /// </summary>
-		public CodecBase()
-		{
-            try
-            {
-                _hInput = GCHandle.Alloc(_inBuffer, GCHandleType.Pinned);
-                _hOutput = GCHandle.Alloc(_outBuffer, GCHandleType.Pinned);
-            }
-            catch (Exception)
-            {
-                CleanUp(false);
-                throw;
-            }
-        }
-
-
-        #region Codec Members
-
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        public event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Fires the <see cref="DataAvailable"/> event
-        /// </summary>
-        protected void OnDataAvailable()
-        {
-            if (_ztream.total_out > 0)
-            {
-                if (DataAvailable != null)
-                    DataAvailable( _outBuffer, 0, (int)_ztream.total_out);
-                resetOutput();
-            }
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public void Add(byte[] data)
-        {
-            Add(data,0,data.Length);
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        public uint Checksum { get { return _checksum; } }
-
-        #endregion
-
-        #region Destructor & IDisposable stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~CodecBase()
-        {
-            CleanUp(false);
-        }
-
-        /// <summary>
-        /// Releases any unmanaged resources and calls the <see cref="CleanUp()"/> method of the derived class
-        /// </summary>
-        public void Dispose()
-        {
-            CleanUp(true);
-        }
-
-        /// <summary>
-        /// Performs any codec specific cleanup
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        protected abstract void CleanUp();
-
-        // performs the release of the handles and calls the dereived CleanUp()
-        private void CleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                CleanUp();
-                if (_hInput.IsAllocated)
-                    _hInput.Free();
-                if (_hOutput.IsAllocated)
-                    _hOutput.Free();
-
-                _isDisposed = true;
-            }
-        }
-
-
-        #endregion
-
-        #region Helper methods
-
-        /// <summary>
-        /// Copies a number of bytes to the internal codec buffer - ready for proccesing
-        /// </summary>
-        /// <param name="data">The byte array that contains the data to copy</param>
-        /// <param name="startIndex">The index of the first byte to copy</param>
-        /// <param name="count">The number of bytes to copy from <c>data</c></param>
-        protected void copyInput(byte[] data, int startIndex, int count)
-        {
-            Array.Copy(data, startIndex, _inBuffer,0, count);
-            _ztream.next_in = _hInput.AddrOfPinnedObject();
-            _ztream.total_in = 0;
-            _ztream.avail_in = (uint)count;
-
-        }
-
-        /// <summary>
-        /// Resets the internal output buffers to a known state - ready for processing
-        /// </summary>
-        protected void resetOutput()
-        {
-            _ztream.total_out = 0;
-            _ztream.avail_out = kBufferSize;
-            _ztream.next_out = _hOutput.AddrOfPinnedObject();
-        }
-
-        /// <summary>
-        /// Updates the running checksum property
-        /// </summary>
-        /// <param name="newSum">The new checksum value</param>
-        protected void setChecksum(uint newSum)
-        {
-            _checksum = newSum;
-        }
-        #endregion
-
-    }
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/Deflater.cs b/contrib/zlib/contrib/dotzlib/DotZLib/Deflater.cs
deleted file mode 100644
index 778a6794d..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/Deflater.cs
+++ /dev/null
@@ -1,106 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-
-    /// <summary>
-    /// Implements a data compressor, using the deflate algorithm in the ZLib dll
-    /// </summary>
-	public sealed class Deflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int deflateInit_(ref ZStream sz, int level, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Deflater</c>
-        /// </summary>
-        /// <param name="level">The compression level to use for this <c>Deflater</c></param>
-		public Deflater(CompressLevel level) : base()
-		{
-            int retval = deflateInit_(ref _ztream, (int)level, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize deflater");
-
-            resetOutput();
-		}
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                while (err >= 0 && _ztream.avail_in > 0)
-                {
-                    err = deflate(ref _ztream, (int)FlushTypes.None);
-                    if (err == 0)
-                        while (_ztream.avail_out == 0)
-                        {
-                            OnDataAvailable();
-                            err = deflate(ref _ztream, (int)FlushTypes.None);
-                        }
-                    inputIndex += (int)_ztream.total_in;
-                }
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do
-            {
-                err = deflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            deflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib deflate stream
-        /// </summary>
-        protected override void CleanUp() { deflateEnd(ref _ztream); }
-
-    }
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.cs b/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.cs
deleted file mode 100644
index a48ed4974..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.cs
+++ /dev/null
@@ -1,288 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-
-    #region Internal types
-
-    /// <summary>
-    /// Defines constants for the various flush types used with zlib
-    /// </summary>
-    internal enum FlushTypes
-    {
-        None,  Partial,  Sync,  Full,  Finish,  Block
-    }
-
-    #region ZStream structure
-    // internal mapping of the zlib zstream structure for marshalling
-    [StructLayoutAttribute(LayoutKind.Sequential, Pack=4, Size=0, CharSet=CharSet.Ansi)]
-    internal struct ZStream
-    {
-        public IntPtr next_in;
-        public uint avail_in;
-        public uint total_in;
-
-        public IntPtr next_out;
-        public uint avail_out;
-        public uint total_out;
-
-        [MarshalAs(UnmanagedType.LPStr)]
-        string msg;
-        uint state;
-
-        uint zalloc;
-        uint zfree;
-        uint opaque;
-
-        int data_type;
-        public uint adler;
-        uint reserved;
-    }
-
-    #endregion
-
-    #endregion
-
-    #region Public enums
-    /// <summary>
-    /// Defines constants for the available compression levels in zlib
-    /// </summary>
-    public enum CompressLevel : int
-    {
-        /// <summary>
-        /// The default compression level with a reasonable compromise between compression and speed
-        /// </summary>
-        Default = -1,
-        /// <summary>
-        /// No compression at all. The data are passed straight through.
-        /// </summary>
-        None = 0,
-        /// <summary>
-        /// The maximum compression rate available.
-        /// </summary>
-        Best = 9,
-        /// <summary>
-        /// The fastest available compression level.
-        /// </summary>
-        Fastest = 1
-    }
-    #endregion
-
-    #region Exception classes
-    /// <summary>
-    /// The exception that is thrown when an error occurs on the zlib dll
-    /// </summary>
-    public class ZLibException : ApplicationException
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
-        /// error message and error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        /// <param name="msg">A message that (hopefully) describes the error</param>
-        public ZLibException(int errorCode, string msg) : base(String.Format("ZLib error {0} {1}", errorCode, msg))
-        {
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
-        /// error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        public ZLibException(int errorCode) : base(String.Format("ZLib error {0}", errorCode))
-        {
-        }
-    }
-    #endregion
-
-    #region Interfaces
-
-    /// <summary>
-    /// Declares methods and properties that enables a running checksum to be calculated
-    /// </summary>
-    public interface ChecksumGenerator
-    {
-        /// <summary>
-        /// Gets the current value of the checksum
-        /// </summary>
-        uint Value { get; }
-
-        /// <summary>
-        /// Clears the current checksum to 0
-        /// </summary>
-        void Reset();
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        void Update(byte[] data);
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="ArgumentNullException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        void Update(string data);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        void Update(string data, Encoding encoding);
-    }
-
-
-    /// <summary>
-    /// Represents the method that will be called from a codec when new data
-    /// are available.
-    /// </summary>
-    /// <paramref name="data">The byte array containing the processed data</paramref>
-    /// <paramref name="startIndex">The index of the first processed byte in <c>data</c></paramref>
-    /// <paramref name="count">The number of processed bytes available</paramref>
-    /// <remarks>On return from this method, the data may be overwritten, so grab it while you can.
-    /// You cannot assume that startIndex will be zero.
-    /// </remarks>
-    public delegate void DataAvailableHandler(byte[] data, int startIndex, int count);
-
-    /// <summary>
-    /// Declares methods and events for implementing compressors/decompressors
-    /// </summary>
-    public interface Codec
-    {
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data);
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        uint Checksum { get; }
-
-
-    }
-
-    #endregion
-
-    #region Classes
-    /// <summary>
-    /// Encapsulates general information about the ZLib library
-    /// </summary>
-    public class Info
-    {
-        #region DLL imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint zlibCompileFlags();
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern string zlibVersion();
-        #endregion
-
-        #region Private stuff
-        private uint _flags;
-
-        // helper function that unpacks a bitsize mask
-        private static int bitSize(uint bits)
-        {
-            switch (bits)
-            {
-                case 0: return 16;
-                case 1: return 32;
-                case 2: return 64;
-            }
-            return -1;
-        }
-        #endregion
-
-        /// <summary>
-        /// Constructs an instance of the <c>Info</c> class.
-        /// </summary>
-        public Info()
-        {
-            _flags = zlibCompileFlags();
-        }
-
-        /// <summary>
-        /// True if the library is compiled with debug info
-        /// </summary>
-        public bool HasDebugInfo { get { return 0 != (_flags & 0x100); } }
-
-        /// <summary>
-        /// True if the library is compiled with assembly optimizations
-        /// </summary>
-        public bool UsesAssemblyCode { get { return 0 != (_flags & 0x200); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned int that was compiled into Zlib
-        /// </summary>
-        public int SizeOfUInt { get { return bitSize(_flags & 3); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned long that was compiled into Zlib
-        /// </summary>
-        public int SizeOfULong { get { return bitSize((_flags >> 2) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the pointers that were compiled into Zlib
-        /// </summary>
-        public int SizeOfPointer { get { return bitSize((_flags >> 4) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the z_off_t type that was compiled into Zlib
-        /// </summary>
-        public int SizeOfOffset { get { return bitSize((_flags >> 6) & 3); } }
-
-        /// <summary>
-        /// Gets the version of ZLib as a string, e.g. "1.2.1"
-        /// </summary>
-        public static string Version { get { return zlibVersion(); } }
-    }
-
-    #endregion
-
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj b/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj
deleted file mode 100644
index dea7fb16a..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj
+++ /dev/null
@@ -1,141 +0,0 @@
-<VisualStudioProject>
-    <CSHARP
-        ProjectType = "Local"
-        ProductVersion = "7.10.3077"
-        SchemaVersion = "2.0"
-        ProjectGuid = "{BB1EE0B1-1808-46CB-B786-949D91117FC5}"
-    >
-        <Build>
-            <Settings
-                ApplicationIcon = ""
-                AssemblyKeyContainerName = ""
-                AssemblyName = "DotZLib"
-                AssemblyOriginatorKeyFile = ""
-                DefaultClientScript = "JScript"
-                DefaultHTMLPageLayout = "Grid"
-                DefaultTargetSchema = "IE50"
-                DelaySign = "false"
-                OutputType = "Library"
-                PreBuildEvent = ""
-                PostBuildEvent = ""
-                RootNamespace = "DotZLib"
-                RunPostBuildEvent = "OnBuildSuccess"
-                StartupObject = ""
-            >
-                <Config
-                    Name = "Debug"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "DEBUG;TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "true"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = "1591"
-                    Optimize = "false"
-                    OutputPath = "bin\Debug\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-                <Config
-                    Name = "Release"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "false"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = ""
-                    Optimize = "true"
-                    OutputPath = "bin\Release\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-            </Settings>
-            <References>
-                <Reference
-                    Name = "System"
-                    AssemblyName = "System"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.dll"
-                />
-                <Reference
-                    Name = "System.Data"
-                    AssemblyName = "System.Data"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.Data.dll"
-                />
-                <Reference
-                    Name = "System.XML"
-                    AssemblyName = "System.Xml"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.XML.dll"
-                />
-                <Reference
-                    Name = "nunit.framework"
-                    AssemblyName = "nunit.framework"
-                    HintPath = "E:\apps\NUnit V2.1\\bin\nunit.framework.dll"
-                    AssemblyFolderKey = "hklm\dn\nunit.framework"
-                />
-            </References>
-        </Build>
-        <Files>
-            <Include>
-                <File
-                    RelPath = "AssemblyInfo.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "ChecksumImpl.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CircularBuffer.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CodecBase.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Deflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "DotZLib.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "GZipStream.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Inflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "UnitTests.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-            </Include>
-        </Files>
-    </CSHARP>
-</VisualStudioProject>
-
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/GZipStream.cs b/contrib/zlib/contrib/dotzlib/DotZLib/GZipStream.cs
deleted file mode 100644
index 07b2f7a9b..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/GZipStream.cs
+++ /dev/null
@@ -1,301 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements a compressed <see cref="Stream"/>, in GZip (.gz) format.
-	/// </summary>
-	public class GZipStream : Stream, IDisposable
-	{
-        #region Dll Imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern IntPtr gzopen(string name, string mode);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzclose(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzwrite(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzread(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzgetc(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzputc(IntPtr gzFile, int c);
-
-        #endregion
-
-        #region Private data
-        private IntPtr _gzFile;
-        private bool _isDisposed = false;
-        private bool _isWriting;
-        #endregion
-
-        #region Constructors
-        /// <summary>
-        /// Creates a new file as a writeable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the compressed file to create</param>
-        /// <param name="level">The compression level to use when adding data</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-		public GZipStream(string fileName, CompressLevel level)
-		{
-            _isWriting = true;
-            _gzFile = gzopen(fileName, String.Format("wb{0}", (int)level));
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-		}
-
-        /// <summary>
-        /// Opens an existing file as a readable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the file to open</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-        public GZipStream(string fileName)
-        {
-            _isWriting = false;
-            _gzFile = gzopen(fileName, "rb");
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-
-        }
-        #endregion
-
-        #region Access properties
-        /// <summary>
-        /// Returns true of this stream can be read from, false otherwise
-        /// </summary>
-        public override bool CanRead
-        {
-            get
-            {
-                return !_isWriting;
-            }
-        }
-
-
-        /// <summary>
-        /// Returns false.
-        /// </summary>
-        public override bool CanSeek
-        {
-            get
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Returns true if this tsream is writeable, false otherwise
-        /// </summary>
-        public override bool CanWrite
-        {
-            get
-            {
-                return _isWriting;
-            }
-        }
-        #endregion
-
-        #region Destructor & IDispose stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~GZipStream()
-        {
-            cleanUp(false);
-        }
-
-        /// <summary>
-        /// Closes the external file handle
-        /// </summary>
-        public void Dispose()
-        {
-            cleanUp(true);
-        }
-
-        // Does the actual closing of the file handle.
-        private void cleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                gzclose(_gzFile);
-                _isDisposed = true;
-            }
-        }
-        #endregion
-
-        #region Basic reading and writing
-        /// <summary>
-        /// Attempts to read a number of bytes from the stream.
-        /// </summary>
-        /// <param name="buffer">The destination data buffer</param>
-        /// <param name="offset">The index of the first destination byte in <c>buffer</c></param>
-        /// <param name="count">The number of bytes requested</param>
-        /// <returns>The number of bytes read</returns>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not readable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override int Read(byte[] buffer, int offset, int count)
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            int result;
-            try
-            {
-                result = gzread(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-            return result;
-        }
-
-        /// <summary>
-        /// Attempts to read a single byte from the stream.
-        /// </summary>
-        /// <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>
-        public override int ReadByte()
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-            return gzgetc(_gzFile);
-        }
-
-        /// <summary>
-        /// Writes a number of bytes to the stream
-        /// </summary>
-        /// <param name="buffer"></param>
-        /// <param name="offset"></param>
-        /// <param name="count"></param>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void Write(byte[] buffer, int offset, int count)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            try
-            {
-                int result = gzwrite(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-        }
-
-        /// <summary>
-        /// Writes a single byte to the stream
-        /// </summary>
-        /// <param name="value">The byte to add to the stream.</param>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void WriteByte(byte value)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            int result = gzputc(_gzFile, (int)value);
-            if (result < 0)
-                throw new IOException();
-        }
-        #endregion
-
-        #region Position & length stuff
-        /// <summary>
-        /// Not supported.
-        /// </summary>
-        /// <param name="value"></param>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override void SetLength(long value)
-        {
-            throw new NotSupportedException();
-        }
-
-        /// <summary>
-        ///  Not suppported.
-        /// </summary>
-        /// <param name="offset"></param>
-        /// <param name="origin"></param>
-        /// <returns></returns>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Seek(long offset, SeekOrigin origin)
-        {
-            throw new NotSupportedException();
-        }
-
-        /// <summary>
-        /// Flushes the <c>GZipStream</c>.
-        /// </summary>
-        /// <remarks>In this implementation, this method does nothing. This is because excessive
-        /// flushing may degrade the achievable compression rates.</remarks>
-        public override void Flush()
-        {
-            // left empty on purpose
-        }
-
-        /// <summary>
-        /// Gets/sets the current position in the <c>GZipStream</c>. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Position
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-            set
-            {
-                throw new NotSupportedException();
-            }
-        }
-
-        /// <summary>
-        /// Gets the size of the stream. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Length
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-        }
-        #endregion
-    }
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/Inflater.cs b/contrib/zlib/contrib/dotzlib/DotZLib/Inflater.cs
deleted file mode 100644
index 8e900ae20..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/Inflater.cs
+++ /dev/null
@@ -1,105 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-
-    /// <summary>
-    /// Implements a data decompressor, using the inflate algorithm in the ZLib dll
-    /// </summary>
-    public class Inflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int inflateInit_(ref ZStream sz, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Inflater</c>
-        /// </summary>
-        public Inflater() : base()
-		{
-            int retval = inflateInit_(ref _ztream, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize inflater");
-
-            resetOutput();
-        }
-
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                err = inflate(ref _ztream, (int)FlushTypes.None);
-                if (err == 0)
-                    while (_ztream.avail_out == 0)
-                    {
-                        OnDataAvailable();
-                        err = inflate(ref _ztream, (int)FlushTypes.None);
-                    }
-
-                inputIndex += (int)_ztream.total_in;
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do
-            {
-                err = inflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            inflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib inflate stream
-        /// </summary>
-        protected override void CleanUp() { inflateEnd(ref _ztream); }
-
-
-	}
-}
diff --git a/contrib/zlib/contrib/dotzlib/DotZLib/UnitTests.cs b/contrib/zlib/contrib/dotzlib/DotZLib/UnitTests.cs
deleted file mode 100644
index 6d8aebb79..000000000
--- a/contrib/zlib/contrib/dotzlib/DotZLib/UnitTests.cs
+++ /dev/null
@@ -1,274 +0,0 @@
-//
-// © Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Collections;
-using System.IO;
-
-// uncomment the define below to include unit tests
-//#define nunit
-#if nunit
-using NUnit.Framework;
-
-// Unit tests for the DotZLib class library
-// ----------------------------------------
-//
-// Use this with NUnit 2 from http://www.nunit.org
-//
-
-namespace DotZLibTests
-{
-    using DotZLib;
-
-    // helper methods
-    internal class Utils
-    {
-        public static bool byteArrEqual( byte[] lhs, byte[] rhs )
-        {
-            if (lhs.Length != rhs.Length)
-                return false;
-            for (int i = lhs.Length-1; i >= 0; --i)
-                if (lhs[i] != rhs[i])
-                    return false;
-            return true;
-        }
-
-    }
-
-
-    [TestFixture]
-    public class CircBufferTests
-    {
-        #region Circular buffer tests
-        [Test]
-        public void SinglePutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-
-            Assert.IsTrue(buf.Put( 1 ));
-            Assert.AreEqual( 1, buf.Size );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-        }
-
-        [Test]
-        public void BlockPutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            byte[] arr = {1,2,3,4,5,6,7,8,9,10};
-            Assert.AreEqual( 10, buf.Put(arr,0,10) );
-            Assert.AreEqual( 10, buf.Size );
-            Assert.IsFalse( buf.Put(11) );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.IsTrue( buf.Put(11) );
-
-            byte[] arr2 = (byte[])arr.Clone();
-            Assert.AreEqual( 9, buf.Get(arr2,1,9) );
-            Assert.IsTrue( Utils.byteArrEqual(arr,arr2) );
-        }
-
-        #endregion
-    }
-
-    [TestFixture]
-    public class ChecksumTests
-    {
-        #region CRC32 Tests
-        [Test]
-        public void CRC32_Null()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            Assert.AreEqual( 0, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            Assert.AreEqual( 1, crc32.Value );
-
-            crc32 = new CRC32Checksum(556);
-            Assert.AreEqual( 556, crc32.Value );
-        }
-
-        [Test]
-        public void CRC32_Data()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            byte[] data = { 1,2,3,4,5,6,7 };
-            crc32.Update(data);
-            Assert.AreEqual( 0x70e46888, crc32.Value  );
-
-            crc32 = new CRC32Checksum();
-            crc32.Update("penguin");
-            Assert.AreEqual( 0x0e5c1a120, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            crc32.Update("penguin");
-            Assert.AreEqual(0x43b6aa94, crc32.Value);
-
-        }
-        #endregion
-
-        #region Adler tests
-
-        [Test]
-        public void Adler_Null()
-        {
-            AdlerChecksum adler = new AdlerChecksum();
-            Assert.AreEqual(0, adler.Value);
-
-            adler = new AdlerChecksum(1);
-            Assert.AreEqual( 1, adler.Value );
-
-            adler = new AdlerChecksum(556);
-            Assert.AreEqual( 556, adler.Value );
-        }
-
-        [Test]
-        public void Adler_Data()
-        {
-            AdlerChecksum adler = new AdlerChecksum(1);
-            byte[] data = { 1,2,3,4,5,6,7 };
-            adler.Update(data);
-            Assert.AreEqual( 0x5b001d, adler.Value  );
-
-            adler = new AdlerChecksum();
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bcf02f6, adler.Value );
-
-            adler = new AdlerChecksum(1);
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bd602f7, adler.Value);
-
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class InfoTests
-    {
-        #region Info tests
-        [Test]
-        public void Info_Version()
-        {
-            Info info = new Info();
-            Assert.AreEqual("1.2.11", Info.Version);
-            Assert.AreEqual(32, info.SizeOfUInt);
-            Assert.AreEqual(32, info.SizeOfULong);
-            Assert.AreEqual(32, info.SizeOfPointer);
-            Assert.AreEqual(32, info.SizeOfOffset);
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class DeflateInflateTests
-    {
-        #region Deflate tests
-        [Test]
-        public void Deflate_Init()
-        {
-            using (Deflater def = new Deflater(CompressLevel.Default))
-            {
-            }
-        }
-
-        private ArrayList compressedData = new ArrayList();
-        private uint adler1;
-
-        private ArrayList uncompressedData = new ArrayList();
-        private uint adler2;
-
-        public void CDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                compressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Deflate_Compress()
-        {
-            compressedData.Clear();
-
-            byte[] testData = new byte[35000];
-            for (int i = 0; i < testData.Length; ++i)
-                testData[i] = 5;
-
-            using (Deflater def = new Deflater((CompressLevel)5))
-            {
-                def.DataAvailable += new DataAvailableHandler(CDataAvail);
-                def.Add(testData);
-                def.Finish();
-                adler1 = def.Checksum;
-            }
-        }
-        #endregion
-
-        #region Inflate tests
-        [Test]
-        public void Inflate_Init()
-        {
-            using (Inflater inf = new Inflater())
-            {
-            }
-        }
-
-        private void DDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                uncompressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Inflate_Expand()
-        {
-            uncompressedData.Clear();
-
-            using (Inflater inf = new Inflater())
-            {
-                inf.DataAvailable += new DataAvailableHandler(DDataAvail);
-                inf.Add((byte[])compressedData.ToArray(typeof(byte)));
-                inf.Finish();
-                adler2 = inf.Checksum;
-            }
-            Assert.AreEqual( adler1, adler2 );
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class GZipStreamTests
-    {
-        #region GZipStream test
-        [Test]
-        public void GZipStream_WriteRead()
-        {
-            using (GZipStream gzOut = new GZipStream("gzstream.gz", CompressLevel.Best))
-            {
-                BinaryWriter writer = new BinaryWriter(gzOut);
-                writer.Write("hi there");
-                writer.Write(Math.PI);
-                writer.Write(42);
-            }
-
-            using (GZipStream gzIn = new GZipStream("gzstream.gz"))
-            {
-                BinaryReader reader = new BinaryReader(gzIn);
-                string s = reader.ReadString();
-                Assert.AreEqual("hi there",s);
-                double d = reader.ReadDouble();
-                Assert.AreEqual(Math.PI, d);
-                int i = reader.ReadInt32();
-                Assert.AreEqual(42,i);
-            }
-
-        }
-        #endregion
-	}
-}
-
-#endif
diff --git a/contrib/zlib/contrib/dotzlib/LICENSE_1_0.txt b/contrib/zlib/contrib/dotzlib/LICENSE_1_0.txt
deleted file mode 100644
index 36b7cd93c..000000000
--- a/contrib/zlib/contrib/dotzlib/LICENSE_1_0.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-Boost Software License - Version 1.0 - August 17th, 2003
-
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
-
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
diff --git a/contrib/zlib/contrib/dotzlib/readme.txt b/contrib/zlib/contrib/dotzlib/readme.txt
deleted file mode 100644
index 4d8c2dd93..000000000
--- a/contrib/zlib/contrib/dotzlib/readme.txt
+++ /dev/null
@@ -1,58 +0,0 @@
-This directory contains a .Net wrapper class library for the ZLib1.dll
-
-The wrapper includes support for inflating/deflating memory buffers,
-.Net streaming wrappers for the gz streams part of zlib, and wrappers
-for the checksum parts of zlib. See DotZLib/UnitTests.cs for examples.
-
-Directory structure:
---------------------
-
-LICENSE_1_0.txt       - License file.
-readme.txt            - This file.
-DotZLib.chm           - Class library documentation
-DotZLib.build         - NAnt build file
-DotZLib.sln           - Microsoft Visual Studio 2003 solution file
-
-DotZLib\*.cs          - Source files for the class library
-
-Unit tests:
------------
-The file DotZLib/UnitTests.cs contains unit tests for use with NUnit 2.1 or higher.
-To include unit tests in the build, define nunit before building.
-
-
-Build instructions:
--------------------
-
-1. Using Visual Studio.Net 2003:
-   Open DotZLib.sln in VS.Net and build from there. Output file (DotZLib.dll)
-   will be found ./DotZLib/bin/release or ./DotZLib/bin/debug, depending on
-   you are building the release or debug version of the library. Check
-   DotZLib/UnitTests.cs for instructions on how to include unit tests in the
-   build.
-
-2. Using NAnt:
-   Open a command prompt with access to the build environment and run nant
-   in the same directory as the DotZLib.build file.
-   You can define 2 properties on the nant command-line to control the build:
-   debug={true|false} to toggle between release/debug builds (default=true).
-   nunit={true|false} to include or esclude unit tests (default=true).
-   Also the target clean will remove binaries.
-   Output file (DotZLib.dll) will be found in either ./DotZLib/bin/release
-   or ./DotZLib/bin/debug, depending on whether you are building the release
-   or debug version of the library.
-
-   Examples:
-     nant -D:debug=false -D:nunit=false
-       will build a release mode version of the library without unit tests.
-     nant
-       will build a debug version of the library with unit tests
-     nant clean
-       will remove all previously built files.
-
-
----------------------------------
-Copyright (c) Henrik Ravn 2004
-
-Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/contrib/zlib/contrib/gcc_gvmat64/gvmat64.S b/contrib/zlib/contrib/gcc_gvmat64/gvmat64.S
deleted file mode 100644
index 23309fa28..000000000
--- a/contrib/zlib/contrib/gcc_gvmat64/gvmat64.S
+++ /dev/null
@@ -1,574 +0,0 @@
-/*
-;uInt longest_match_x64(
-;    deflate_state *s,
-;    IPos cur_match);                             // current match 
-
-; gvmat64.S -- Asm portion of the optimized longest_match for 32 bits x86_64
-;  (AMD64 on Athlon 64, Opteron, Phenom
-;     and Intel EM64T on Pentium 4 with EM64T, Pentium D, Core 2 Duo, Core I5/I7)
-; this file is translation from gvmat64.asm to GCC 4.x (for Linux, Mac XCode)
-; Copyright (C) 1995-2010 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-;
-; File written by Gilles Vollant, by converting to assembly the longest_match
-;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.
-;  and by taking inspiration on asm686 with masm, optimised assembly code
-;        from Brian Raiter, written 1998
-;
-;  This software is provided 'as-is', without any express or implied
-;  warranty.  In no event will the authors be held liable for any damages
-;  arising from the use of this software.
-;
-;  Permission is granted to anyone to use this software for any purpose,
-;  including commercial applications, and to alter it and redistribute it
-;  freely, subject to the following restrictions:
-;
-;  1. The origin of this software must not be misrepresented; you must not
-;     claim that you wrote the original software. If you use this software
-;     in a product, an acknowledgment in the product documentation would be
-;     appreciated but is not required.
-;  2. Altered source versions must be plainly marked as such, and must not be
-;     misrepresented as being the original software
-;  3. This notice may not be removed or altered from any source distribution.
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; to compile this file for zLib, I use option:
-;   gcc -c -arch x86_64 gvmat64.S
-
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             // current match /
-;
-; with XCode for Mac, I had strange error with some jump on intel syntax
-; this is why BEFORE_JMP and AFTER_JMP are used
- */
-
-
-#define BEFORE_JMP .att_syntax
-#define AFTER_JMP .intel_syntax noprefix
-
-#ifndef NO_UNDERLINE
-#	define	match_init	_match_init
-#	define	longest_match	_longest_match
-#endif
-
-.intel_syntax noprefix
-
-.globl	match_init, longest_match
-.text
-longest_match:
-
-
-
-#define LocalVarsSize 96
-/*
-; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12
-; free register :  r14,r15
-; register can be saved : rsp
-*/
-
-#define chainlenwmask     (rsp + 8 - LocalVarsSize)
-#define nicematch         (rsp + 16 - LocalVarsSize)
-
-#define save_rdi        (rsp + 24 - LocalVarsSize)
-#define save_rsi        (rsp + 32 - LocalVarsSize)
-#define save_rbx        (rsp + 40 - LocalVarsSize)
-#define save_rbp        (rsp + 48 - LocalVarsSize)
-#define save_r12        (rsp + 56 - LocalVarsSize)
-#define save_r13        (rsp + 64 - LocalVarsSize)
-#define save_r14        (rsp + 72 - LocalVarsSize)
-#define save_r15        (rsp + 80 - LocalVarsSize)
-
-
-/*
-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
-;  in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, remove the +4).
-;  Note : these value are good with a 8 bytes boundary pack structure
-*/
-
-#define    MAX_MATCH              258
-#define    MIN_MATCH              3
-#define    MIN_LOOKAHEAD          (MAX_MATCH+MIN_MATCH+1)
-
-/*
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-*/
-
-
-
-/* you can check the structure offset by running
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "deflate.h"
-
-void print_depl()
-{
-deflate_state ds;
-deflate_state *s=&ds;
-printf("size pointer=%u\n",(int)sizeof(void*));
-
-printf("#define dsWSize         %u\n",(int)(((char*)&(s->w_size))-((char*)s)));
-printf("#define dsWMask         %u\n",(int)(((char*)&(s->w_mask))-((char*)s)));
-printf("#define dsWindow        %u\n",(int)(((char*)&(s->window))-((char*)s)));
-printf("#define dsPrev          %u\n",(int)(((char*)&(s->prev))-((char*)s)));
-printf("#define dsMatchLen      %u\n",(int)(((char*)&(s->match_length))-((char*)s)));
-printf("#define dsPrevMatch     %u\n",(int)(((char*)&(s->prev_match))-((char*)s)));
-printf("#define dsStrStart      %u\n",(int)(((char*)&(s->strstart))-((char*)s)));
-printf("#define dsMatchStart    %u\n",(int)(((char*)&(s->match_start))-((char*)s)));
-printf("#define dsLookahead     %u\n",(int)(((char*)&(s->lookahead))-((char*)s)));
-printf("#define dsPrevLen       %u\n",(int)(((char*)&(s->prev_length))-((char*)s)));
-printf("#define dsMaxChainLen   %u\n",(int)(((char*)&(s->max_chain_length))-((char*)s)));
-printf("#define dsGoodMatch     %u\n",(int)(((char*)&(s->good_match))-((char*)s)));
-printf("#define dsNiceMatch     %u\n",(int)(((char*)&(s->nice_match))-((char*)s)));
-}
-*/
-
-#define dsWSize          68
-#define dsWMask          76
-#define dsWindow         80
-#define dsPrev           96
-#define dsMatchLen       144
-#define dsPrevMatch      148
-#define dsStrStart       156
-#define dsMatchStart     160
-#define dsLookahead      164
-#define dsPrevLen        168
-#define dsMaxChainLen    172
-#define dsGoodMatch      188
-#define dsNiceMatch      192
-
-#define window_size      [ rcx + dsWSize]
-#define WMask            [ rcx + dsWMask]
-#define window_ad        [ rcx + dsWindow]
-#define prev_ad          [ rcx + dsPrev]
-#define strstart         [ rcx + dsStrStart]
-#define match_start      [ rcx + dsMatchStart]
-#define Lookahead        [ rcx + dsLookahead] //; 0ffffffffh on infozip
-#define prev_length      [ rcx + dsPrevLen]
-#define max_chain_length [ rcx + dsMaxChainLen]
-#define good_match       [ rcx + dsGoodMatch]
-#define nice_match       [ rcx + dsNiceMatch]
-
-/*
-; windows:
-; parameter 1 in rcx(deflate state s), param 2 in rdx (cur match)
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.
-
-;
-; gcc on macosx-linux:
-; see http://www.x86-64.org/documentation/abi-0.99.pdf
-; param 1 in rdi, param 2 in rsi
-; rbx, rsp, rbp, r12 to r15 must be preserved
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-
-;;; Retrieve the function arguments. r8d will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-; ms: parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)
-; mac: param 1 in rdi, param 2 rsi
-; this clear high 32 bits of r8, which can be garbage in both r8 and rdx
-*/
-        mov [save_rbx],rbx
-        mov [save_rbp],rbp
-
-
-        mov rcx,rdi
-
-        mov r8d,esi
-
-
-        mov [save_r12],r12
-        mov [save_r13],r13
-        mov [save_r14],r14
-        mov [save_r15],r15
-
-
-//;;; uInt wmask = s->w_mask;
-//;;; unsigned chain_length = s->max_chain_length;
-//;;; if (s->prev_length >= s->good_match) {
-//;;;     chain_length >>= 2;
-//;;; }
-
-
-        mov edi, prev_length
-        mov esi, good_match
-        mov eax, WMask
-        mov ebx, max_chain_length
-        cmp edi, esi
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-//;;; chainlen is decremented once beforehand so that the function can
-//;;; use the sign flag instead of the zero flag for the exit test.
-//;;; It is then shifted into the high word, to make room for the wmask
-//;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-
-//;;; on zlib only
-//;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-
-
-        mov eax, nice_match
-        mov [chainlenwmask], ebx
-        mov r10d, Lookahead
-        cmp r10d, eax
-        cmovnl r10d, eax
-        mov [nicematch],r10d
-
-
-
-//;;; register Bytef *scan = s->window + s->strstart;
-        mov r10, window_ad
-        mov ebp, strstart
-        lea r13, [r10 + rbp]
-
-//;;; Determine how many bytes the scan ptr is off from being
-//;;; dword-aligned.
-
-         mov r9,r13
-         neg r13
-         and r13,3
-
-//;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-//;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-
-        mov eax, window_size
-        sub eax, MIN_LOOKAHEAD
-
-
-        xor edi,edi
-        sub ebp, eax
-
-        mov r11d, prev_length
-
-        cmovng ebp,edi
-
-//;;; int best_len = s->prev_length;
-
-
-//;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-       lea  rsi,[r10+r11]
-
-//;;; register ush scan_start = *(ushf*)scan;
-//;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-//;;; Posf *prev = s->prev;
-
-        movzx r12d,word ptr [r9]
-        movzx ebx, word ptr [r9 + r11 - 1]
-
-        mov rdi, prev_ad
-
-//;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-				
-						
-						
-LookupLoop1:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-		
-		
-		
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry1:
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jz  LookupLoopIsZero
-		AFTER_JMP
-
-LookupLoop2:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry2:
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jz  LookupLoopIsZero
-		AFTER_JMP
-
-LookupLoop4:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry4:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jnz LookupLoop1
-        jmp LookupLoopIsZero
-		AFTER_JMP
-/*
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; r8d = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-*/
-.balign 16
-LookupLoop:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jnz LookupLoop1
-		AFTER_JMP
-LookupLoopIsZero:
-        cmp     r12w, word ptr [r10 + r8]
-		BEFORE_JMP
-        jnz LookupLoop1
-		AFTER_JMP
-
-
-//;;; Store the current value of chainlen.
-        mov [chainlenwmask], edx
-/*
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-*/
-        lea rsi,[r8+r10]
-        mov rdx, 0xfffffffffffffef8 //; -(MAX_MATCH_8)
-        lea rsi, [rsi + r13 + 0x0108] //;MAX_MATCH_8]
-        lea rdi, [r9 + r13 + 0x0108] //;MAX_MATCH_8]
-
-        prefetcht1 [rsi+rdx]
-        prefetcht1 [rdi+rdx]
-
-/*
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust rdx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (rsi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-*/
-
-LoopCmps:
-        mov rax, [rsi + rdx]
-        xor rax, [rdi + rdx]
-        jnz LeaveLoopCmps
-
-        mov rax, [rsi + rdx + 8]
-        xor rax, [rdi + rdx + 8]
-        jnz LeaveLoopCmps8
-
-
-        mov rax, [rsi + rdx + 8+8]
-        xor rax, [rdi + rdx + 8+8]
-        jnz LeaveLoopCmps16
-
-        add rdx,8+8+8
-
-		BEFORE_JMP
-        jnz  LoopCmps
-        jmp  LenMaximum
-		AFTER_JMP
-		
-LeaveLoopCmps16: add rdx,8
-LeaveLoopCmps8: add rdx,8
-LeaveLoopCmps:
-
-        test    eax, 0x0000FFFF
-        jnz LenLower
-
-        test eax,0xffffffff
-
-        jnz LenLower32
-
-        add rdx,4
-        shr rax,32
-        or ax,ax
-		BEFORE_JMP
-        jnz LenLower
-		AFTER_JMP
-
-LenLower32:
-        shr eax,16
-        add rdx,2
-		
-LenLower:		
-        sub al, 1
-        adc rdx, 0
-//;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-//;;; then automatically accept it as the best possible match and leave.
-
-        lea rax, [rdi + rdx]
-        sub rax, r9
-        cmp eax, MAX_MATCH
-		BEFORE_JMP
-        jge LenMaximum
-		AFTER_JMP
-/*
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-;///////////////////////////////////
-*/
-        cmp eax, r11d
-        jg  LongerMatch
-
-        lea rsi,[r10+r11]
-
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-		BEFORE_JMP
-        jmp LookupLoop
-		AFTER_JMP
-/*
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-*/
-LongerMatch:
-        mov r11d, eax
-        mov match_start, r8d
-        cmp eax, [nicematch]
-		BEFORE_JMP
-        jge LeaveNow
-		AFTER_JMP
-
-        lea rsi,[r10+rax]
-
-        movzx   ebx, word ptr [r9 + rax - 1]
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-		BEFORE_JMP
-        jmp LookupLoop
-		AFTER_JMP
-
-//;;; Accept the current string, with the maximum possible length.
-
-LenMaximum:
-        mov r11d,MAX_MATCH
-        mov match_start, r8d
-
-//;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-//;;; return s->lookahead;
-
-LeaveNow:
-        mov eax, Lookahead
-        cmp r11d, eax
-        cmovng eax, r11d
-
-
-
-//;;; Restore the stack and return from whence we came.
-
-
-//        mov rsi,[save_rsi]
-//        mov rdi,[save_rdi]
-        mov rbx,[save_rbx]
-        mov rbp,[save_rbp]
-        mov r12,[save_r12]
-        mov r13,[save_r13]
-        mov r14,[save_r14]
-        mov r15,[save_r15]
-
-
-        ret 0
-//; please don't remove this string !
-//; Your can freely use gvmat64 in any free or commercial app
-//; but it is far better don't remove the string in the binary!
- //   db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0
-
-
-match_init:
-  ret 0
-
-
diff --git a/contrib/zlib/contrib/infback9/README b/contrib/zlib/contrib/infback9/README
deleted file mode 100644
index e75ed1329..000000000
--- a/contrib/zlib/contrib/infback9/README
+++ /dev/null
@@ -1 +0,0 @@
-See infback9.h for what this is and how to use it.
diff --git a/contrib/zlib/contrib/infback9/infback9.c b/contrib/zlib/contrib/infback9/infback9.c
deleted file mode 100644
index 05fb3e338..000000000
--- a/contrib/zlib/contrib/infback9/infback9.c
+++ /dev/null
@@ -1,615 +0,0 @@
-/* infback9.c -- inflate deflate64 data using a call-back interface
- * Copyright (C) 1995-2008 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infback9.h"
-#include "inftree9.h"
-#include "inflate9.h"
-
-#define WSIZE 65536UL
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   window is a user-supplied window and output buffer that is 64K bytes.
- */
-int ZEXPORT inflateBack9Init_(strm, window, version, stream_size)
-z_stream FAR *strm;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (voidpf)state;
-    state->window = window;
-    return Z_OK;
-}
-
-/*
-   Build and output length and distance decoding tables for fixed code
-   decoding.
- */
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-void makefixed9(void)
-{
-    unsigned sym, bits, low, size;
-    code *next, *lenfix, *distfix;
-    struct inflate_state state;
-    code fixed[544];
-
-    /* literal/length table */
-    sym = 0;
-    while (sym < 144) state.lens[sym++] = 8;
-    while (sym < 256) state.lens[sym++] = 9;
-    while (sym < 280) state.lens[sym++] = 7;
-    while (sym < 288) state.lens[sym++] = 8;
-    next = fixed;
-    lenfix = next;
-    bits = 9;
-    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);
-
-    /* distance table */
-    sym = 0;
-    while (sym < 32) state.lens[sym++] = 5;
-    distfix = next;
-    bits = 5;
-    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);
-
-    /* write tables */
-    puts("    /* inffix9.h -- table for decoding deflate64 fixed codes");
-    puts("     * Generated automatically by makefixed9().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", lenfix[low].op, lenfix[low].bits,
-               lenfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 5) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", distfix[low].op, distfix[low].bits,
-               distfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/* Macros for inflateBack(): */
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n <= 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = window; \
-            left = WSIZE; \
-            wrap = 1; \
-            if (out(out_desc, put, (unsigned)left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack9(strm, in, in_desc, out, out_desc)
-z_stream FAR *strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have;              /* available input */
-    unsigned long left;         /* available output */
-    inflate_mode mode;          /* current inflate mode */
-    int lastblock;              /* true if processing last block */
-    int wrap;                   /* true if the window has wrapped */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned extra;             /* extra bits needed */
-    unsigned long length;       /* literal or length of data to copy */
-    unsigned long offset;       /* distance back to copy string from */
-    unsigned long copy;         /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-#include "inffix9.h"
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    mode = TYPE;
-    lastblock = 0;
-    wrap = 0;
-    window = state->window;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = window;
-    left = WSIZE;
-    lencode = Z_NULL;
-    distcode = Z_NULL;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (lastblock) {
-                BYTEBITS();
-                mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            lastblock = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                lencode = lenfix;
-                lenbits = 9;
-                distcode = distfix;
-                distbits = 5;
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = LEN;                     /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                mode = BAD;
-                break;
-            }
-            length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %lu\n",
-                    length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (length != 0) {
-                copy = length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-            if (state->nlen > 286) {
-                strm->msg = (char *)"too many length symbols";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 7;
-            ret = inflate_table9(CODES, state->lens, 19, &(state->next),
-                                &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = lencode[BITS(lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    NEEDBITS(here.bits);
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftree9.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 9;
-            ret = inflate_table9(LENS, state->lens, state->nlen,
-                            &(state->next), &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                mode = BAD;
-                break;
-            }
-            distcode = (code const FAR *)(state->next);
-            distbits = 6;
-            ret = inflate_table9(DISTS, state->lens + state->nlen,
-                            state->ndist, &(state->next), &(distbits),
-                            state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            mode = LEN;
-
-        case LEN:
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = lencode[BITS(lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            length = (unsigned)here.val;
-
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(length);
-                left--;
-                mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            extra = (unsigned)(here.op) & 31;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                length += BITS(extra);
-                DROPBITS(extra);
-            }
-            Tracevv((stderr, "inflate:         length %lu\n", length));
-
-            /* get distance code */
-            for (;;) {
-                here = distcode[BITS(distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                mode = BAD;
-                break;
-            }
-            offset = (unsigned)here.val;
-
-            /* get distance extra bits, if any */
-            extra = (unsigned)(here.op) & 15;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                offset += BITS(extra);
-                DROPBITS(extra);
-            }
-            if (offset > WSIZE - (wrap ? 0: left)) {
-                strm->msg = (char *)"invalid distance too far back";
-                mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %lu\n", offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = WSIZE - offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - offset;
-                    copy = left;
-                }
-                if (copy > length) copy = length;
-                length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < WSIZE) {
-                if (out(out_desc, window, (unsigned)(WSIZE - left)))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBack9End(strm)
-z_stream FAR *strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff --git a/contrib/zlib/contrib/infback9/infback9.h b/contrib/zlib/contrib/infback9/infback9.h
deleted file mode 100644
index 1073c0a38..000000000
--- a/contrib/zlib/contrib/infback9/infback9.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* infback9.h -- header for using inflateBack9 functions
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * This header file and associated patches provide a decoder for PKWare's
- * undocumented deflate64 compression method (method 9).  Use with infback9.c,
- * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.
- * This should be compiled with zlib, since it uses zutil.h and zutil.o.
- * This code has not yet been tested on 16-bit architectures.  See the
- * comments in zlib.h for inflateBack() usage.  These functions are used
- * identically, except that there is no windowBits parameter, and a 64K
- * window must be provided.  Also if int's are 16 bits, then a zero for
- * the third parameter of the "out" function actually means 65536UL.
- * zlib.h must be included before this header file.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-ZEXTERN int ZEXPORT inflateBack9End OF((z_stream FAR *strm));
-ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define inflateBack9Init(strm, window) \
-        inflateBack9Init_((strm), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/contrib/zlib/contrib/infback9/inffix9.h b/contrib/zlib/contrib/infback9/inffix9.h
deleted file mode 100644
index ee5671d2d..000000000
--- a/contrib/zlib/contrib/infback9/inffix9.h
+++ /dev/null
@@ -1,107 +0,0 @@
-    /* inffix9.h -- table for decoding deflate64 fixed codes
-     * Generated automatically by makefixed9().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{132,8,115},{130,7,31},{0,8,112},
-        {0,8,48},{0,9,192},{128,7,10},{0,8,96},{0,8,32},{0,9,160},
-        {0,8,0},{0,8,128},{0,8,64},{0,9,224},{128,7,6},{0,8,88},
-        {0,8,24},{0,9,144},{131,7,59},{0,8,120},{0,8,56},{0,9,208},
-        {129,7,17},{0,8,104},{0,8,40},{0,9,176},{0,8,8},{0,8,136},
-        {0,8,72},{0,9,240},{128,7,4},{0,8,84},{0,8,20},{133,8,227},
-        {131,7,43},{0,8,116},{0,8,52},{0,9,200},{129,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},
-        {128,7,8},{0,8,92},{0,8,28},{0,9,152},{132,7,83},{0,8,124},
-        {0,8,60},{0,9,216},{130,7,23},{0,8,108},{0,8,44},{0,9,184},
-        {0,8,12},{0,8,140},{0,8,76},{0,9,248},{128,7,3},{0,8,82},
-        {0,8,18},{133,8,163},{131,7,35},{0,8,114},{0,8,50},{0,9,196},
-        {129,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},{0,8,130},
-        {0,8,66},{0,9,228},{128,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {132,7,67},{0,8,122},{0,8,58},{0,9,212},{130,7,19},{0,8,106},
-        {0,8,42},{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},
-        {128,7,5},{0,8,86},{0,8,22},{65,8,0},{131,7,51},{0,8,118},
-        {0,8,54},{0,9,204},{129,7,15},{0,8,102},{0,8,38},{0,9,172},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,236},{128,7,9},{0,8,94},
-        {0,8,30},{0,9,156},{132,7,99},{0,8,126},{0,8,62},{0,9,220},
-        {130,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{133,8,131},
-        {130,7,31},{0,8,113},{0,8,49},{0,9,194},{128,7,10},{0,8,97},
-        {0,8,33},{0,9,162},{0,8,1},{0,8,129},{0,8,65},{0,9,226},
-        {128,7,6},{0,8,89},{0,8,25},{0,9,146},{131,7,59},{0,8,121},
-        {0,8,57},{0,9,210},{129,7,17},{0,8,105},{0,8,41},{0,9,178},
-        {0,8,9},{0,8,137},{0,8,73},{0,9,242},{128,7,4},{0,8,85},
-        {0,8,21},{144,8,3},{131,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {129,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},
-        {0,8,69},{0,9,234},{128,7,8},{0,8,93},{0,8,29},{0,9,154},
-        {132,7,83},{0,8,125},{0,8,61},{0,9,218},{130,7,23},{0,8,109},
-        {0,8,45},{0,9,186},{0,8,13},{0,8,141},{0,8,77},{0,9,250},
-        {128,7,3},{0,8,83},{0,8,19},{133,8,195},{131,7,35},{0,8,115},
-        {0,8,51},{0,9,198},{129,7,11},{0,8,99},{0,8,35},{0,9,166},
-        {0,8,3},{0,8,131},{0,8,67},{0,9,230},{128,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{132,7,67},{0,8,123},{0,8,59},{0,9,214},
-        {130,7,19},{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},
-        {0,8,75},{0,9,246},{128,7,5},{0,8,87},{0,8,23},{77,8,0},
-        {131,7,51},{0,8,119},{0,8,55},{0,9,206},{129,7,15},{0,8,103},
-        {0,8,39},{0,9,174},{0,8,7},{0,8,135},{0,8,71},{0,9,238},
-        {128,7,9},{0,8,95},{0,8,31},{0,9,158},{132,7,99},{0,8,127},
-        {0,8,63},{0,9,222},{130,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},
-        {0,8,16},{132,8,115},{130,7,31},{0,8,112},{0,8,48},{0,9,193},
-        {128,7,10},{0,8,96},{0,8,32},{0,9,161},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,225},{128,7,6},{0,8,88},{0,8,24},{0,9,145},
-        {131,7,59},{0,8,120},{0,8,56},{0,9,209},{129,7,17},{0,8,104},
-        {0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},{0,9,241},
-        {128,7,4},{0,8,84},{0,8,20},{133,8,227},{131,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{129,7,13},{0,8,100},{0,8,36},{0,9,169},
-        {0,8,4},{0,8,132},{0,8,68},{0,9,233},{128,7,8},{0,8,92},
-        {0,8,28},{0,9,153},{132,7,83},{0,8,124},{0,8,60},{0,9,217},
-        {130,7,23},{0,8,108},{0,8,44},{0,9,185},{0,8,12},{0,8,140},
-        {0,8,76},{0,9,249},{128,7,3},{0,8,82},{0,8,18},{133,8,163},
-        {131,7,35},{0,8,114},{0,8,50},{0,9,197},{129,7,11},{0,8,98},
-        {0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {128,7,7},{0,8,90},{0,8,26},{0,9,149},{132,7,67},{0,8,122},
-        {0,8,58},{0,9,213},{130,7,19},{0,8,106},{0,8,42},{0,9,181},
-        {0,8,10},{0,8,138},{0,8,74},{0,9,245},{128,7,5},{0,8,86},
-        {0,8,22},{65,8,0},{131,7,51},{0,8,118},{0,8,54},{0,9,205},
-        {129,7,15},{0,8,102},{0,8,38},{0,9,173},{0,8,6},{0,8,134},
-        {0,8,70},{0,9,237},{128,7,9},{0,8,94},{0,8,30},{0,9,157},
-        {132,7,99},{0,8,126},{0,8,62},{0,9,221},{130,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},
-        {96,7,0},{0,8,81},{0,8,17},{133,8,131},{130,7,31},{0,8,113},
-        {0,8,49},{0,9,195},{128,7,10},{0,8,97},{0,8,33},{0,9,163},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,227},{128,7,6},{0,8,89},
-        {0,8,25},{0,9,147},{131,7,59},{0,8,121},{0,8,57},{0,9,211},
-        {129,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},{0,8,137},
-        {0,8,73},{0,9,243},{128,7,4},{0,8,85},{0,8,21},{144,8,3},
-        {131,7,43},{0,8,117},{0,8,53},{0,9,203},{129,7,13},{0,8,101},
-        {0,8,37},{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},
-        {128,7,8},{0,8,93},{0,8,29},{0,9,155},{132,7,83},{0,8,125},
-        {0,8,61},{0,9,219},{130,7,23},{0,8,109},{0,8,45},{0,9,187},
-        {0,8,13},{0,8,141},{0,8,77},{0,9,251},{128,7,3},{0,8,83},
-        {0,8,19},{133,8,195},{131,7,35},{0,8,115},{0,8,51},{0,9,199},
-        {129,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{128,7,7},{0,8,91},{0,8,27},{0,9,151},
-        {132,7,67},{0,8,123},{0,8,59},{0,9,215},{130,7,19},{0,8,107},
-        {0,8,43},{0,9,183},{0,8,11},{0,8,139},{0,8,75},{0,9,247},
-        {128,7,5},{0,8,87},{0,8,23},{77,8,0},{131,7,51},{0,8,119},
-        {0,8,55},{0,9,207},{129,7,15},{0,8,103},{0,8,39},{0,9,175},
-        {0,8,7},{0,8,135},{0,8,71},{0,9,239},{128,7,9},{0,8,95},
-        {0,8,31},{0,9,159},{132,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {130,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},
-        {0,8,79},{0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {128,5,1},{135,5,257},{131,5,17},{139,5,4097},{129,5,5},
-        {137,5,1025},{133,5,65},{141,5,16385},{128,5,3},{136,5,513},
-        {132,5,33},{140,5,8193},{130,5,9},{138,5,2049},{134,5,129},
-        {142,5,32769},{128,5,2},{135,5,385},{131,5,25},{139,5,6145},
-        {129,5,7},{137,5,1537},{133,5,97},{141,5,24577},{128,5,4},
-        {136,5,769},{132,5,49},{140,5,12289},{130,5,13},{138,5,3073},
-        {134,5,193},{142,5,49153}
-    };
diff --git a/contrib/zlib/contrib/infback9/inflate9.h b/contrib/zlib/contrib/infback9/inflate9.h
deleted file mode 100644
index ee9a79394..000000000
--- a/contrib/zlib/contrib/infback9/inflate9.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* inflate9.h -- internal inflate state definition
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-            LEN,        /* i: waiting for length/lit code */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD         /* got a data error -- remain here until reset */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to the BAD mode -- not shown for clarity)
-
-    Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or DONE
-            STORED -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
-                LEN -> LEN or TYPE
- */
-
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
-struct inflate_state {
-        /* sliding window */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-};
diff --git a/contrib/zlib/contrib/infback9/inftree9.c b/contrib/zlib/contrib/infback9/inftree9.c
deleted file mode 100644
index 5f4a76798..000000000
--- a/contrib/zlib/contrib/infback9/inftree9.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/* inftree9.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftree9.h"
-
-#define MAXBITS 15
-
-const char inflate9_copyright[] =
-   " inflate9 1.2.11 Copyright 1995-2017 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int inflate_table9(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code this;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,
-        19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
-        131, 163, 195, 227, 3, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,
-        130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,
-        133, 133, 133, 133, 144, 77, 202};
-    static const unsigned short dbase[32] = { /* Distance codes 0..31 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,
-        65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
-        4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
-    static const unsigned short dext[32] = { /* Distance codes 0..31 extra */
-        128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,
-        133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,
-        139, 139, 140, 140, 141, 141, 142, 142};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) return -1;            /* no codes! */
-    for (min = 1; min <= MAXBITS; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftree9.h
-       for more information.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if ((type == LENS && used >= ENOUGH_LENS) ||
-        (type == DISTS && used >= ENOUGH_DISTS))
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        this.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            this.op = (unsigned char)0;
-            this.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
-        }
-        else {
-            this.op = (unsigned char)(32 + 64);         /* end of block */
-            this.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = this;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += 1U << curr;
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used >= ENOUGH_LENS) ||
-                (type == DISTS && used >= ENOUGH_DISTS))
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    this.op = (unsigned char)64;                /* invalid code marker */
-    this.bits = (unsigned char)(len - drop);
-    this.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            curr = root;
-            this.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = this;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff --git a/contrib/zlib/contrib/infback9/inftree9.h b/contrib/zlib/contrib/infback9/inftree9.h
deleted file mode 100644
index 5ab21f0c6..000000000
--- a/contrib/zlib/contrib/infback9/inftree9.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* inftree9.h -- header to use inftree9.c
- * Copyright (C) 1995-2008 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    100eeeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1446, which is the sum of 852 for literal/length codes and 594 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 32 6 15" for distance codes returns 594.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in infback9.c.  If the root table size is changed,
-   then these maximum sizes would be need to be recalculated and updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 594
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table9() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff --git a/contrib/zlib/contrib/inflate86/inffas86.c b/contrib/zlib/contrib/inflate86/inffas86.c
deleted file mode 100644
index 7292f67b7..000000000
--- a/contrib/zlib/contrib/inflate86/inffas86.c
+++ /dev/null
@@ -1,1157 +0,0 @@
-/* inffas86.c is a hand tuned assembler version of
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } ar;
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->wnext;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((unsigned long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-    __asm__ __volatile__ (
-"        leaq    %0, %%rax\n"
-"        movq    %%rbp, 8(%%rax)\n"       /* save regs rbp and rsp */
-"        movq    %%rsp, (%%rax)\n"
-"        movq    %%rax, %%rsp\n"          /* make rsp point to &ar */
-"        movq    16(%%rsp), %%rsi\n"      /* rsi  = in */
-"        movq    32(%%rsp), %%rdi\n"      /* rdi  = out */
-"        movq    24(%%rsp), %%r9\n"       /* r9   = last */
-"        movq    48(%%rsp), %%r10\n"      /* r10  = end */
-"        movq    64(%%rsp), %%rbp\n"      /* rbp  = lcode */
-"        movq    72(%%rsp), %%r11\n"      /* r11  = dcode */
-"        movq    80(%%rsp), %%rdx\n"      /* rdx  = hold */
-"        movl    88(%%rsp), %%ebx\n"      /* ebx  = bits */
-"        movl    100(%%rsp), %%r12d\n"    /* r12d = lmask */
-"        movl    104(%%rsp), %%r13d\n"    /* r13d = dmask */
-                                          /* r14d = len */
-                                          /* r15d = dist */
-"        cld\n"
-"        cmpq    %%rdi, %%r10\n"
-"        je      .L_one_time\n"           /* if only one decode left */
-"        cmpq    %%rsi, %%r9\n"
-"        je      .L_one_time\n"
-"        jmp     .L_do_loop\n"
-
-".L_one_time:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code_one_time\n"
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-"        jmp     .L_get_length_code_one_time\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpq    %%rdi, %%r10\n"
-"        jbe     .L_break_loop\n"
-"        cmpq    %%rsi, %%r9\n"
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n"  /* eax = lcode[hold & lmask] */
-
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        movq    %%r12, %%r8\n"            /* r8 = lmask */
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-
-".L_get_length_code_one_time:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%r14d\n"         /* len = this */
-"        shrl    $16, %%r14d\n"           /* len = this.val */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r14d\n"         /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        movq    %%r13, %%r8\n"           /* r8 = dmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        andq    %%rdx, %%r8\n"           /* r8 &= hold */
-"        movl    (%%r11,%%r8,4), %%eax\n" /* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%r15d\n"         /* dist = this */
-"        shrl    $16, %%r15d\n"           /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r15d\n"         /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movq    %%rsi, %%r8\n"           /* save in so from can use it's reg */
-"        movq    %%rdi, %%rax\n"
-"        subq    40(%%rsp), %%rax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%rsi), %%al\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%r15d\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpq    %%rdi, 40(%%rsp)\n"      /* if out == beg, outside window */
-"        je      .L_check_window\n"
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movb    -1(%%rdi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r14d, %%eax\n"        /* eax += len */
-"        movl    (%%rbp,%%rax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r15d, %%eax\n"        /* eax += dist */
-"        movl    (%%r11,%%rax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = nbytes */
-"        movl    92(%%rsp), %%eax\n"     /* eax = wsize, prepare for dist cmp */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%r15d, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 96(%%rsp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        movq    56(%%rsp), %%rsi\n"     /* from  = window */
-"        subl    %%ecx, %%eax\n"         /* eax  -= nbytes */
-"        addq    %%rax, %%rsi\n"         /* from += wsize - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%r14d\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* eax -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = &out[ -dist ] */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    96(%%rsp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        movl    92(%%rsp), %%esi\n"     /* from  = wsize */
-"        addq    56(%%rsp), %%rsi\n"     /* from += window */
-"        addq    %%rax, %%rsi\n"         /* from += write */
-"        subq    %%rcx, %%rsi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    56(%%rsp), %%rsi\n"     /* from = window */
-"        movl    96(%%rsp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        movq    56(%%rsp), %%rsi\n"     /* rsi = window */
-"        addq    %%rax, %%rsi\n"
-"        subq    %%rcx, %%rsi\n"         /* from += write - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = len */
-"        rep     movsb\n"
-
-"        movq    %%r8, %%rsi\n"          /* move in back to %esi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    $4, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 116(%%rsp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movq    %%rsi, 16(%%rsp)\n"     /* in */
-"        movq    %%rdi, 32(%%rsp)\n"     /* out */
-"        movl    %%ebx, 88(%%rsp)\n"     /* bits */
-"        movq    %%rdx, 80(%%rsp)\n"     /* hold */
-"        movq    (%%rsp), %%rax\n"       /* restore rbp and rsp */
-"        movq    8(%%rsp), %%rbp\n"
-"        movq    %%rax, %%rsp\n"
-          :
-          : "m" (ar)
-          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-    );
-#elif ( defined( __GNUC__ ) || defined( __ICC ) ) && defined( __i386 )
-    __asm__ __volatile__ (
-"        leal    %0, %%eax\n"
-"        movl    %%esp, (%%eax)\n"        /* save esp, ebp */
-"        movl    %%ebp, 4(%%eax)\n"
-"        movl    %%eax, %%esp\n"
-"        movl    8(%%esp), %%esi\n"       /* esi = in */
-"        movl    16(%%esp), %%edi\n"      /* edi = out */
-"        movl    40(%%esp), %%edx\n"      /* edx = hold */
-"        movl    44(%%esp), %%ebx\n"      /* ebx = bits */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-
-"        cld\n"
-"        jmp     .L_do_loop\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpl    %%edi, 24(%%esp)\n"      /* out < end */
-"        jbe     .L_break_loop\n"
-"        cmpl    %%esi, 12(%%esp)\n"      /* in < last */
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        movl    56(%%esp), %%eax\n"      /* eax = lmask */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%ecx\n"          /* len = this */
-"        shrl    $16, %%ecx\n"            /* len = this.val */
-"        movl    %%ecx, 64(%%esp)\n"      /* save len */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_len\n"    /* if (op <= bits) */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, 64(%%esp)\n"      /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        movl    60(%%esp), %%eax\n"      /* eax = dmask */
-"        movl    36(%%esp), %%ecx\n"      /* ecx = dcode */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ecx,%%eax,4), %%eax\n"/* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%ebp\n"          /* dist = this */
-"        shrl    $16, %%ebp\n"            /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_dist\n"   /* if (op <= bits) 97.6% */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, %%ebp\n"          /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movl    %%esi, 8(%%esp)\n"       /* save in so from can use it's reg */
-"        movl    %%edi, %%eax\n"
-"        subl    20(%%esp), %%eax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%esi), %%al\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%ebp\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpl    %%edi, 20(%%esp)\n"
-"        je      .L_check_window\n"      /* out == beg, if outside window */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movb    -1(%%edi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    64(%%esp), %%eax\n"     /* eax += len */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%ebp, %%eax\n"         /* eax += dist */
-"        movl    36(%%esp), %%ecx\n"     /* ecx = dcode */
-"        movl    (%%ecx,%%eax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"
-"        movl    48(%%esp), %%eax\n"     /* eax = wsize */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%ebp, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 52(%%esp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        subl    %%ecx, %%eax\n"
-"        addl    %%eax, %%esi\n"         /* from += wsize - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    52(%%esp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        addl    48(%%esp), %%esi\n"     /* from += wsize */
-"        addl    %%eax, %%esi\n"         /* from += write */
-"        subl    %%ecx, %%esi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-"        movl    52(%%esp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        addl    %%eax, %%esi\n"
-"        subl    %%ecx, %%esi\n"         /* from += write - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"
-"        rep     movsb\n"
-
-"        movl    8(%%esp), %%esi\n"      /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"     /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    8(%%esp), %%esi\n"
-"        movl    $4, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 72(%%esp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movl    %%esi, 8(%%esp)\n"      /* save in */
-"        movl    %%edi, 16(%%esp)\n"     /* save out */
-"        movl    %%ebx, 44(%%esp)\n"     /* save bits */
-"        movl    %%edx, 40(%%esp)\n"     /* save hold */
-"        movl    4(%%esp), %%ebp\n"      /* restore esp, ebp */
-"        movl    (%%esp), %%esp\n"
-          :
-          : "m" (ar)
-          : "memory", "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
-    );
-#elif defined( _MSC_VER ) && ! defined( _M_AMD64 )
-    __asm {
-	lea	eax, ar
-	mov	[eax], esp         /* save esp, ebp */
-	mov	[eax+4], ebp
-	mov	esp, eax
-	mov	esi, [esp+8]       /* esi = in */
-	mov	edi, [esp+16]      /* edi = out */
-	mov	edx, [esp+40]      /* edx = hold */
-	mov	ebx, [esp+44]      /* ebx = bits */
-	mov	ebp, [esp+32]      /* ebp = lcode */
-
-	cld
-	jmp	L_do_loop
-
-ALIGN 4
-L_while_test:
-	cmp	[esp+24], edi
-	jbe	L_break_loop
-	cmp	[esp+12], esi
-	jbe	L_break_loop
-
-L_do_loop:
-	cmp	bl, 15
-	ja	L_get_length_code    /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-
-L_get_length_code:
-	mov	eax, [esp+56]      /* eax = lmask */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ebp+eax*4] /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            /* cl = this.bits */
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base /* if (op != 0) 45.7% */
-
-	shr	eax, 16            /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	ecx, eax          /* len = this */
-	shr	ecx, 16            /* len = this.val */
-	mov	[esp+64], ecx      /* save len */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-	and	cl, 15             /* op &= 15 */
-	jz	L_decode_distance    /* if (!op) */
-	cmp	bl, cl
-	jae	L_add_bits_to_len    /* if (op <= bits) */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	[esp+64], eax      /* len += hold & mask[op] */
-
-L_decode_distance:
-	cmp	bl, 15
-	ja	L_get_distance_code  /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-
-L_get_distance_code:
-	mov	eax, [esp+60]      /* eax = dmask */
-	mov	ecx, [esp+36]      /* ecx = dcode */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ecx+eax*4]/* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	ebp, eax          /* dist = this */
-	shr	ebp, 16            /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-	mov	cl, al            /* cl = this.op */
-
-	test	al, 16             /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             /* op &= 15 */
-	jz	L_check_dist_one
-	cmp	bl, cl
-	jae	L_add_bits_to_dist   /* if (op <= bits) 97.6% */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 /* (1 << op) - 1 */
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	ebp, eax          /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	[esp+8], esi       /* save in so from can use it's reg */
-	mov	eax, edi
-	sub	eax, [esp+20]      /* nbytes = out - beg */
-
-	cmp	eax, ebp
-	jb	L_clip_window        /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, [esp+64]      /* ecx = len */
-	mov	esi, edi
-	sub	esi, ebp          /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two
-
-	rep     movsw
-	mov	al, [esi]
-	mov	[edi], al
-	inc	edi
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	ebp, 1            /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[esp+20], edi
-	je	L_check_window    /* out == beg, if outside window */
-
-	mov	ecx, [esp+64]     /* ecx = len */
-	mov	al, [edi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[edi], al         /* memset out with from[-1] */
-	inc	edi
-
-L_set_two:
-	rep     stosw
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, [esp+64]     /* eax += len */
-	mov	eax, [ebp+eax*4] /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, ebp         /* eax += dist */
-	mov	ecx, [esp+36]     /* ecx = dcode */
-	mov	eax, [ecx+eax*4] /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax
-	mov	eax, [esp+48]     /* eax = wsize */
-	neg	ecx                /* nbytes = -nbytes */
-	mov	esi, [esp+28]     /* from = window */
-
-	cmp	eax, ebp
-	jb	L_invalid_distance_too_far /* if (dist > wsize) */
-
-	add	ecx, ebp         /* nbytes = dist - nbytes */
-	cmp	dword ptr [esp+52], 0
-	jne	L_wrap_around_window /* if (write != 0) */
-
-	sub	eax, ecx
-	add	esi, eax         /* from += wsize - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [esp+52]    /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window /* if (write >= nbytes) */
-
-	add	esi, [esp+48]    /* from += wsize */
-	add	esi, eax         /* from += write */
-	sub	esi, ecx         /* from -= nbytes */
-	sub	ecx, eax         /* nbytes -= write */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, [esp+28]     /* from = window */
-	mov	ecx, [esp+52]     /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	add	esi, eax
-	sub	esi, ecx         /* from += write - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax
-	rep     movsb
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [esp+72], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [esp+72], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [esp+72], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	esi, [esp+4]
-	mov	dword ptr [esp+72], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [esp+72], 0
-
-L_break_loop_with_status:
-/* put in, out, bits, and hold back into ar and pop esp */
-	mov	[esp+8], esi     /* save in */
-	mov	[esp+16], edi    /* save out */
-	mov	[esp+44], ebx    /* save bits */
-	mov	[esp+40], edx    /* save hold */
-	mov	ebp, [esp+4]     /* restore esp, ebp */
-	mov	esp, [esp]
-    }
-#else
-#error "x86 architecture not defined"
-#endif
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
diff --git a/contrib/zlib/contrib/inflate86/inffast.S b/contrib/zlib/contrib/inflate86/inffast.S
deleted file mode 100644
index 2245a2905..000000000
--- a/contrib/zlib/contrib/inflate86/inffast.S
+++ /dev/null
@@ -1,1368 +0,0 @@
-/*
- * inffast.S is a hand tuned assembler version of:
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * This version (Jan-23-2003) of inflate_fast was coded and tested under
- * GNU/Linux on a pentium 3, using the gcc-3.2 compiler distribution.  On that
- * machine, I found that gzip style archives decompressed about 20% faster than
- * the gcc-3.2 -O3 -fomit-frame-pointer compiled version.  Your results will
- * depend on how large of a buffer is used for z_stream.next_in & next_out
- * (8K-32K worked best for my 256K cpu cache) and how much overhead there is in
- * stream processing I/O and crc32/addler32.  In my case, this routine used
- * 70% of the cpu time and crc32 used 20%.
- *
- * I am confident that this version will work in the general case, but I have
- * not tested a wide variety of datasets or a wide variety of platforms.
- *
- * Jan-24-2003 -- Added -DUSE_MMX define for slightly faster inflating.
- * It should be a runtime flag instead of compile time flag...
- *
- * Jan-26-2003 -- Added runtime check for MMX support with cpuid instruction.
- * With -DUSE_MMX, only MMX code is compiled.  With -DNO_MMX, only non-MMX code
- * is compiled.  Without either option, runtime detection is enabled.  Runtime
- * detection should work on all modern cpus and the recomended algorithm (flip
- * ID bit on eflags and then use the cpuid instruction) is used in many
- * multimedia applications.  Tested under win2k with gcc-2.95 and gas-2.12
- * distributed with cygwin3.  Compiling with gcc-2.95 -c inffast.S -o
- * inffast.obj generates a COFF object which can then be linked with MSVC++
- * compiled code.  Tested under FreeBSD 4.7 with gcc-2.95.
- *
- * Jan-28-2003 -- Tested Athlon XP... MMX mode is slower than no MMX (and
- * slower than compiler generated code).  Adjusted cpuid check to use the MMX
- * code only for Pentiums < P4 until I have more data on the P4.  Speed
- * improvment is only about 15% on the Athlon when compared with code generated
- * with MSVC++.  Not sure yet, but I think the P4 will also be slower using the
- * MMX mode because many of it's x86 ALU instructions execute in .5 cycles and
- * have less latency than MMX ops.  Added code to buffer the last 11 bytes of
- * the input stream since the MMX code grabs bits in chunks of 32, which
- * differs from the inffast.c algorithm.  I don't think there would have been
- * read overruns where a page boundary was crossed (a segfault), but there
- * could have been overruns when next_in ends on unaligned memory (unintialized
- * memory read).
- *
- * Mar-13-2003 -- P4 MMX is slightly slower than P4 NO_MMX.  I created a C
- * version of the non-MMX code so that it doesn't depend on zstrm and zstate
- * structure offsets which are hard coded in this file.  This was last tested
- * with zlib-1.2.0 which is currently in beta testing, newer versions of this
- * and inffas86.c can be found at http://www.eetbeetee.com/zlib/ and
- * http://www.charm.net/~christop/zlib/
- */
-
-
-/*
- * if you have underscore linking problems (_inflate_fast undefined), try
- * using -DGAS_COFF
- */
-#if ! defined( GAS_COFF ) && ! defined( GAS_ELF )
-
-#if defined( WIN32 ) || defined( __CYGWIN__ )
-#define GAS_COFF /* windows object format */
-#else
-#define GAS_ELF
-#endif
-
-#endif /* ! GAS_COFF && ! GAS_ELF */
-
-
-#if defined( GAS_COFF )
-
-/* coff externals have underscores */
-#define inflate_fast _inflate_fast
-#define inflate_fast_use_mmx _inflate_fast_use_mmx
-
-#endif /* GAS_COFF */
-
-
-.file "inffast.S"
-
-.globl inflate_fast
-
-.text
-.align 4,0
-.L_invalid_literal_length_code_msg:
-.string "invalid literal/length code"
-
-.align 4,0
-.L_invalid_distance_code_msg:
-.string "invalid distance code"
-
-.align 4,0
-.L_invalid_distance_too_far_msg:
-.string "invalid distance too far back"
-
-#if ! defined( NO_MMX )
-.align 4,0
-.L_mask: /* mask[N] = ( 1 << N ) - 1 */
-.long 0
-.long 1
-.long 3
-.long 7
-.long 15
-.long 31
-.long 63
-.long 127
-.long 255
-.long 511
-.long 1023
-.long 2047
-.long 4095
-.long 8191
-.long 16383
-.long 32767
-.long 65535
-.long 131071
-.long 262143
-.long 524287
-.long 1048575
-.long 2097151
-.long 4194303
-.long 8388607
-.long 16777215
-.long 33554431
-.long 67108863
-.long 134217727
-.long 268435455
-.long 536870911
-.long 1073741823
-.long 2147483647
-.long 4294967295
-#endif /* NO_MMX */
-
-.text
-
-/*
- * struct z_stream offsets, in zlib.h
- */
-#define next_in_strm   0   /* strm->next_in */
-#define avail_in_strm  4   /* strm->avail_in */
-#define next_out_strm  12  /* strm->next_out */
-#define avail_out_strm 16  /* strm->avail_out */
-#define msg_strm       24  /* strm->msg */
-#define state_strm     28  /* strm->state */
-
-/*
- * struct inflate_state offsets, in inflate.h
- */
-#define mode_state     0   /* state->mode */
-#define wsize_state    32  /* state->wsize */
-#define write_state    40  /* state->write */
-#define window_state   44  /* state->window */
-#define hold_state     48  /* state->hold */
-#define bits_state     52  /* state->bits */
-#define lencode_state  68  /* state->lencode */
-#define distcode_state 72  /* state->distcode */
-#define lenbits_state  76  /* state->lenbits */
-#define distbits_state 80  /* state->distbits */
-
-/*
- * inflate_fast's activation record
- */
-#define local_var_size 64 /* how much local space for vars */
-#define strm_sp        88 /* first arg: z_stream * (local_var_size + 24) */
-#define start_sp       92 /* second arg: unsigned int (local_var_size + 28) */
-
-/*
- * offsets for local vars on stack
- */
-#define out            60  /* unsigned char* */
-#define window         56  /* unsigned char* */
-#define wsize          52  /* unsigned int */
-#define write          48  /* unsigned int */
-#define in             44  /* unsigned char* */
-#define beg            40  /* unsigned char* */
-#define buf            28  /* char[ 12 ] */
-#define len            24  /* unsigned int */
-#define last           20  /* unsigned char* */
-#define end            16  /* unsigned char* */
-#define dcode          12  /* code* */
-#define lcode           8  /* code* */
-#define dmask           4  /* unsigned int */
-#define lmask           0  /* unsigned int */
-
-/*
- * typedef enum inflate_mode consts, in inflate.h
- */
-#define INFLATE_MODE_TYPE 11  /* state->mode flags enum-ed in inflate.h */
-#define INFLATE_MODE_BAD  26
-
-
-#if ! defined( USE_MMX ) && ! defined( NO_MMX )
-
-#define RUN_TIME_MMX
-
-#define CHECK_MMX    1
-#define DO_USE_MMX   2
-#define DONT_USE_MMX 3
-
-.globl inflate_fast_use_mmx
-
-.data
-
-.align 4,0
-inflate_fast_use_mmx: /* integer flag for run time control 1=check,2=mmx,3=no */
-.long CHECK_MMX
-
-#if defined( GAS_ELF )
-/* elf info */
-.type   inflate_fast_use_mmx,@object
-.size   inflate_fast_use_mmx,4
-#endif
-
-#endif /* RUN_TIME_MMX */
-
-#if defined( GAS_COFF )
-/* coff info: scl 2 = extern, type 32 = function */
-.def inflate_fast; .scl 2; .type 32; .endef
-#endif
-
-.text
-
-.align 32,0x90
-inflate_fast:
-        pushl   %edi
-        pushl   %esi
-        pushl   %ebp
-        pushl   %ebx
-        pushf   /* save eflags (strm_sp, state_sp assumes this is 32 bits) */
-        subl    $local_var_size, %esp
-        cld
-
-#define strm_r  %esi
-#define state_r %edi
-
-        movl    strm_sp(%esp), strm_r
-        movl    state_strm(strm_r), state_r
-
-        /* in = strm->next_in;
-         * out = strm->next_out;
-         * last = in + strm->avail_in - 11;
-         * beg = out - (start - strm->avail_out);
-         * end = out + (strm->avail_out - 257);
-         */
-        movl    avail_in_strm(strm_r), %edx
-        movl    next_in_strm(strm_r), %eax
-
-        addl    %eax, %edx      /* avail_in += next_in */
-        subl    $11, %edx       /* avail_in -= 11 */
-
-        movl    %eax, in(%esp)
-        movl    %edx, last(%esp)
-
-        movl    start_sp(%esp), %ebp
-        movl    avail_out_strm(strm_r), %ecx
-        movl    next_out_strm(strm_r), %ebx
-
-        subl    %ecx, %ebp      /* start -= avail_out */
-        negl    %ebp            /* start = -start */
-        addl    %ebx, %ebp      /* start += next_out */
-
-        subl    $257, %ecx      /* avail_out -= 257 */
-        addl    %ebx, %ecx      /* avail_out += out */
-
-        movl    %ebx, out(%esp)
-        movl    %ebp, beg(%esp)
-        movl    %ecx, end(%esp)
-
-        /* wsize = state->wsize;
-         * write = state->write;
-         * window = state->window;
-         * hold = state->hold;
-         * bits = state->bits;
-         * lcode = state->lencode;
-         * dcode = state->distcode;
-         * lmask = ( 1 << state->lenbits ) - 1;
-         * dmask = ( 1 << state->distbits ) - 1;
-         */
-
-        movl    lencode_state(state_r), %eax
-        movl    distcode_state(state_r), %ecx
-
-        movl    %eax, lcode(%esp)
-        movl    %ecx, dcode(%esp)
-
-        movl    $1, %eax
-        movl    lenbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, lmask(%esp)
-
-        movl    $1, %eax
-        movl    distbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, dmask(%esp)
-
-        movl    wsize_state(state_r), %eax
-        movl    write_state(state_r), %ecx
-        movl    window_state(state_r), %edx
-
-        movl    %eax, wsize(%esp)
-        movl    %ecx, write(%esp)
-        movl    %edx, window(%esp)
-
-        movl    hold_state(state_r), %ebp
-        movl    bits_state(state_r), %ebx
-
-#undef strm_r
-#undef state_r
-
-#define in_r       %esi
-#define from_r     %esi
-#define out_r      %edi
-
-        movl    in(%esp), in_r
-        movl    last(%esp), %ecx
-        cmpl    in_r, %ecx
-        ja      .L_align_long           /* if in < last */
-
-        addl    $11, %ecx               /* ecx = &in[ avail_in ] */
-        subl    in_r, %ecx              /* ecx = avail_in */
-        movl    $12, %eax
-        subl    %ecx, %eax              /* eax = 12 - avail_in */
-        leal    buf(%esp), %edi
-        rep     movsb                   /* memcpy( buf, in, avail_in ) */
-        movl    %eax, %ecx
-        xorl    %eax, %eax
-        rep     stosb         /* memset( &buf[ avail_in ], 0, 12 - avail_in ) */
-        leal    buf(%esp), in_r         /* in = buf */
-        movl    in_r, last(%esp)        /* last = in, do just one iteration */
-        jmp     .L_is_aligned
-
-        /* align in_r on long boundary */
-.L_align_long:
-        testl   $3, in_r
-        jz      .L_is_aligned
-        xorl    %eax, %eax
-        movb    (in_r), %al
-        incl    in_r
-        movl    %ebx, %ecx
-        addl    $8, %ebx
-        shll    %cl, %eax
-        orl     %eax, %ebp
-        jmp     .L_align_long
-
-.L_is_aligned:
-        movl    out(%esp), out_r
-
-#if defined( NO_MMX )
-        jmp     .L_do_loop
-#endif
-
-#if defined( USE_MMX )
-        jmp     .L_init_mmx
-#endif
-
-/*** Runtime MMX check ***/
-
-#if defined( RUN_TIME_MMX )
-.L_check_mmx:
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        je      .L_init_mmx
-        ja      .L_do_loop /* > 2 */
-
-        pushl   %eax
-        pushl   %ebx
-        pushl   %ecx
-        pushl   %edx
-        pushf
-        movl    (%esp), %eax      /* copy eflags to eax */
-        xorl    $0x200000, (%esp) /* try toggling ID bit of eflags (bit 21)
-                                   * to see if cpu supports cpuid...
-                                   * ID bit method not supported by NexGen but
-                                   * bios may load a cpuid instruction and
-                                   * cpuid may be disabled on Cyrix 5-6x86 */
-        popf
-        pushf
-        popl    %edx              /* copy new eflags to edx */
-        xorl    %eax, %edx        /* test if ID bit is flipped */
-        jz      .L_dont_use_mmx   /* not flipped if zero */
-        xorl    %eax, %eax
-        cpuid
-        cmpl    $0x756e6547, %ebx /* check for GenuineIntel in ebx,ecx,edx */
-        jne     .L_dont_use_mmx
-        cmpl    $0x6c65746e, %ecx
-        jne     .L_dont_use_mmx
-        cmpl    $0x49656e69, %edx
-        jne     .L_dont_use_mmx
-        movl    $1, %eax
-        cpuid                     /* get cpu features */
-        shrl    $8, %eax
-        andl    $15, %eax
-        cmpl    $6, %eax          /* check for Pentium family, is 0xf for P4 */
-        jne     .L_dont_use_mmx
-        testl   $0x800000, %edx   /* test if MMX feature is set (bit 23) */
-        jnz     .L_use_mmx
-        jmp     .L_dont_use_mmx
-.L_use_mmx:
-        movl    $DO_USE_MMX, inflate_fast_use_mmx
-        jmp     .L_check_mmx_pop
-.L_dont_use_mmx:
-        movl    $DONT_USE_MMX, inflate_fast_use_mmx
-.L_check_mmx_pop:
-        popl    %edx
-        popl    %ecx
-        popl    %ebx
-        popl    %eax
-        jmp     .L_check_mmx
-#endif
-
-
-/*** Non-MMX code ***/
-
-#if defined ( NO_MMX ) || defined( RUN_TIME_MMX )
-
-#define hold_r     %ebp
-#define bits_r     %bl
-#define bitslong_r %ebx
-
-.align 32,0x90
-.L_while_test:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * do {
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = lcode[hold & lmask]
-         */
-        cmpb    $15, bits_r
-        ja      .L_get_length_code      /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_length_code:
-        movl    lmask(%esp), %edx       /* edx = lmask */
-        movl    lcode(%esp), %ecx       /* ecx = lcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * dolen:
-         *    bits -= this.bits;
-         *    hold >>= this.bits
-         */
-        movb    %ah, %cl                /* cl = this.bits */
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* check if op is a literal
-         * if (op == 0) {
-         *    PUP(out) = this.val;
-         *  }
-         */
-        testb   %al, %al
-        jnz     .L_test_for_length_base /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test
-
-.L_test_for_length_base:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = len
-         *
-         * else if (op & 16) {
-         *   len = this.val
-         *   op &= 15
-         *   if (op) {
-         *     if (op > bits) {
-         *       hold |= *((unsigned short *)in)++ << bits;
-         *       bits += 16
-         *     }
-         *     len += hold & mask[op];
-         *     bits -= op;
-         *     hold >>= op;
-         *   }
-         */
-#define len_r %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-        movb    %al, %cl
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_save_len             /* if (!op) */
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_len      /* if (op <= bits) */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_len:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, len_r             /* len += hold & mask[op] */
-
-.L_save_len:
-        movl    len_r, len(%esp)        /* save len */
-#undef  len_r
-
-.L_decode_distance:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = dcode[hold & dmask];
-         * dodist:
-         *   bits -= this.bits;
-         *   hold >>= this.bits;
-         *   op = this.op;
-         */
-
-        cmpb    $15, bits_r
-        ja      .L_get_distance_code    /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_distance_code:
-        movl    dmask(%esp), %edx       /* edx = dmask */
-        movl    dcode(%esp), %ecx       /* ecx = dcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = dcode[hold & dmask] */
-
-#define dist_r %edx
-.L_dodist:
-        movl    %eax, dist_r            /* dist = this */
-        shrl    $16, dist_r             /* dist = this.val */
-        movb    %ah, %cl
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* if (op & 16) {
-         *   dist = this.val
-         *   op &= 15
-         *   if (op > bits) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   dist += hold & mask[op];
-         *   bits -= op;
-         *   hold >>= op;
-         */
-        movb    %al, %cl                /* cl = this.op */
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_check_dist_one
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_dist     /* if (op <= bits) 97.6% */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_dist:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax                    /* (1 << op) - 1 */
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, dist_r            /* dist += hold & ((1 << op) - 1) */
-        jmp     .L_check_window
-
-.L_check_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * nbytes = out - beg;
-         * if (dist <= nbytes) {
-         *   from = out - dist;
-         *   do {
-         *     PUP(out) = PUP(from);
-         *   } while (--len > 0) {
-         * }
-         */
-
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window          /* if (dist > nbytes) 4.2% */
-
-        movl    len(%esp), %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_check_dist_one:
-        cmpl    $1, dist_r
-        jne     .L_check_window
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window
-
-        decl    out_r
-        movl    len(%esp), %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_test_for_second_level_length:
-        /* else if ((op & 64) == 0) {
-         *   this = lcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    lcode(%esp), %edx       /* edx = lcode */
-        movl    (%edx,%eax,4), %eax     /* eax = lcode[val + (hold&mask[op])] */
-        jmp     .L_dolen
-
-.align 16,0x90
-.L_test_for_second_level_dist:
-        /* else if ((op & 64) == 0) {
-         *   this = dcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    dcode(%esp), %edx       /* edx = dcode */
-        movl    (%edx,%eax,4), %eax     /* eax = dcode[val + (hold&mask[op])] */
-        jmp     .L_dodist
-
-.align 16,0x90
-.L_clip_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * else {
-         *   if (dist > wsize) {
-         *     invalid distance
-         *   }
-         *   from = window;
-         *   nbytes = dist - nbytes;
-         *   if (write == 0) {
-         *     from += wsize - nbytes;
-         */
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window   /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = len
-         *
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define len_r %eax
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_wrap_around_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else if (write < nbytes) {
-         *     from += wsize + write - nbytes;
-         *     nbytes -= write;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = window;
-         *       nbytes = write;
-         *       if (nbytes < len) {
-         *         len -= nbytes;
-         *         do {
-         *           PUP(out) = PUP(from);
-         *         } while(--nbytes);
-         *         from = out - dist;
-         *       }
-         *     }
-         *   }
-         */
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_contiguous_in_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else {
-         *     from += write - nbytes;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1:
-        /* regs: %esi = from, %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *       %eax = len
-         *
-         *     while (len > 0) {
-         *       PUP(out) = PUP(from);
-         *       len--;
-         *     }
-         *   }
-         * } while (in < last && out < end);
-         */
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-#undef len_r
-#undef dist_r
-
-#endif /* NO_MMX || RUN_TIME_MMX */
-
-
-/*** MMX code ***/
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-.align 32,0x90
-.L_init_mmx:
-        emms
-
-#undef  bits_r
-#undef  bitslong_r
-#define bitslong_r %ebp
-#define hold_mm    %mm0
-        movd    %ebp, hold_mm
-        movl    %ebx, bitslong_r
-
-#define used_mm   %mm1
-#define dmask2_mm %mm2
-#define lmask2_mm %mm3
-#define lmask_mm  %mm4
-#define dmask_mm  %mm5
-#define tmp_mm    %mm6
-
-        movd    lmask(%esp), lmask_mm
-        movq    lmask_mm, lmask2_mm
-        movd    dmask(%esp), dmask_mm
-        movq    dmask_mm, dmask2_mm
-        pxor    used_mm, used_mm
-        movl    lcode(%esp), %ebx       /* ebx = lcode */
-        jmp     .L_do_loop_mmx
-
-.align 32,0x90
-.L_while_test_mmx:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_length_code_mmx  /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_length_code_mmx:
-        pand    hold_mm, lmask_mm
-        movd    lmask_mm, %eax
-        movq    lmask2_mm, lmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen_mmx:
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movd    %ecx, used_mm
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-
-        testb   %al, %al
-        jnz     .L_test_for_length_base_mmx /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test_mmx
-
-.L_test_for_length_base_mmx:
-#define len_r  %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length_mmx /* if ((op & 16) == 0) 8% */
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_decode_distance_mmx  /* if (!op) */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm
-        movd    hold_mm, %ecx
-        subl    %eax, bitslong_r
-        andl    .L_mask(,%eax,4), %ecx
-        addl    %ecx, len_r             /* len += hold & mask[op] */
-
-.L_decode_distance_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_dist_code_mmx    /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_dist_code_mmx:
-        movl    dcode(%esp), %ebx       /* ebx = dcode */
-        pand    hold_mm, dmask_mm
-        movd    dmask_mm, %eax
-        movq    dmask2_mm, dmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = dcode[hold & lmask] */
-
-.L_dodist_mmx:
-#define dist_r %ebx
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movl    %eax, dist_r
-        shrl    $16, dist_r             /* dist  = this.val */
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-        movd    %ecx, used_mm
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist_mmx
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_check_dist_one_mmx
-
-.L_add_bits_to_dist_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm           /* save bit length of current op */
-        movd    hold_mm, %ecx           /* get the next bits on input stream */
-        subl    %eax, bitslong_r        /* bits -= op bits */
-        andl    .L_mask(,%eax,4), %ecx  /* ecx   = hold & mask[op] */
-        addl    %ecx, dist_r            /* dist += hold & mask[op] */
-
-.L_check_window_mmx:
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window_mmx      /* if (dist > nbytes) 4.2% */
-
-        movl    len_r, %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_check_dist_one_mmx:
-        cmpl    $1, dist_r
-        jne     .L_check_window_mmx
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window_mmx
-
-        decl    out_r
-        movl    len_r, %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_test_for_second_level_length_mmx:
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        addl    len_r, %ecx
-        movl    (%ebx,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dolen_mmx
-
-.align 16,0x90
-.L_test_for_second_level_dist_mmx:
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        movl    dcode(%esp), %eax       /* ecx = dcode */
-        addl    dist_r, %ecx
-        movl    (%eax,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dodist_mmx
-
-.align 16,0x90
-.L_clip_window_mmx:
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window_mmx /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_wrap_around_window_mmx:
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window_mmx /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_contiguous_in_window_mmx:
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1_mmx:
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-#undef hold_r
-#undef bitslong_r
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-
-/*** USE_MMX, NO_MMX, and RUNTIME_MMX from here on ***/
-
-.L_invalid_distance_code:
-        /* else {
-         *   strm->msg = "invalid distance code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_distance_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_test_for_end_of_block:
-        /* else if (op & 32) {
-         *   state->mode = TYPE;
-         *   break;
-         * }
-         */
-        testb   $32, %al
-        jz      .L_invalid_literal_length_code  /* if ((op & 32) == 0) */
-
-        movl    $0, %ecx
-        movl    $INFLATE_MODE_TYPE, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_literal_length_code:
-        /* else {
-         *   strm->msg = "invalid literal/length code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_literal_length_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_distance_too_far:
-        /* strm->msg = "invalid distance too far back";
-         * state->mode = BAD;
-         */
-        movl    in(%esp), in_r          /* from_r has in's reg, put in back */
-        movl    $.L_invalid_distance_too_far_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_update_stream_state:
-        /* set strm->msg = %ecx, strm->state->mode = %edx */
-        movl    strm_sp(%esp), %eax
-        testl   %ecx, %ecx              /* if (msg != NULL) */
-        jz      .L_skip_msg
-        movl    %ecx, msg_strm(%eax)    /* strm->msg = msg */
-.L_skip_msg:
-        movl    state_strm(%eax), %eax  /* state = strm->state */
-        movl    %edx, mode_state(%eax)  /* state->mode = edx (BAD | TYPE) */
-        jmp     .L_break_loop
-
-.align 32,0x90
-.L_break_loop:
-
-/*
- * Regs:
- *
- * bits = %ebp when mmx, and in %ebx when non-mmx
- * hold = %hold_mm when mmx, and in %ebp when non-mmx
- * in   = %esi
- * out  = %edi
- */
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_next_in
-
-#endif /* RUN_TIME_MMX */
-
-        movl    %ebp, %ebx
-
-.L_update_next_in:
-
-#endif
-
-#define strm_r  %eax
-#define state_r %edx
-
-        /* len = bits >> 3;
-         * in -= len;
-         * bits -= len << 3;
-         * hold &= (1U << bits) - 1;
-         * state->hold = hold;
-         * state->bits = bits;
-         * strm->next_in = in;
-         * strm->next_out = out;
-         */
-        movl    strm_sp(%esp), strm_r
-        movl    %ebx, %ecx
-        movl    state_strm(strm_r), state_r
-        shrl    $3, %ecx
-        subl    %ecx, in_r
-        shll    $3, %ecx
-        subl    %ecx, %ebx
-        movl    out_r, next_out_strm(strm_r)
-        movl    %ebx, bits_state(state_r)
-        movl    %ebx, %ecx
-
-        leal    buf(%esp), %ebx
-        cmpl    %ebx, last(%esp)
-        jne     .L_buf_not_used         /* if buf != last */
-
-        subl    %ebx, in_r              /* in -= buf */
-        movl    next_in_strm(strm_r), %ebx
-        movl    %ebx, last(%esp)        /* last = strm->next_in */
-        addl    %ebx, in_r              /* in += strm->next_in */
-        movl    avail_in_strm(strm_r), %ebx
-        subl    $11, %ebx
-        addl    %ebx, last(%esp)    /* last = &strm->next_in[ avail_in - 11 ] */
-
-.L_buf_not_used:
-        movl    in_r, next_in_strm(strm_r)
-
-        movl    $1, %ebx
-        shll    %cl, %ebx
-        decl    %ebx
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_hold
-
-#endif /* RUN_TIME_MMX */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ebp
-
-        emms
-
-.L_update_hold:
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-        andl    %ebx, %ebp
-        movl    %ebp, hold_state(state_r)
-
-#define last_r %ebx
-
-        /* strm->avail_in = in < last ? 11 + (last - in) : 11 - (in - last) */
-        movl    last(%esp), last_r
-        cmpl    in_r, last_r
-        jbe     .L_last_is_smaller     /* if (in >= last) */
-
-        subl    in_r, last_r           /* last -= in */
-        addl    $11, last_r            /* last += 11 */
-        movl    last_r, avail_in_strm(strm_r)
-        jmp     .L_fixup_out
-.L_last_is_smaller:
-        subl    last_r, in_r           /* in -= last */
-        negl    in_r                   /* in = -in */
-        addl    $11, in_r              /* in += 11 */
-        movl    in_r, avail_in_strm(strm_r)
-
-#undef last_r
-#define end_r %ebx
-
-.L_fixup_out:
-        /* strm->avail_out = out < end ? 257 + (end - out) : 257 - (out - end)*/
-        movl    end(%esp), end_r
-        cmpl    out_r, end_r
-        jbe     .L_end_is_smaller      /* if (out >= end) */
-
-        subl    out_r, end_r           /* end -= out */
-        addl    $257, end_r            /* end += 257 */
-        movl    end_r, avail_out_strm(strm_r)
-        jmp     .L_done
-.L_end_is_smaller:
-        subl    end_r, out_r           /* out -= end */
-        negl    out_r                  /* out = -out */
-        addl    $257, out_r            /* out += 257 */
-        movl    out_r, avail_out_strm(strm_r)
-
-#undef end_r
-#undef strm_r
-#undef state_r
-
-.L_done:
-        addl    $local_var_size, %esp
-        popf
-        popl    %ebx
-        popl    %ebp
-        popl    %esi
-        popl    %edi
-        ret
-
-#if defined( GAS_ELF )
-/* elf info */
-.type inflate_fast,@function
-.size inflate_fast,.-inflate_fast
-#endif
diff --git a/contrib/zlib/contrib/iostream/test.cpp b/contrib/zlib/contrib/iostream/test.cpp
deleted file mode 100644
index 7d265b3b5..000000000
--- a/contrib/zlib/contrib/iostream/test.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-
-#include "zfstream.h"
-
-int main() {
-
-  // Construct a stream object with this filebuffer.  Anything sent
-  // to this stream will go to standard out.
-  gzofstream os( 1, ios::out );
-
-  // This text is getting compressed and sent to stdout.
-  // To prove this, run 'test | zcat'.
-  os << "Hello, Mommy" << endl;
-
-  os << setcompressionlevel( Z_NO_COMPRESSION );
-  os << "hello, hello, hi, ho!" << endl;
-
-  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )
-    << "I'm compressing again" << endl;
-
-  os.close();
-
-  return 0;
-
-}
diff --git a/contrib/zlib/contrib/iostream/zfstream.cpp b/contrib/zlib/contrib/iostream/zfstream.cpp
deleted file mode 100644
index d0cd85faa..000000000
--- a/contrib/zlib/contrib/iostream/zfstream.cpp
+++ /dev/null
@@ -1,329 +0,0 @@
-
-#include "zfstream.h"
-
-gzfilebuf::gzfilebuf() :
-  file(NULL),
-  mode(0),
-  own_file_descriptor(0)
-{ }
-
-gzfilebuf::~gzfilebuf() {
-
-  sync();
-  if ( own_file_descriptor )
-    close();
-
-}
-
-gzfilebuf *gzfilebuf::open( const char *name,
-                            int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzopen(name, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 1;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::attach( int file_descriptor,
-                              int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 0;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::close() {
-
-  if ( is_open() ) {
-
-    sync();
-    gzclose( file );
-    file = NULL;
-
-  }
-
-  return this;
-
-}
-
-int gzfilebuf::setcompressionlevel( int comp_level ) {
-
-  return gzsetparams(file, comp_level, -2);
-
-}
-
-int gzfilebuf::setcompressionstrategy( int comp_strategy ) {
-
-  return gzsetparams(file, -2, comp_strategy);
-
-}
-
-
-streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {
-
-  return streampos(EOF);
-
-}
-
-int gzfilebuf::underflow() {
-
-  // If the file hasn't been opened for reading, error.
-  if ( !is_open() || !(mode & ios::in) )
-    return EOF;
-
-  // if a buffer doesn't exists, allocate one.
-  if ( !base() ) {
-
-    if ( (allocate()) == EOF )
-      return EOF;
-    setp(0,0);
-
-  } else {
-
-    if ( in_avail() )
-      return (unsigned char) *gptr();
-
-    if ( out_waiting() ) {
-      if ( flushbuf() == EOF )
-        return EOF;
-    }
-
-  }
-
-  // Attempt to fill the buffer.
-
-  int result = fillbuf();
-  if ( result == EOF ) {
-    // disable get area
-    setg(0,0,0);
-    return EOF;
-  }
-
-  return (unsigned char) *gptr();
-
-}
-
-int gzfilebuf::overflow( int c ) {
-
-  if ( !is_open() || !(mode & ios::out) )
-    return EOF;
-
-  if ( !base() ) {
-    if ( allocate() == EOF )
-      return EOF;
-    setg(0,0,0);
-  } else {
-    if (in_avail()) {
-        return EOF;
-    }
-    if (out_waiting()) {
-      if (flushbuf() == EOF)
-        return EOF;
-    }
-  }
-
-  int bl = blen();
-  setp( base(), base() + bl);
-
-  if ( c != EOF ) {
-
-    *pptr() = c;
-    pbump(1);
-
-  }
-
-  return 0;
-
-}
-
-int gzfilebuf::sync() {
-
-  if ( !is_open() )
-    return EOF;
-
-  if ( out_waiting() )
-    return flushbuf();
-
-  return 0;
-
-}
-
-int gzfilebuf::flushbuf() {
-
-  int n;
-  char *q;
-
-  q = pbase();
-  n = pptr() - q;
-
-  if ( gzwrite( file, q, n) < n )
-    return EOF;
-
-  setp(0,0);
-
-  return 0;
-
-}
-
-int gzfilebuf::fillbuf() {
-
-  int required;
-  char *p;
-
-  p = base();
-
-  required = blen();
-
-  int t = gzread( file, p, required );
-
-  if ( t <= 0) return EOF;
-
-  setg( base(), base(), base()+t);
-
-  return t;
-
-}
-
-gzfilestream_common::gzfilestream_common() :
-  ios( gzfilestream_common::rdbuf() )
-{ }
-
-gzfilestream_common::~gzfilestream_common()
-{ }
-
-void gzfilestream_common::attach( int fd, int io_mode ) {
-
-  if ( !buffer.attach( fd, io_mode) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::open( const char *name, int io_mode ) {
-
-  if ( !buffer.open( name, io_mode ) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::close() {
-
-  if ( !buffer.close() )
-    clear( ios::failbit | ios::badbit );
-
-}
-
-gzfilebuf *gzfilestream_common::rdbuf()
-{
-  return &buffer;
-}
-
-gzifstream::gzifstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzifstream::gzifstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzifstream::gzifstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzifstream::~gzifstream() { }
-
-gzofstream::gzofstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzofstream::gzofstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzofstream::gzofstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzofstream::~gzofstream() { }
diff --git a/contrib/zlib/contrib/iostream/zfstream.h b/contrib/zlib/contrib/iostream/zfstream.h
deleted file mode 100644
index ed79098a3..000000000
--- a/contrib/zlib/contrib/iostream/zfstream.h
+++ /dev/null
@@ -1,128 +0,0 @@
-
-#ifndef zfstream_h
-#define zfstream_h
-
-#include <fstream.h>
-#include "zlib.h"
-
-class gzfilebuf : public streambuf {
-
-public:
-
-  gzfilebuf( );
-  virtual ~gzfilebuf();
-
-  gzfilebuf *open( const char *name, int io_mode );
-  gzfilebuf *attach( int file_descriptor, int io_mode );
-  gzfilebuf *close();
-
-  int setcompressionlevel( int comp_level );
-  int setcompressionstrategy( int comp_strategy );
-
-  inline int is_open() const { return (file !=NULL); }
-
-  virtual streampos seekoff( streamoff, ios::seek_dir, int );
-
-  virtual int sync();
-
-protected:
-
-  virtual int underflow();
-  virtual int overflow( int = EOF );
-
-private:
-
-  gzFile file;
-  short mode;
-  short own_file_descriptor;
-
-  int flushbuf();
-  int fillbuf();
-
-};
-
-class gzfilestream_common : virtual public ios {
-
-  friend class gzifstream;
-  friend class gzofstream;
-  friend gzofstream &setcompressionlevel( gzofstream &, int );
-  friend gzofstream &setcompressionstrategy( gzofstream &, int );
-
-public:
-  virtual ~gzfilestream_common();
-
-  void attach( int fd, int io_mode );
-  void open( const char *name, int io_mode );
-  void close();
-
-protected:
-  gzfilestream_common();
-
-private:
-  gzfilebuf *rdbuf();
-
-  gzfilebuf buffer;
-
-};
-
-class gzifstream : public gzfilestream_common, public istream {
-
-public:
-
-  gzifstream();
-  gzifstream( const char *name, int io_mode = ios::in );
-  gzifstream( int fd, int io_mode = ios::in );
-
-  virtual ~gzifstream();
-
-};
-
-class gzofstream : public gzfilestream_common, public ostream {
-
-public:
-
-  gzofstream();
-  gzofstream( const char *name, int io_mode = ios::out );
-  gzofstream( int fd, int io_mode = ios::out );
-
-  virtual ~gzofstream();
-
-};
-
-template<class T> class gzomanip {
-  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);
-public:
-  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }
-private:
-  gzofstream &(*func)(gzofstream &, T);
-  T val;
-};
-
-template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)
-{
-  return (*m.func)(s, m.val);
-}
-
-inline gzofstream &setcompressionlevel( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionlevel(l);
-  return s;
-}
-
-inline gzofstream &setcompressionstrategy( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionstrategy(l);
-  return s;
-}
-
-inline gzomanip<int> setcompressionlevel(int l)
-{
-  return gzomanip<int>(&setcompressionlevel,l);
-}
-
-inline gzomanip<int> setcompressionstrategy(int l)
-{
-  return gzomanip<int>(&setcompressionstrategy,l);
-}
-
-#endif
diff --git a/contrib/zlib/contrib/iostream2/zstream.h b/contrib/zlib/contrib/iostream2/zstream.h
deleted file mode 100644
index 43d2332b7..000000000
--- a/contrib/zlib/contrib/iostream2/zstream.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- *
- * Copyright (c) 1997
- * Christian Michelsen Research AS
- * Advanced Computing
- * Fantoftvegen 38, 5036 BERGEN, Norway
- * http://www.cmr.no
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Christian Michelsen Research AS makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef ZSTREAM__H
-#define ZSTREAM__H
-
-/*
- * zstream.h - C++ interface to the 'zlib' general purpose compression library
- * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $
- */
-
-#include <strstream.h>
-#include <string.h>
-#include <stdio.h>
-#include "zlib.h"
-
-#if defined(_WIN32)
-#   include <fcntl.h>
-#   include <io.h>
-#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#   define SET_BINARY_MODE(file)
-#endif
-
-class zstringlen {
-public:
-    zstringlen(class izstream&);
-    zstringlen(class ozstream&, const char*);
-    size_t value() const { return val.word; }
-private:
-    struct Val { unsigned char byte; size_t word; } val;
-};
-
-//  ----------------------------- izstream -----------------------------
-
-class izstream
-{
-    public:
-        izstream() : m_fp(0) {}
-        izstream(FILE* fp) : m_fp(0) { open(fp); }
-        izstream(const char* name) : m_fp(0) { open(name); }
-        ~izstream() { close(); }
-
-        /* Opens a gzip (.gz) file for reading.
-         * open() can be used to read a file which is not in gzip format;
-         * in this case read() will directly read from the file without
-         * decompression. errno can be checked to distinguish two error
-         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name) {
-            if (m_fp) close();
-            m_fp = ::gzopen(name, "rb");
-        }
-
-        void open(FILE* fp) {
-            SET_BINARY_MODE(fp);
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), "rb");
-        }
-
-        /* Flushes all pending input if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            int r = ::gzclose(m_fp);
-            m_fp = 0; return r;
-        }
-
-        /* Binary read the given number of bytes from the compressed file.
-         */
-        int read(void* buf, size_t len) {
-            return ::gzread(m_fp, buf, len);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-    private:
-        gzFile m_fp;
-};
-
-/*
- * Binary read the given (array of) object(s) from the compressed file.
- * If the input file was not in gzip format, read() copies the objects number
- * of bytes into the buffer.
- * returns the number of uncompressed bytes actually read
- * (0 for end of file, -1 for error).
- */
-template <class T, class Items>
-inline int read(izstream& zs, T* x, Items items) {
-    return ::gzread(zs.fp(), x, items*sizeof(T));
-}
-
-/*
- * Binary input with the '>' operator.
- */
-template <class T>
-inline izstream& operator>(izstream& zs, T& x) {
-    ::gzread(zs.fp(), &x, sizeof(T));
-    return zs;
-}
-
-
-inline zstringlen::zstringlen(izstream& zs) {
-    zs > val.byte;
-    if (val.byte == 255) zs > val.word;
-    else val.word = val.byte;
-}
-
-/*
- * Read length of string + the string with the '>' operator.
- */
-inline izstream& operator>(izstream& zs, char* x) {
-    zstringlen len(zs);
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return zs;
-}
-
-inline char* read_string(izstream& zs) {
-    zstringlen len(zs);
-    char* x = new char[len.value()+1];
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return x;
-}
-
-// ----------------------------- ozstream -----------------------------
-
-class ozstream
-{
-    public:
-        ozstream() : m_fp(0), m_os(0) {
-        }
-        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(fp, level);
-        }
-        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(name, level);
-        }
-        ~ozstream() {
-            close();
-        }
-
-        /* Opens a gzip (.gz) file for writing.
-         * The compression level parameter should be in 0..9
-         * errno can be checked to distinguish two error cases
-         * (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzopen(name, mode);
-        }
-
-        /* open from a FILE pointer.
-         */
-        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {
-            SET_BINARY_MODE(fp);
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), mode);
-        }
-
-        /* Flushes all pending output if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            if (m_os) {
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = 0;
-            }
-            int r = ::gzclose(m_fp); m_fp = 0; return r;
-        }
-
-        /* Binary write the given number of bytes into the compressed file.
-         */
-        int write(const void* buf, size_t len) {
-            return ::gzwrite(m_fp, (voidp) buf, len);
-        }
-
-        /* Flushes all pending output into the compressed file. The parameter
-         * _flush is as in the deflate() function. The return value is the zlib
-         * error number (see function gzerror below). flush() returns Z_OK if
-         * the flush_ parameter is Z_FINISH and all output could be flushed.
-         * flush() should be called only when strictly necessary because it can
-         * degrade compression.
-         */
-        int flush(int _flush) {
-            os_flush();
-            return ::gzflush(m_fp, _flush);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-        ostream& os() {
-            if (m_os == 0) m_os = new ostrstream;
-            return *m_os;
-        }
-
-        void os_flush() {
-            if (m_os && m_os->pcount()>0) {
-                ostrstream* oss = new ostrstream;
-                oss->fill(m_os->fill());
-                oss->flags(m_os->flags());
-                oss->precision(m_os->precision());
-                oss->width(m_os->width());
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = oss;
-            }
-        }
-
-    private:
-        gzFile m_fp;
-        ostrstream* m_os;
-};
-
-/*
- * Binary write the given (array of) object(s) into the compressed file.
- * returns the number of uncompressed bytes actually written
- * (0 in case of error).
- */
-template <class T, class Items>
-inline int write(ozstream& zs, const T* x, Items items) {
-    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));
-}
-
-/*
- * Binary output with the '<' operator.
- */
-template <class T>
-inline ozstream& operator<(ozstream& zs, const T& x) {
-    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));
-    return zs;
-}
-
-inline zstringlen::zstringlen(ozstream& zs, const char* x) {
-    val.byte = 255;  val.word = ::strlen(x);
-    if (val.word < 255) zs < (val.byte = val.word);
-    else zs < val;
-}
-
-/*
- * Write length of string + the string with the '<' operator.
- */
-inline ozstream& operator<(ozstream& zs, const char* x) {
-    zstringlen len(zs, x);
-    ::gzwrite(zs.fp(), (voidp) x, len.value());
-    return zs;
-}
-
-#ifdef _MSC_VER
-inline ozstream& operator<(ozstream& zs, char* const& x) {
-    return zs < (const char*) x;
-}
-#endif
-
-/*
- * Ascii write with the << operator;
- */
-template <class T>
-inline ostream& operator<<(ozstream& zs, const T& x) {
-    zs.os_flush();
-    return zs.os() << x;
-}
-
-#endif
diff --git a/contrib/zlib/contrib/iostream2/zstream_test.cpp b/contrib/zlib/contrib/iostream2/zstream_test.cpp
deleted file mode 100644
index 6273f62d6..000000000
--- a/contrib/zlib/contrib/iostream2/zstream_test.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-#include "zstream.h"
-#include <math.h>
-#include <stdlib.h>
-#include <iomanip.h>
-
-void main() {
-    char h[256] = "Hello";
-    char* g = "Goodbye";
-    ozstream out("temp.gz");
-    out < "This works well" < h < g;
-    out.close();
-
-    izstream in("temp.gz"); // read it back
-    char *x = read_string(in), *y = new char[256], z[256];
-    in > y > z;
-    in.close();
-    cout << x << endl << y << endl << z << endl;
-
-    out.open("temp.gz"); // try ascii output; zcat temp.gz to see the results
-    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;
-    out << z << endl << y << endl << x << endl;
-    out << 1.1234567890123456789 << endl;
-
-    delete[] x; delete[] y;
-}
diff --git a/contrib/zlib/contrib/iostream3/README b/contrib/zlib/contrib/iostream3/README
deleted file mode 100644
index f7b319ab9..000000000
--- a/contrib/zlib/contrib/iostream3/README
+++ /dev/null
@@ -1,35 +0,0 @@
-These classes provide a C++ stream interface to the zlib library. It allows you
-to do things like:
-
-  gzofstream outf("blah.gz");
-  outf << "These go into the gzip file " << 123 << endl;
-
-It does this by deriving a specialized stream buffer for gzipped files, which is
-the way Stroustrup would have done it. :->
-
-The gzifstream and gzofstream classes were originally written by Kevin Ruland
-and made available in the zlib contrib/iostream directory. The older version still
-compiles under gcc 2.xx, but not under gcc 3.xx, which sparked the development of
-this version.
-
-The new classes are as standard-compliant as possible, closely following the
-approach of the standard library's fstream classes. It compiles under gcc versions
-3.2 and 3.3, but not under gcc 2.xx. This is mainly due to changes in the standard
-library naming scheme. The new version of gzifstream/gzofstream/gzfilebuf differs
-from the previous one in the following respects:
-- added showmanyc
-- added setbuf, with support for unbuffered output via setbuf(0,0)
-- a few bug fixes of stream behavior
-- gzipped output file opened with default compression level instead of maximum level
-- setcompressionlevel()/strategy() members replaced by single setcompression()
-
-The code is provided "as is", with the permission to use, copy, modify, distribute
-and sell it for any purpose without fee.
-
-Ludwig Schwardt
-<schwardt@sun.ac.za>
-
-DSP Lab
-Electrical & Electronic Engineering Department
-University of Stellenbosch
-South Africa
diff --git a/contrib/zlib/contrib/iostream3/TODO b/contrib/zlib/contrib/iostream3/TODO
deleted file mode 100644
index 7032f97be..000000000
--- a/contrib/zlib/contrib/iostream3/TODO
+++ /dev/null
@@ -1,17 +0,0 @@
-Possible upgrades to gzfilebuf:
-
-- The ability to do putback (e.g. putbackfail)
-
-- The ability to seek (zlib supports this, but could be slow/tricky)
-
-- Simultaneous read/write access (does it make sense?)
-
-- Support for ios_base::ate open mode
-
-- Locale support?
-
-- Check public interface to see which calls give problems
-  (due to dependence on library internals)
-
-- Override operator<<(ostream&, gzfilebuf*) to allow direct copying
-  of stream buffer to stream ( i.e. os << is.rdbuf(); )
diff --git a/contrib/zlib/contrib/iostream3/test.cc b/contrib/zlib/contrib/iostream3/test.cc
deleted file mode 100644
index 94235334f..000000000
--- a/contrib/zlib/contrib/iostream3/test.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Test program for gzifstream and gzofstream
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- */
-
-#include "zfstream.h"
-#include <iostream>      // for cout
-
-int main() {
-
-  gzofstream outf;
-  gzifstream inf;
-  char buf[80];
-
-  outf.open("test1.txt.gz");
-  outf << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\n"
-            << "The quick brown fox sidestepped the lazy canine\n"
-            << 1.3 << "\nPlan " << 9 << std::endl;
-
-  std::cout << "\nReading 'test1.txt.gz' (buffered) produces:\n";
-  inf.open("test1.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  outf.rdbuf()->pubsetbuf(0,0);
-  outf.open("test2.txt.gz");
-  outf << setcompression(Z_NO_COMPRESSION)
-       << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "\nWrote the same message to 'test2.txt.gz' in uncompressed form";
-
-  std::cout << "\nReading 'test2.txt.gz' (unbuffered) produces:\n";
-  inf.rdbuf()->pubsetbuf(0,0);
-  inf.open("test2.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  return 0;
-
-}
diff --git a/contrib/zlib/contrib/iostream3/zfstream.cc b/contrib/zlib/contrib/iostream3/zfstream.cc
deleted file mode 100644
index 94eb93344..000000000
--- a/contrib/zlib/contrib/iostream3/zfstream.cc
+++ /dev/null
@@ -1,479 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#include "zfstream.h"
-#include <cstring>          // for strcpy, strcat, strlen (mode strings)
-#include <cstdio>           // for BUFSIZ
-
-// Internal buffer sizes (default and "unbuffered" versions)
-#define BIGBUFSIZE BUFSIZ
-#define SMALLBUFSIZE 1
-
-/*****************************************************************************/
-
-// Default constructor
-gzfilebuf::gzfilebuf()
-: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),
-  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)
-{
-  // No buffers to start with
-  this->disable_buffer();
-}
-
-// Destructor
-gzfilebuf::~gzfilebuf()
-{
-  // Sync output buffer and close only if responsible for file
-  // (i.e. attached streams should be left open at this stage)
-  this->sync();
-  if (own_fd)
-    this->close();
-  // Make sure internal buffer is deallocated
-  this->disable_buffer();
-}
-
-// Set compression level and strategy
-int
-gzfilebuf::setcompression(int comp_level,
-                          int comp_strategy)
-{
-  return gzsetparams(file, comp_level, comp_strategy);
-}
-
-// Open gzipped file
-gzfilebuf*
-gzfilebuf::open(const char *name,
-                std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = true;
-  return this;
-}
-
-// Attach to gzipped file
-gzfilebuf*
-gzfilebuf::attach(int fd,
-                  std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzdopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = false;
-  return this;
-}
-
-// Close gzipped file
-gzfilebuf*
-gzfilebuf::close()
-{
-  // Fail immediately if no file is open
-  if (!this->is_open())
-    return NULL;
-  // Assume success
-  gzfilebuf* retval = this;
-  // Attempt to sync and close gzipped file
-  if (this->sync() == -1)
-    retval = NULL;
-  if (gzclose(file) < 0)
-    retval = NULL;
-  // File is now gone anyway (postcondition [27.8.1.3.8])
-  file = NULL;
-  own_fd = false;
-  // Destroy internal buffer if it exists
-  this->disable_buffer();
-  return retval;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Convert int open mode to mode string
-bool
-gzfilebuf::open_mode(std::ios_base::openmode mode,
-                     char* c_mode) const
-{
-  bool testb = mode & std::ios_base::binary;
-  bool testi = mode & std::ios_base::in;
-  bool testo = mode & std::ios_base::out;
-  bool testt = mode & std::ios_base::trunc;
-  bool testa = mode & std::ios_base::app;
-
-  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
-  // Original zfstream hardcoded the compression level to maximum here...
-  // Double the time for less than 1% size improvement seems
-  // excessive though - keeping it at the default level
-  // To change back, just append "9" to the next three mode strings
-  if (!testi && testo && !testt && !testa)
-    strcpy(c_mode, "w");
-  if (!testi && testo && !testt && testa)
-    strcpy(c_mode, "a");
-  if (!testi && testo && testt && !testa)
-    strcpy(c_mode, "w");
-  if (testi && !testo && !testt && !testa)
-    strcpy(c_mode, "r");
-  // No read/write mode yet
-//  if (testi && testo && !testt && !testa)
-//    strcpy(c_mode, "r+");
-//  if (testi && testo && testt && !testa)
-//    strcpy(c_mode, "w+");
-
-  // Mode string should be empty for invalid combination of flags
-  if (strlen(c_mode) == 0)
-    return false;
-  if (testb)
-    strcat(c_mode, "b");
-  return true;
-}
-
-// Determine number of characters in internal get buffer
-std::streamsize
-gzfilebuf::showmanyc()
-{
-  // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return -1;
-  // Make sure get area is in use
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return std::streamsize(this->egptr() - this->gptr());
-  else
-    return 0;
-}
-
-// Fill get area from gzipped file
-gzfilebuf::int_type
-gzfilebuf::underflow()
-{
-  // If something is left in the get area by chance, return it
-  // (this shouldn't normally happen, as underflow is only supposed
-  // to be called when gptr >= egptr, but it serves as error check)
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return traits_type::to_int_type(*(this->gptr()));
-
-  // If the file hasn't been opened for reading, produce error
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return traits_type::eof();
-
-  // Attempt to fill internal buffer from gzipped file
-  // (buffer must be guaranteed to exist...)
-  int bytes_read = gzread(file, buffer, buffer_size);
-  // Indicates error or EOF
-  if (bytes_read <= 0)
-  {
-    // Reset get area
-    this->setg(buffer, buffer, buffer);
-    return traits_type::eof();
-  }
-  // Make all bytes read from file available as get area
-  this->setg(buffer, buffer, buffer + bytes_read);
-
-  // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr()));
-}
-
-// Write put area to gzipped file
-gzfilebuf::int_type
-gzfilebuf::overflow(int_type c)
-{
-  // Determine whether put area is in use
-  if (this->pbase())
-  {
-    // Double-check pointer range
-    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())
-      return traits_type::eof();
-    // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
-    {
-      *(this->pptr()) = traits_type::to_char_type(c);
-      this->pbump(1);
-    }
-    // Number of characters to write to file
-    int bytes_to_write = this->pptr() - this->pbase();
-    // Overflow doesn't fail if nothing is to be written
-    if (bytes_to_write > 0)
-    {
-      // If the file hasn't been opened for writing, produce error
-      if (!this->is_open() || !(io_mode & std::ios_base::out))
-        return traits_type::eof();
-      // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)
-        return traits_type::eof();
-      // Reset next pointer to point to pbase on success
-      this->pbump(-bytes_to_write);
-    }
-  }
-  // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof()))
-  {
-    // If the file hasn't been opened for writing, produce error
-    if (!this->is_open() || !(io_mode & std::ios_base::out))
-      return traits_type::eof();
-    // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type(c);
-    // If gzipped file won't accept this character, fail
-    if (gzwrite(file, &last_char, 1) != 1)
-      return traits_type::eof();
-  }
-
-  // If you got here, you have succeeded (even if c was EOF)
-  // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof()))
-    return traits_type::not_eof(c);
-  else
-    return c;
-}
-
-// Assign new buffer
-std::streambuf*
-gzfilebuf::setbuf(char_type* p,
-                  std::streamsize n)
-{
-  // First make sure stuff is sync'ed, for safety
-  if (this->sync() == -1)
-    return NULL;
-  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
-  // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
-  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
-  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
-  if (!p || !n)
-  {
-    // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer();
-    buffer = NULL;
-    buffer_size = 0;
-    own_buffer = true;
-    this->enable_buffer();
-  }
-  else
-  {
-    // Replace existing buffer (if any) with external buffer
-    this->disable_buffer();
-    buffer = p;
-    buffer_size = n;
-    own_buffer = false;
-    this->enable_buffer();
-  }
-  return this;
-}
-
-// Write put area to gzipped file (i.e. ensures that put area is empty)
-int
-gzfilebuf::sync()
-{
-  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Allocate internal buffer
-void
-gzfilebuf::enable_buffer()
-{
-  // If internal buffer required, allocate one
-  if (own_buffer && !buffer)
-  {
-    // Check for buffered vs. "unbuffered"
-    if (buffer_size > 0)
-    {
-      // Allocate internal buffer
-      buffer = new char_type[buffer_size];
-      // Get area starts empty and will be expanded by underflow as need arises
-      this->setg(buffer, buffer, buffer);
-      // Setup entire internal buffer as put area.
-      // The one-past-end pointer actually points to the last element of the buffer,
-      // so that overflow(c) can safely add the extra character c to the sequence.
-      // These pointers remain in place for the duration of the buffer
-      this->setp(buffer, buffer + buffer_size - 1);
-    }
-    else
-    {
-      // Even in "unbuffered" case, (small?) get buffer is still required
-      buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
-      this->setg(buffer, buffer, buffer);
-      // "Unbuffered" means no put buffer
-      this->setp(0, 0);
-    }
-  }
-  else
-  {
-    // If buffer already allocated, reset buffer pointers just to make sure no
-    // stale chars are lying around
-    this->setg(buffer, buffer, buffer);
-    this->setp(buffer, buffer + buffer_size - 1);
-  }
-}
-
-// Destroy internal buffer
-void
-gzfilebuf::disable_buffer()
-{
-  // If internal buffer exists, deallocate it
-  if (own_buffer && buffer)
-  {
-    // Preserve unbuffered status by zeroing size
-    if (!this->pbase())
-      buffer_size = 0;
-    delete[] buffer;
-    buffer = NULL;
-    this->setg(0, 0, 0);
-    this->setp(0, 0);
-  }
-  else
-  {
-    // Reset buffer pointers to initial state if external buffer exists
-    this->setg(buffer, buffer, buffer);
-    if (buffer)
-      this->setp(buffer, buffer + buffer_size - 1);
-    else
-      this->setp(0, 0);
-  }
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzifstream::gzifstream()
-: std::istream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzifstream::gzifstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzifstream::gzifstream(int fd,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzifstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzifstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzifstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzofstream::gzofstream()
-: std::ostream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzofstream::gzofstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzofstream::gzofstream(int fd,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzofstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzofstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzofstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
diff --git a/contrib/zlib/contrib/iostream3/zfstream.h b/contrib/zlib/contrib/iostream3/zfstream.h
deleted file mode 100644
index 8574479ae..000000000
--- a/contrib/zlib/contrib/iostream3/zfstream.h
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#ifndef ZFSTREAM_H
-#define ZFSTREAM_H
-
-#include <istream>  // not iostream, since we don't need cin/cout
-#include <ostream>
-#include "zlib.h"
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file stream buffer class.
- *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet support
- *  seeking (allowed by zlib but slow/limited), putback and read/write access
- *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
- *  file streambuf.
-*/
-class gzfilebuf : public std::streambuf
-{
-public:
-  //  Default constructor.
-  gzfilebuf();
-
-  //  Destructor.
-  virtual
-  ~gzfilebuf();
-
-  /**
-   *  @brief  Set compression level and strategy on the fly.
-   *  @param  comp_level  Compression level (see zlib.h for allowed values)
-   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
-   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
-   *
-   *  Unfortunately, these parameters cannot be modified separately, as the
-   *  previous zfstream version assumed. Since the strategy is seldom changed,
-   *  it can default and setcompression(level) then becomes like the old
-   *  setcompressionlevel(level).
-  */
-  int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() const { return (file != NULL); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Close gzipped file.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  close();
-
-protected:
-  /**
-   *  @brief  Convert ios open mode int to mode string used by zlib.
-   *  @return  True if valid mode flag combination.
-  */
-  bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
-
-  /**
-   *  @brief  Number of characters available in stream buffer.
-   *  @return  Number of characters.
-   *
-   *  This indicates number of characters in get area of stream buffer.
-   *  These characters can be read without accessing the gzipped file.
-  */
-  virtual std::streamsize
-  showmanyc();
-
-  /**
-   *  @brief  Fill get area from gzipped file.
-   *  @return  First character in get area on success, EOF on error.
-   *
-   *  This actually reads characters from gzipped file to stream
-   *  buffer. Always buffered.
-  */
-  virtual int_type
-  underflow();
-
-  /**
-   *  @brief  Write put area to gzipped file.
-   *  @param  c  Extra character to add to buffer contents.
-   *  @return  Non-EOF on success, EOF on error.
-   *
-   *  This actually writes characters in stream buffer to
-   *  gzipped file. With unbuffered output this is done one
-   *  character at a time.
-  */
-  virtual int_type
-  overflow(int_type c = traits_type::eof());
-
-  /**
-   *  @brief  Installs external stream buffer.
-   *  @param  p  Pointer to char buffer.
-   *  @param  n  Size of external buffer.
-   *  @return  @c this on success, NULL on failure.
-   *
-   *  Call setbuf(0,0) to enable unbuffered output.
-  */
-  virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
-
-  /**
-   *  @brief  Flush stream buffer to file.
-   *  @return  0 on success, -1 on error.
-   *
-   *  This calls underflow(EOF) to do the job.
-  */
-  virtual int
-  sync();
-
-//
-// Some future enhancements
-//
-//  virtual int_type uflow();
-//  virtual int_type pbackfail(int_type c = traits_type::eof());
-//  virtual pos_type
-//  seekoff(off_type off,
-//          std::ios_base::seekdir way,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-//  virtual pos_type
-//  seekpos(pos_type sp,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-
-private:
-  /**
-   *  @brief  Allocate internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that a proper internal buffer exists if it is required. If the
-   *  buffer already exists or is external, the buffer pointers will be
-   *  reset to their original state.
-  */
-  void
-  enable_buffer();
-
-  /**
-   *  @brief  Destroy internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that the internal buffer is deallocated if it exists. In any
-   *  case, it will also reset the buffer pointers.
-  */
-  void
-  disable_buffer();
-
-  /**
-   *  Underlying file pointer.
-  */
-  gzFile file;
-
-  /**
-   *  Mode in which file was opened.
-  */
-  std::ios_base::openmode io_mode;
-
-  /**
-   *  @brief  True if this object owns file descriptor.
-   *
-   *  This makes the class responsible for closing the file
-   *  upon destruction.
-  */
-  bool own_fd;
-
-  /**
-   *  @brief  Stream buffer.
-   *
-   *  For simplicity this remains allocated on the free store for the
-   *  entire life span of the gzfilebuf object, unless replaced by setbuf.
-  */
-  char_type* buffer;
-
-  /**
-   *  @brief  Stream buffer size.
-   *
-   *  Defaults to system default buffer size (typically 8192 bytes).
-   *  Modified by setbuf.
-  */
-  std::streamsize buffer_size;
-
-  /**
-   *  @brief  True if this object owns stream buffer.
-   *
-   *  This makes the class responsible for deleting the buffer
-   *  upon destruction.
-  */
-  bool own_buffer;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file input stream class.
- *
- *  This class implements ifstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzifstream : public std::istream
-{
-public:
-  //  Default constructor
-  gzifstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ifstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream class.
- *
- *  This class implements ofstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzofstream : public std::ostream
-{
-public:
-  //  Default constructor
-  gzofstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ofstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream manipulator class.
- *
- *  This class defines a two-argument manipulator for gzofstream. It is used
- *  as base for the setcompression(int,int) manipulator.
-*/
-template<typename T1, typename T2>
-  class gzomanip2
-  {
-  public:
-    // Allows insertor to peek at internals
-    template <typename Ta, typename Tb>
-      friend gzofstream&
-      operator<<(gzofstream&,
-                 const gzomanip2<Ta,Tb>&);
-
-    // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
-  private:
-    // Underlying manipulator function
-    gzofstream&
-    (*func)(gzofstream&, T1, T2);
-
-    // Arguments for manipulator function
-    T1 val1;
-    T2 val2;
-  };
-
-/*****************************************************************************/
-
-// Manipulator function thunks through to stream buffer
-inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
-{
-  (gzs.rdbuf())->setcompression(l, s);
-  return gzs;
-}
-
-// Manipulator constructor stores arguments
-template<typename T1, typename T2>
-  inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
-  : func(f), val1(v1), val2(v2)
-  { }
-
-// Insertor applies underlying manipulator function to stream
-template<typename T1, typename T2>
-  inline gzofstream&
-  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
-  { return (*m.func)(s, m.val1, m.val2); }
-
-// Insert this onto stream to simplify setting of compression level
-inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
-{ return gzomanip2<int,int>(&setcompression, l, s); }
-
-#endif // ZFSTREAM_H
diff --git a/contrib/zlib/contrib/masmx64/bld_ml64.bat b/contrib/zlib/contrib/masmx64/bld_ml64.bat
deleted file mode 100644
index f74bcef5b..000000000
--- a/contrib/zlib/contrib/masmx64/bld_ml64.bat
+++ /dev/null
@@ -1,2 +0,0 @@
-ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-ml64.exe /Flgvmat64   /c /Zi gvmat64.asm
diff --git a/contrib/zlib/contrib/masmx64/gvmat64.asm b/contrib/zlib/contrib/masmx64/gvmat64.asm
deleted file mode 100644
index c1817f1be..000000000
--- a/contrib/zlib/contrib/masmx64/gvmat64.asm
+++ /dev/null
@@ -1,553 +0,0 @@
-;uInt longest_match_x64(
-;    deflate_state *s,
-;    IPos cur_match);                             /* current match */
-
-; gvmat64.asm -- Asm portion of the optimized longest_match for 32 bits x86_64
-;  (AMD64 on Athlon 64, Opteron, Phenom
-;     and Intel EM64T on Pentium 4 with EM64T, Pentium D, Core 2 Duo, Core I5/I7)
-; Copyright (C) 1995-2010 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-;
-; File written by Gilles Vollant, by converting to assembly the longest_match
-;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.
-;
-;  and by taking inspiration on asm686 with masm, optimised assembly code
-;        from Brian Raiter, written 1998
-;
-;  This software is provided 'as-is', without any express or implied
-;  warranty.  In no event will the authors be held liable for any damages
-;  arising from the use of this software.
-;
-;  Permission is granted to anyone to use this software for any purpose,
-;  including commercial applications, and to alter it and redistribute it
-;  freely, subject to the following restrictions:
-;
-;  1. The origin of this software must not be misrepresented; you must not
-;     claim that you wrote the original software. If you use this software
-;     in a product, an acknowledgment in the product documentation would be
-;     appreciated but is not required.
-;  2. Altered source versions must be plainly marked as such, and must not be
-;     misrepresented as being the original software
-;  3. This notice may not be removed or altered from any source distribution.
-;
-;
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; to compile this file for infozip Zip, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi /DINFOZIP gvmat64.asm
-;
-; to compile this file for zLib, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi gvmat64.asm
-; Be carrefull to adapt zlib1222add below to your version of zLib
-;   (if you use a version of zLib before 1.0.4 or after 1.2.2.2, change
-;    value of zlib1222add later)
-;
-; This file compile with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005/2008/2010 and Windows WDK
-;
-;   (you can get Windows WDK with ml64 for AMD64 from
-;      http://www.microsoft.com/whdc/Devtools/wdk/default.mspx for low price)
-;
-
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-.code
-longest_match PROC
-
-
-;LocalVarsSize   equ 88
- LocalVarsSize   equ 72
-
-; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12
-; free register :  r14,r15
-; register can be saved : rsp
-
- chainlenwmask   equ  rsp + 8 - LocalVarsSize    ; high word: current chain len
-                                                 ; low word: s->wmask
-;window          equ  rsp + xx - LocalVarsSize   ; local copy of s->window ; stored in r10
-;windowbestlen   equ  rsp + xx - LocalVarsSize   ; s->window + bestlen , use r10+r11
-;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w
-;scanend         equ  rsp + xx - LocalVarsSize   ; last two bytes of string use ebx
-;scanalign       equ  rsp + xx - LocalVarsSize   ; dword-misalignment of string r13
-;bestlen         equ  rsp + xx - LocalVarsSize   ; size of best match so far -> r11d
-;scan            equ  rsp + xx - LocalVarsSize   ; ptr to string wanting match -> r9
-IFDEF INFOZIP
-ELSE
- nicematch       equ  (rsp + 16 - LocalVarsSize) ; a good enough match size
-ENDIF
-
-save_rdi        equ  rsp + 24 - LocalVarsSize
-save_rsi        equ  rsp + 32 - LocalVarsSize
-save_rbx        equ  rsp + 40 - LocalVarsSize
-save_rbp        equ  rsp + 48 - LocalVarsSize
-save_r12        equ  rsp + 56 - LocalVarsSize
-save_r13        equ  rsp + 64 - LocalVarsSize
-;save_r14        equ  rsp + 72 - LocalVarsSize
-;save_r15        equ  rsp + 80 - LocalVarsSize
-
-
-; summary of register usage
-; scanend     ebx
-; scanendw    bx
-; chainlenwmask   edx
-; curmatch    rsi
-; curmatchd   esi
-; windowbestlen   r8
-; scanalign   r9
-; scanalignd  r9d
-; window      r10
-; bestlen     r11
-; bestlend    r11d
-; scanstart   r12d
-; scanstartw  r12w
-; scan        r13
-; nicematch   r14d
-; limit       r15
-; limitd      r15d
-; prev        rcx
-
-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
-;  in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, remove the +4).
-;  Note : these value are good with a 8 bytes boundary pack structure
-
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-
-IFDEF INFOZIP
-
-_DATA   SEGMENT
-COMM    window_size:DWORD
-; WMask ; 7fff
-COMM    window:BYTE:010040H
-COMM    prev:WORD:08000H
-; MatchLen : unused
-; PrevMatch : unused
-COMM    strstart:DWORD
-COMM    match_start:DWORD
-; Lookahead : ignore
-COMM    prev_length:DWORD ; PrevLen
-COMM    max_chain_length:DWORD
-COMM    good_match:DWORD
-COMM    nice_match:DWORD
-prev_ad equ OFFSET prev
-window_ad equ OFFSET window
-nicematch equ nice_match
-_DATA ENDS
-WMask equ 07fffh
-
-ELSE
-
-  IFNDEF zlib1222add
-    zlib1222add equ 8
-  ENDIF
-dsWSize         equ 56+zlib1222add+(zlib1222add/2)
-dsWMask         equ 64+zlib1222add+(zlib1222add/2)
-dsWindow        equ 72+zlib1222add
-dsPrev          equ 88+zlib1222add
-dsMatchLen      equ 128+zlib1222add
-dsPrevMatch     equ 132+zlib1222add
-dsStrStart      equ 140+zlib1222add
-dsMatchStart    equ 144+zlib1222add
-dsLookahead     equ 148+zlib1222add
-dsPrevLen       equ 152+zlib1222add
-dsMaxChainLen   equ 156+zlib1222add
-dsGoodMatch     equ 172+zlib1222add
-dsNiceMatch     equ 176+zlib1222add
-
-window_size     equ [ rcx + dsWSize]
-WMask           equ [ rcx + dsWMask]
-window_ad       equ [ rcx + dsWindow]
-prev_ad         equ [ rcx + dsPrev]
-strstart        equ [ rcx + dsStrStart]
-match_start     equ [ rcx + dsMatchStart]
-Lookahead       equ [ rcx + dsLookahead] ; 0ffffffffh on infozip
-prev_length     equ [ rcx + dsPrevLen]
-max_chain_length equ [ rcx + dsMaxChainLen]
-good_match      equ [ rcx + dsGoodMatch]
-nice_match      equ [ rcx + dsNiceMatch]
-ENDIF
-
-; parameter 1 in r8(deflate state s), param 2 in rdx (cur match)
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.
-
-
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-
-;;; Retrieve the function arguments. r8d will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-; parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)
-
-; this clear high 32 bits of r8, which can be garbage in both r8 and rdx
-
-        mov [save_rdi],rdi
-        mov [save_rsi],rsi
-        mov [save_rbx],rbx
-        mov [save_rbp],rbp
-IFDEF INFOZIP
-        mov r8d,ecx
-ELSE
-        mov r8d,edx
-ENDIF
-        mov [save_r12],r12
-        mov [save_r13],r13
-;        mov [save_r14],r14
-;        mov [save_r15],r15
-
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov edi, prev_length
-        mov esi, good_match
-        mov eax, WMask
-        mov ebx, max_chain_length
-        cmp edi, esi
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-
-;;; on zlib only
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-IFDEF INFOZIP
-        mov [chainlenwmask], ebx
-; on infozip nice_match = [nice_match]
-ELSE
-        mov eax, nice_match
-        mov [chainlenwmask], ebx
-        mov r10d, Lookahead
-        cmp r10d, eax
-        cmovnl r10d, eax
-        mov [nicematch],r10d
-ENDIF
-
-;;; register Bytef *scan = s->window + s->strstart;
-        mov r10, window_ad
-        mov ebp, strstart
-        lea r13, [r10 + rbp]
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-         mov r9,r13
-         neg r13
-         and r13,3
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-IFDEF INFOZIP
-        mov eax,07efah ; MAX_DIST = (WSIZE-MIN_LOOKAHEAD) (0x8000-(3+8+1))
-ELSE
-        mov eax, window_size
-        sub eax, MIN_LOOKAHEAD
-ENDIF
-        xor edi,edi
-        sub ebp, eax
-
-        mov r11d, prev_length
-
-        cmovng ebp,edi
-
-;;; int best_len = s->prev_length;
-
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-       lea  rsi,[r10+r11]
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx r12d,word ptr [r9]
-        movzx ebx, word ptr [r9 + r11 - 1]
-
-        mov rdi, prev_ad
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop1:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry1:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop2:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry2:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop4:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry4:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-        jmp LookupLoopIsZero
-
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; r8d = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-LookupLoopIsZero:
-        cmp     r12w, word ptr [r10 + r8]
-        jnz LookupLoop1
-
-
-;;; Store the current value of chainlen.
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        lea rsi,[r8+r10]
-        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)
-        lea rsi, [rsi + r13 + 0108h] ;MAX_MATCH_8]
-        lea rdi, [r9 + r13 + 0108h] ;MAX_MATCH_8]
-
-        prefetcht1 [rsi+rdx]
-        prefetcht1 [rdi+rdx]
-
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust rdx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (rsi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-
-LoopCmps:
-        mov rax, [rsi + rdx]
-        xor rax, [rdi + rdx]
-        jnz LeaveLoopCmps
-
-        mov rax, [rsi + rdx + 8]
-        xor rax, [rdi + rdx + 8]
-        jnz LeaveLoopCmps8
-
-
-        mov rax, [rsi + rdx + 8+8]
-        xor rax, [rdi + rdx + 8+8]
-        jnz LeaveLoopCmps16
-
-        add rdx,8+8+8
-
-        jnz short LoopCmps
-        jmp short LenMaximum
-LeaveLoopCmps16: add rdx,8
-LeaveLoopCmps8: add rdx,8
-LeaveLoopCmps:
-
-        test    eax, 0000FFFFh
-        jnz LenLower
-
-        test eax,0ffffffffh
-
-        jnz LenLower32
-
-        add rdx,4
-        shr rax,32
-        or ax,ax
-        jnz LenLower
-
-LenLower32:
-        shr eax,16
-        add rdx,2
-LenLower:   sub al, 1
-        adc rdx, 0
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea rax, [rdi + rdx]
-        sub rax, r9
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-;///////////////////////////////////
-
-        cmp eax, r11d
-        jg  LongerMatch
-
-        lea rsi,[r10+r11]
-
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:
-        mov r11d, eax
-        mov match_start, r8d
-        cmp eax, [nicematch]
-        jge LeaveNow
-
-        lea rsi,[r10+rax]
-
-        movzx   ebx, word ptr [r9 + rax - 1]
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum:
-        mov r11d,MAX_MATCH
-        mov match_start, r8d
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-IFDEF INFOZIP
-        mov eax,r11d
-ELSE
-        mov eax, Lookahead
-        cmp r11d, eax
-        cmovng eax, r11d
-ENDIF
-
-;;; Restore the stack and return from whence we came.
-
-
-        mov rsi,[save_rsi]
-        mov rdi,[save_rdi]
-        mov rbx,[save_rbx]
-        mov rbp,[save_rbp]
-        mov r12,[save_r12]
-        mov r13,[save_r13]
-;        mov r14,[save_r14]
-;        mov r15,[save_r15]
-
-
-        ret 0
-; please don't remove this string !
-; Your can freely use gvmat64 in any free or commercial app
-; but it is far better don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0
-longest_match   ENDP
-
-match_init PROC
-  ret 0
-match_init ENDP
-
-
-END
diff --git a/contrib/zlib/contrib/masmx64/inffas8664.c b/contrib/zlib/contrib/masmx64/inffas8664.c
deleted file mode 100644
index aa861a333..000000000
--- a/contrib/zlib/contrib/masmx64/inffas8664.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding
- * version for AMD64 on Windows using Microsoft C compiler
- *
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant
- *
- * inffas8664.c call function inffas8664fnc in inffasx64.asm
- *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- *
- */
-
-#include <stdio.h>
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-
-
-
-    typedef struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ size_t /*unsigned long */hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } type_ar;
-#ifdef ASMINF
-
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    type_ar ar;
-    void inffas8664fnc(struct inffast_ar * par);
-
-
-
-#if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->wnext;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-    inffas8664fnc(&ar);
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = (unsigned long)ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
-#endif
diff --git a/contrib/zlib/contrib/masmx64/inffasx64.asm b/contrib/zlib/contrib/masmx64/inffasx64.asm
deleted file mode 100644
index 41ec82392..000000000
--- a/contrib/zlib/contrib/masmx64/inffasx64.asm
+++ /dev/null
@@ -1,396 +0,0 @@
-; inffasx64.asm is a hand tuned assembler version of inffast.c - fast decoding
-; version for AMD64 on Windows using Microsoft C compiler
-;
-; inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
-; inffasx64.asm is called by inffas8664.c, which contain more info.
-
-
-; to compile this file, I use option
-;   ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-;   with Microsoft Macro Assembler (x64) for AMD64
-;
-
-; This file compile with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005/2008/2010 and Windows WDK
-;
-;   (you can get Windows WDK with ml64 for AMD64 from
-;      http://www.microsoft.com/whdc/Devtools/wdk/default.mspx for low price)
-;
-
-
-.code
-inffas8664fnc PROC
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r-9, r10, and r11, which are scratch.
-
-
-	mov [rsp-8],rsi
-	mov [rsp-16],rdi
-	mov [rsp-24],r12
-	mov [rsp-32],r13
-	mov [rsp-40],r14
-	mov [rsp-48],r15
-	mov [rsp-56],rbx
-
-	mov rax,rcx
-
-	mov	[rax+8], rbp       ; /* save regs rbp and rsp */
-	mov	[rax], rsp
-
-	mov	rsp, rax          ; /* make rsp point to &ar */
-
-	mov	rsi, [rsp+16]      ; /* rsi  = in */
-	mov	rdi, [rsp+32]      ; /* rdi  = out */
-	mov	r9, [rsp+24]       ; /* r9   = last */
-	mov	r10, [rsp+48]      ; /* r10  = end */
-	mov	rbp, [rsp+64]      ; /* rbp  = lcode */
-	mov	r11, [rsp+72]      ; /* r11  = dcode */
-	mov	rdx, [rsp+80]      ; /* rdx  = hold */
-	mov	ebx, [rsp+88]      ; /* ebx  = bits */
-	mov	r12d, [rsp+100]    ; /* r12d = lmask */
-	mov	r13d, [rsp+104]    ; /* r13d = dmask */
-                                          ; /* r14d = len */
-                                          ; /* r15d = dist */
-
-
-	cld
-	cmp	r10, rdi
-	je	L_one_time           ; /* if only one decode left */
-	cmp	r9, rsi
-
-    jne L_do_loop
-
-
-L_one_time:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code_one_time
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-	jmp	L_get_length_code_one_time
-
-ALIGN 4
-L_while_test:
-	cmp	r10, rdi
-	jbe	L_break_loop
-	cmp	r9, rsi
-	jbe	L_break_loop
-
-L_do_loop:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code    ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_length_code:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4]  ; /* eax = lcode[hold & lmask] */
-
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	mov	r8, r12            ; /* r8 = lmask */
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-
-L_get_length_code_one_time:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4] ; /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	r14d, eax         ; /* len = this */
-	shr	r14d, 16           ; /* len = this.val */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length ; /* if ((op & 16) == 0) 8% */
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_decode_distance    ; /* if (!op) */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r14d, eax         ; /* len += hold & mask[op] */
-
-L_decode_distance:
-	mov	r8, r13           ; /* r8 = dmask */
-	cmp	bl, 32
-	ja	L_get_distance_code  ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_distance_code:
-	and	r8, rdx           ; /* r8 &= hold */
-	mov	eax, [r11+r8*4] ; /* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	r15d, eax         ; /* dist = this */
-	shr	r15d, 16           ; /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-	mov	cl, al            ; /* cl = this.op */
-
-	test	al, 16             ; /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_check_dist_one
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 ; /* (1 << op) - 1 */
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r15d, eax         ; /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	r8, rsi           ; /* save in so from can use it's reg */
-	mov	rax, rdi
-	sub	rax, [rsp+40]      ; /* nbytes = out - beg */
-
-	cmp	eax, r15d
-	jb	L_clip_window        ; /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	rsi, rdi
-	sub	rsi, r15          ; /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two           ; /* if len % 2 == 0 */
-
-	rep     movsw
-	mov	al, [rsi]
-	mov	[rdi], al
-	inc	rdi
-
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	r15d, 1            ; /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[rsp+40], rdi      ; /* if out == beg, outside window */
-	je	L_check_window
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	al, [rdi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[rdi], al
-	inc	rdi
-
-L_set_two:
-	rep     stosw
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r14d        ; /* eax += len */
-	mov	eax, [rbp+rax*4] ; /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r15d        ; /* eax += dist */
-	mov	eax, [r11+rax*4] ; /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax         ; /* ecx = nbytes */
-	mov	eax, [rsp+92]     ; /* eax = wsize, prepare for dist cmp */
-	neg	ecx                ; /* nbytes = -nbytes */
-
-	cmp	eax, r15d
-	jb	L_invalid_distance_too_far ; /* if (dist > wsize) */
-
-	add	ecx, r15d         ; /* nbytes = dist - nbytes */
-	cmp	dword ptr [rsp+96], 0
-	jne	L_wrap_around_window ; /* if (write != 0) */
-
-	mov	rsi, [rsp+56]     ; /* from  = window */
-	sub	eax, ecx         ; /* eax  -= nbytes */
-	add	rsi, rax         ; /* from += wsize - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	r14d, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* eax -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = &out[ -dist ] */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [rsp+96]     ; /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window ; /* if (write >= nbytes) */
-
-	mov	esi, [rsp+92]     ; /* from  = wsize */
-	add	rsi, [rsp+56]     ; /* from += window */
-	add	rsi, rax         ; /* from += write */
-	sub	rsi, rcx         ; /* from -= nbytes */
-	sub	ecx, eax         ; /* nbytes -= write */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, [rsp+56]     ; /* from = window */
-	mov	ecx, [rsp+96]     ; /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	mov	rsi, [rsp+56]     ; /* rsi = window */
-	add	rsi, rax
-	sub	rsi, rcx         ; /* from += write - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy           ; /* if (nbytes >= len) */
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax         ; /* ecx = len */
-	rep     movsb
-
-	mov	rsi, r8          ; /* move in back to %esi, toss from */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [rsp+116], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [rsp+116], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [rsp+116], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	dword ptr [rsp+116], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [rsp+116], 0
-
-L_break_loop_with_status:
-; /* put in, out, bits, and hold back into ar and pop esp */
-	mov	[rsp+16], rsi     ; /* in */
-	mov	[rsp+32], rdi     ; /* out */
-	mov	[rsp+88], ebx     ; /* bits */
-	mov	[rsp+80], rdx     ; /* hold */
-
-	mov	rax, [rsp]       ; /* restore rbp and rsp */
-	mov	rbp, [rsp+8]
-	mov	rsp, rax
-
-
-
-	mov rsi,[rsp-8]
-	mov rdi,[rsp-16]
-	mov r12,[rsp-24]
-	mov r13,[rsp-32]
-	mov r14,[rsp-40]
-	mov r15,[rsp-48]
-	mov rbx,[rsp-56]
-
-    ret 0
-;          :
-;          : "m" (ar)
-;          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-;            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-;    );
-
-inffas8664fnc 	ENDP
-;_TEXT	ENDS
-END
diff --git a/contrib/zlib/contrib/masmx64/readme.txt b/contrib/zlib/contrib/masmx64/readme.txt
deleted file mode 100644
index 652571c7a..000000000
--- a/contrib/zlib/contrib/masmx64/readme.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast(), for 64 bits x86 (both AMD64 and Intel EM64t),
-for use with Microsoft Macro Assembler (x64) for AMD64 and Microsoft C++ 64 bits.
-
-gvmat64.asm is written by Gilles Vollant (2005), by using Brian Raiter 686/32 bits
-   assembly optimized version from Jean-loup Gailly original longest_match function
-
-inffasx64.asm and inffas8664.c were written by Chris Anderson, by optimizing
-   original function from Mark Adler
-
-Use instructions
-----------------
-Assemble the .asm files using MASM and put the object files into the zlib source
-directory.  You can also get object files here:
-
-     http://www.winimage.com/zLibDll/zlib124_masm_obj.zip
-
-define ASMV and ASMINF in your project. Include inffas8664.c in your source tree,
-and inffasx64.obj and gvmat64.obj as object to link.
-
-
-Build instructions
-------------------
-run bld_64.bat with Microsoft Macro Assembler (x64) for AMD64 (ml64.exe)
-
-ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK
-
-You can get Windows 2003 server DDK with ml64 and cl for AMD64 from
-  http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)
diff --git a/contrib/zlib/contrib/masmx86/bld_ml32.bat b/contrib/zlib/contrib/masmx86/bld_ml32.bat
deleted file mode 100644
index fcf5755e4..000000000
--- a/contrib/zlib/contrib/masmx86/bld_ml32.bat
+++ /dev/null
@@ -1,2 +0,0 @@
-ml /coff /Zi /c /Flmatch686.lst match686.asm
-ml /coff /Zi /c /Flinffas32.lst inffas32.asm
diff --git a/contrib/zlib/contrib/masmx86/inffas32.asm b/contrib/zlib/contrib/masmx86/inffas32.asm
deleted file mode 100644
index cb37a81e4..000000000
--- a/contrib/zlib/contrib/masmx86/inffas32.asm
+++ /dev/null
@@ -1,1080 +0,0 @@
-;/* inffas32.asm is a hand tuned assembler version of inffast.c -- fast decoding
-; *
-; * inffas32.asm is derivated from inffas86.c, with translation of assembly code
-; *
-; * Copyright (C) 1995-2003 Mark Adler
-; * For conditions of distribution and use, see copyright notice in zlib.h
-; *
-; * Copyright (C) 2003 Chris Anderson <christop@charm.net>
-; * Please use the copyright conditions above.
-; *
-; * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
-; * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
-; * the moment.  I have successfully compiled and tested this code with gcc2.96,
-; * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
-; * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
-; * enabled.  I will attempt to merge the MMX code into this version.  Newer
-; * versions of this and inffast.S can be found at
-; * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
-; *
-; * 2005 : modification by Gilles Vollant
-; */
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is in directory \MASM611C of Win95 DDK
-;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm
-;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/
-;
-;
-;   compile with command line option
-;   ml  /coff /Zi /c /Flinffas32.lst inffas32.asm
-
-;   if you define NO_GZIP (see inflate.h), compile with
-;   ml  /coff /Zi /c /Flinffas32.lst /DNO_GUNZIP inffas32.asm
-
-
-; zlib122sup is 0 fort zlib 1.2.2.1 and lower
-; zlib122sup is 8 fort zlib 1.2.2.2 and more (with addition of dmax and head
-;        in inflate_state in inflate.h)
-zlib1222sup      equ    8
-
-
-IFDEF GUNZIP
-  INFLATE_MODE_TYPE    equ 11
-  INFLATE_MODE_BAD     equ 26
-ELSE
-  IFNDEF NO_GUNZIP
-    INFLATE_MODE_TYPE    equ 11
-    INFLATE_MODE_BAD     equ 26
-  ELSE
-    INFLATE_MODE_TYPE    equ 3
-    INFLATE_MODE_BAD     equ 17
-  ENDIF
-ENDIF
-
-
-; 75 "inffast.S"
-;FILE "inffast.S"
-
-;;;GLOBAL _inflate_fast
-
-;;;SECTION .text
-
-
-
-	.586p
-	.mmx
-
-	name	inflate_fast_x86
-	.MODEL	FLAT
-
-_DATA			segment
-inflate_fast_use_mmx:
-	dd	1
-
-
-_TEXT			segment
-
-
-
-ALIGN 4
-	db	'Fast decoding Code from Chris Anderson'
-	db	0
-
-ALIGN 4
-invalid_literal_length_code_msg:
-	db	'invalid literal/length code'
-	db	0
-
-ALIGN 4
-invalid_distance_code_msg:
-	db	'invalid distance code'
-	db	0
-
-ALIGN 4
-invalid_distance_too_far_msg:
-	db	'invalid distance too far back'
-	db	0
-
-
-ALIGN 4
-inflate_fast_mask:
-dd	0
-dd	1
-dd	3
-dd	7
-dd	15
-dd	31
-dd	63
-dd	127
-dd	255
-dd	511
-dd	1023
-dd	2047
-dd	4095
-dd	8191
-dd	16383
-dd	32767
-dd	65535
-dd	131071
-dd	262143
-dd	524287
-dd	1048575
-dd	2097151
-dd	4194303
-dd	8388607
-dd	16777215
-dd	33554431
-dd	67108863
-dd	134217727
-dd	268435455
-dd	536870911
-dd	1073741823
-dd	2147483647
-dd	4294967295
-
-
-mode_state	 equ	0	;/* state->mode	*/
-wsize_state	 equ	(32+zlib1222sup)	;/* state->wsize */
-write_state	 equ	(36+4+zlib1222sup)	;/* state->write */
-window_state	 equ	(40+4+zlib1222sup)	;/* state->window */
-hold_state	 equ	(44+4+zlib1222sup)	;/* state->hold	*/
-bits_state	 equ	(48+4+zlib1222sup)	;/* state->bits	*/
-lencode_state	 equ	(64+4+zlib1222sup)	;/* state->lencode */
-distcode_state	 equ	(68+4+zlib1222sup)	;/* state->distcode */
-lenbits_state	 equ	(72+4+zlib1222sup)	;/* state->lenbits */
-distbits_state	 equ	(76+4+zlib1222sup)	;/* state->distbits */
-
-
-;;SECTION .text
-; 205 "inffast.S"
-;GLOBAL	inflate_fast_use_mmx
-
-;SECTION .data
-
-
-; GLOBAL inflate_fast_use_mmx:object
-;.size inflate_fast_use_mmx, 4
-; 226 "inffast.S"
-;SECTION .text
-
-ALIGN 4
-_inflate_fast proc near
-.FPO (16, 4, 0, 0, 1, 0)
-	push  edi
-	push  esi
-	push  ebp
-	push  ebx
-	pushfd
-	sub  esp,64
-	cld
-
-
-
-
-	mov  esi, [esp+88]
-	mov  edi, [esi+28]
-
-
-
-
-
-
-
-	mov  edx, [esi+4]
-	mov  eax, [esi+0]
-
-	add  edx,eax
-	sub  edx,11
-
-	mov  [esp+44],eax
-	mov  [esp+20],edx
-
-	mov  ebp, [esp+92]
-	mov  ecx, [esi+16]
-	mov  ebx, [esi+12]
-
-	sub  ebp,ecx
-	neg  ebp
-	add  ebp,ebx
-
-	sub  ecx,257
-	add  ecx,ebx
-
-	mov  [esp+60],ebx
-	mov  [esp+40],ebp
-	mov  [esp+16],ecx
-; 285 "inffast.S"
-	mov  eax, [edi+lencode_state]
-	mov  ecx, [edi+distcode_state]
-
-	mov  [esp+8],eax
-	mov  [esp+12],ecx
-
-	mov  eax,1
-	mov  ecx, [edi+lenbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+0],eax
-
-	mov  eax,1
-	mov  ecx, [edi+distbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+4],eax
-
-	mov  eax, [edi+wsize_state]
-	mov  ecx, [edi+write_state]
-	mov  edx, [edi+window_state]
-
-	mov  [esp+52],eax
-	mov  [esp+48],ecx
-	mov  [esp+56],edx
-
-	mov  ebp, [edi+hold_state]
-	mov  ebx, [edi+bits_state]
-; 321 "inffast.S"
-	mov  esi, [esp+44]
-	mov  ecx, [esp+20]
-	cmp  ecx,esi
-	ja   L_align_long
-
-	add  ecx,11
-	sub  ecx,esi
-	mov  eax,12
-	sub  eax,ecx
-	lea  edi, [esp+28]
-	rep movsb
-	mov  ecx,eax
-	xor  eax,eax
-	rep stosb
-	lea  esi, [esp+28]
-	mov  [esp+20],esi
-	jmp  L_is_aligned
-
-
-L_align_long:
-	test  esi,3
-	jz   L_is_aligned
-	xor  eax,eax
-	mov  al, [esi]
-	inc  esi
-	mov  ecx,ebx
-	add  ebx,8
-	shl  eax,cl
-	or  ebp,eax
-	jmp L_align_long
-
-L_is_aligned:
-	mov  edi, [esp+60]
-; 366 "inffast.S"
-L_check_mmx:
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	je   L_init_mmx
-	ja   L_do_loop
-
-	push  eax
-	push  ebx
-	push  ecx
-	push  edx
-	pushfd
-	mov  eax, [esp]
-	xor  dword ptr [esp],0200000h
-
-
-
-
-	popfd
-	pushfd
-	pop  edx
-	xor  edx,eax
-	jz   L_dont_use_mmx
-	xor  eax,eax
-	cpuid
-	cmp  ebx,0756e6547h
-	jne  L_dont_use_mmx
-	cmp  ecx,06c65746eh
-	jne  L_dont_use_mmx
-	cmp  edx,049656e69h
-	jne  L_dont_use_mmx
-	mov  eax,1
-	cpuid
-	shr  eax,8
-	and  eax,15
-	cmp  eax,6
-	jne  L_dont_use_mmx
-	test  edx,0800000h
-	jnz  L_use_mmx
-	jmp  L_dont_use_mmx
-L_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],2
-	jmp  L_check_mmx_pop
-L_dont_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],3
-L_check_mmx_pop:
-	pop  edx
-	pop  ecx
-	pop  ebx
-	pop  eax
-	jmp  L_check_mmx
-; 426 "inffast.S"
-ALIGN 4
-L_do_loop:
-; 437 "inffast.S"
-	cmp  bl,15
-	ja   L_get_length_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_length_code:
-	mov  edx, [esp+0]
-	mov  ecx, [esp+8]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-L_dolen:
-
-
-
-
-
-
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-
-
-
-
-
-
-	test  al,al
-	jnz   L_test_for_length_base
-
-	shr  eax,16
-	stosb
-
-L_while_test:
-
-
-	cmp  [esp+16],edi
-	jbe  L_break_loop
-
-	cmp  [esp+20],esi
-	ja   L_do_loop
-	jmp  L_break_loop
-
-L_test_for_length_base:
-; 502 "inffast.S"
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,al
-
-	test  al,16
-	jz   L_test_for_second_level_length
-	and  cl,15
-	jz   L_save_len
-	cmp  bl,cl
-	jae  L_add_bits_to_len
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_len:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-
-L_save_len:
-	mov  [esp+24],edx
-
-
-L_decode_distance:
-; 549 "inffast.S"
-	cmp  bl,15
-	ja   L_get_distance_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_distance_code:
-	mov  edx, [esp+4]
-	mov  ecx, [esp+12]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-
-L_dodist:
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-; 584 "inffast.S"
-	mov  cl,al
-
-	test  al,16
-	jz  L_test_for_second_level_dist
-	and  cl,15
-	jz  L_check_dist_one
-	cmp  bl,cl
-	jae  L_add_bits_to_dist
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_dist:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-	jmp  L_check_window
-
-L_check_window:
-; 625 "inffast.S"
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,edx
-	jb   L_clip_window
-
-	mov  ecx, [esp+24]
-	mov  esi,edi
-	sub  esi,edx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp  edx,1
-	jne  L_check_window
-	cmp  [esp+40],edi
-	je  L_check_window
-
-	dec  edi
-	mov  ecx, [esp+24]
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	jmp  L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-
-
-
-
-	test  al,64
-	jnz   L_test_for_end_of_block
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+8]
-	mov  eax, [edx+eax*4]
-	jmp  L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-
-
-
-
-	test  al,64
-	jnz   L_invalid_distance_code
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+12]
-	mov  eax, [edx+eax*4]
-	jmp  L_dodist
-
-ALIGN 4
-L_clip_window:
-; 721 "inffast.S"
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,edx
-	jb   L_invalid_distance_too_far
-
-	add  ecx,edx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window
-
-	sub  eax,ecx
-	add  esi,eax
-; 749 "inffast.S"
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_wrap_around_window:
-; 793 "inffast.S"
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_contiguous_in_window:
-; 836 "inffast.S"
-	add  esi,eax
-	sub  esi,ecx
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-
-L_do_copy1:
-; 862 "inffast.S"
-	mov  ecx,eax
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-; 878 "inffast.S"
-ALIGN 4
-L_init_mmx:
-	emms
-
-
-
-
-
-	movd mm0,ebp
-	mov  ebp,ebx
-; 896 "inffast.S"
-	movd mm4,dword ptr [esp+0]
-	movq mm3,mm4
-	movd mm5,dword ptr [esp+4]
-	movq mm2,mm5
-	pxor mm1,mm1
-	mov  ebx, [esp+8]
-	jmp  L_do_loop_mmx
-
-ALIGN 4
-L_do_loop_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja  L_get_length_code_mmx
-
-	movd mm6,ebp
-	movd mm7,dword ptr [esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_length_code_mmx:
-	pand mm4,mm0
-	movd eax,mm4
-	movq mm4,mm3
-	mov  eax, [ebx+eax*4]
-
-L_dolen_mmx:
-	movzx  ecx,ah
-	movd mm1,ecx
-	sub  ebp,ecx
-
-	test  al,al
-	jnz L_test_for_length_base_mmx
-
-	shr  eax,16
-	stosb
-
-L_while_test_mmx:
-
-
-	cmp  [esp+16],edi
-	jbe L_break_loop
-
-	cmp  [esp+20],esi
-	ja L_do_loop_mmx
-	jmp L_break_loop
-
-L_test_for_length_base_mmx:
-
-	mov  edx,eax
-	shr  edx,16
-
-	test  al,16
-	jz  L_test_for_second_level_length_mmx
-	and  eax,15
-	jz L_decode_distance_mmx
-
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  edx,ecx
-
-L_decode_distance_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja L_get_dist_code_mmx
-
-	movd mm6,ebp
-	movd mm7,dword ptr [esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_dist_code_mmx:
-	mov  ebx, [esp+12]
-	pand mm5,mm0
-	movd eax,mm5
-	movq mm5,mm2
-	mov  eax, [ebx+eax*4]
-
-L_dodist_mmx:
-
-	movzx  ecx,ah
-	mov  ebx,eax
-	shr  ebx,16
-	sub  ebp,ecx
-	movd mm1,ecx
-
-	test  al,16
-	jz L_test_for_second_level_dist_mmx
-	and  eax,15
-	jz L_check_dist_one_mmx
-
-L_add_bits_to_dist_mmx:
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ebx,ecx
-
-L_check_window_mmx:
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,ebx
-	jb L_clip_window_mmx
-
-	mov  ecx,edx
-	mov  esi,edi
-	sub  esi,ebx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_check_dist_one_mmx:
-	cmp  ebx,1
-	jne  L_check_window_mmx
-	cmp  [esp+40],edi
-	je   L_check_window_mmx
-
-	dec  edi
-	mov  ecx,edx
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_test_for_second_level_length_mmx:
-	test  al,64
-	jnz L_test_for_end_of_block
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ecx,edx
-	mov  eax, [ebx+ecx*4]
-	jmp L_dolen_mmx
-
-ALIGN 4
-L_test_for_second_level_dist_mmx:
-	test  al,64
-	jnz L_invalid_distance_code
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	mov  eax, [esp+12]
-	add  ecx,ebx
-	mov  eax, [eax+ecx*4]
-	jmp  L_dodist_mmx
-
-ALIGN 4
-L_clip_window_mmx:
-
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,ebx
-	jb  L_invalid_distance_too_far
-
-	add  ecx,ebx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window_mmx
-
-	sub  eax,ecx
-	add  esi,eax
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_wrap_around_window_mmx:
-
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window_mmx
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_contiguous_in_window_mmx:
-
-	add  esi,eax
-	sub  esi,ecx
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-
-L_do_copy1_mmx:
-
-
-	mov  ecx,edx
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-; 1174 "inffast.S"
-L_invalid_distance_code:
-
-
-
-
-
-	mov  ecx, invalid_distance_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_test_for_end_of_block:
-
-
-
-
-
-	test  al,32
-	jz  L_invalid_literal_length_code
-
-	mov  ecx,0
-	mov  edx,INFLATE_MODE_TYPE
-	jmp  L_update_stream_state
-
-L_invalid_literal_length_code:
-
-
-
-
-
-	mov  ecx, invalid_literal_length_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_invalid_distance_too_far:
-
-
-
-	mov  esi, [esp+44]
-	mov  ecx, invalid_distance_too_far_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_update_stream_state:
-
-	mov  eax, [esp+88]
-	test  ecx,ecx
-	jz  L_skip_msg
-	mov  [eax+24],ecx
-L_skip_msg:
-	mov  eax, [eax+28]
-	mov  [eax+mode_state],edx
-	jmp  L_break_loop
-
-ALIGN 4
-L_break_loop:
-; 1243 "inffast.S"
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_next_in
-
-
-
-	mov  ebx,ebp
-
-L_update_next_in:
-; 1266 "inffast.S"
-	mov  eax, [esp+88]
-	mov  ecx,ebx
-	mov  edx, [eax+28]
-	shr  ecx,3
-	sub  esi,ecx
-	shl  ecx,3
-	sub  ebx,ecx
-	mov  [eax+12],edi
-	mov  [edx+bits_state],ebx
-	mov  ecx,ebx
-
-	lea  ebx, [esp+28]
-	cmp  [esp+20],ebx
-	jne  L_buf_not_used
-
-	sub  esi,ebx
-	mov  ebx, [eax+0]
-	mov  [esp+20],ebx
-	add  esi,ebx
-	mov  ebx, [eax+4]
-	sub  ebx,11
-	add  [esp+20],ebx
-
-L_buf_not_used:
-	mov  [eax+0],esi
-
-	mov  ebx,1
-	shl  ebx,cl
-	dec  ebx
-
-
-
-
-
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_hold
-
-
-
-	psrlq mm0,mm1
-	movd ebp,mm0
-
-	emms
-
-L_update_hold:
-
-
-
-	and  ebp,ebx
-	mov  [edx+hold_state],ebp
-
-
-
-
-	mov  ebx, [esp+20]
-	cmp  ebx,esi
-	jbe  L_last_is_smaller
-
-	sub  ebx,esi
-	add  ebx,11
-	mov  [eax+4],ebx
-	jmp  L_fixup_out
-L_last_is_smaller:
-	sub  esi,ebx
-	neg  esi
-	add  esi,11
-	mov  [eax+4],esi
-
-
-
-
-L_fixup_out:
-
-	mov  ebx, [esp+16]
-	cmp  ebx,edi
-	jbe  L_end_is_smaller
-
-	sub  ebx,edi
-	add  ebx,257
-	mov  [eax+16],ebx
-	jmp  L_done
-L_end_is_smaller:
-	sub  edi,ebx
-	neg  edi
-	add  edi,257
-	mov  [eax+16],edi
-
-
-
-
-
-L_done:
-	add  esp,64
-	popfd
-	pop  ebx
-	pop  ebp
-	pop  esi
-	pop  edi
-	ret
-_inflate_fast endp
-
-_TEXT	ends
-end
diff --git a/contrib/zlib/contrib/masmx86/match686.asm b/contrib/zlib/contrib/masmx86/match686.asm
deleted file mode 100644
index 69e0eed01..000000000
--- a/contrib/zlib/contrib/masmx86/match686.asm
+++ /dev/null
@@ -1,479 +0,0 @@
-; match686.asm -- Asm portion of the optimized longest_match for 32 bits x86
-; Copyright (C) 1995-1996 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-; File written by Gilles Vollant, by converting match686.S from Brian Raiter
-; for MASM. This is as assembly version of longest_match
-;  from Jean-loup Gailly in deflate.c
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is distributed in
-;  http://www.microsoft.com/downloads/details.aspx?FamilyID=7a1c9da0-0510-44a2-b042-7ef370530c64
-;
-; this file contain two implementation of longest_match
-;
-;  this longest_match was written by Brian raiter (1998), optimized for Pentium Pro
-;   (and the faster known version of match_init on modern Core 2 Duo and AMD Phenom)
-;
-;  for using an assembly version of longest_match, you need define ASMV in project
-;
-;    compile the asm file running
-;           ml /coff /Zi /c /Flmatch686.lst match686.asm
-;    and do not include match686.obj in your project
-;
-; note: contrib of zLib 1.2.3 and earlier contained both a deprecated version for
-;  Pentium (prior Pentium Pro) and this version for Pentium Pro and modern processor
-;  with autoselect (with cpu detection code)
-;  if you want support the old pentium optimization, you can still use these version
-;
-; this file is not optimized for old pentium, but it compatible with all x86 32 bits
-; processor (starting 80386)
-;
-;
-; see below : zlib1222add must be adjuster if you use a zlib version < 1.2.2.2
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-
-    NbStack         equ     76
-    cur_match       equ     dword ptr[esp+NbStack-0]
-    str_s           equ     dword ptr[esp+NbStack-4]
-; 5 dword on top (ret,ebp,esi,edi,ebx)
-    adrret          equ     dword ptr[esp+NbStack-8]
-    pushebp         equ     dword ptr[esp+NbStack-12]
-    pushedi         equ     dword ptr[esp+NbStack-16]
-    pushesi         equ     dword ptr[esp+NbStack-20]
-    pushebx         equ     dword ptr[esp+NbStack-24]
-
-    chain_length    equ     dword ptr [esp+NbStack-28]
-    limit           equ     dword ptr [esp+NbStack-32]
-    best_len        equ     dword ptr [esp+NbStack-36]
-    window          equ     dword ptr [esp+NbStack-40]
-    prev            equ     dword ptr [esp+NbStack-44]
-    scan_start      equ      word ptr [esp+NbStack-48]
-    wmask           equ     dword ptr [esp+NbStack-52]
-    match_start_ptr equ     dword ptr [esp+NbStack-56]
-    nice_match      equ     dword ptr [esp+NbStack-60]
-    scan            equ     dword ptr [esp+NbStack-64]
-
-    windowlen       equ     dword ptr [esp+NbStack-68]
-    match_start     equ     dword ptr [esp+NbStack-72]
-    strend          equ     dword ptr [esp+NbStack-76]
-    NbStackAdd      equ     (NbStack-24)
-
-    .386p
-
-    name    gvmatch
-    .MODEL  FLAT
-
-
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-    zlib1222add         equ     8
-
-;  Note : these value are good with a 8 bytes boundary pack structure
-    dep_chain_length    equ     74h+zlib1222add
-    dep_window          equ     30h+zlib1222add
-    dep_strstart        equ     64h+zlib1222add
-    dep_prev_length     equ     70h+zlib1222add
-    dep_nice_match      equ     88h+zlib1222add
-    dep_w_size          equ     24h+zlib1222add
-    dep_prev            equ     38h+zlib1222add
-    dep_w_mask          equ     2ch+zlib1222add
-    dep_good_match      equ     84h+zlib1222add
-    dep_match_start     equ     68h+zlib1222add
-    dep_lookahead       equ     6ch+zlib1222add
-
-
-_TEXT                   segment
-
-IFDEF NOUNDERLINE
-            public  longest_match
-            public  match_init
-ELSE
-            public  _longest_match
-            public  _match_init
-ENDIF
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-
-MAX_MATCH       equ     258
-MIN_MATCH       equ     3
-MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)
-MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)
-
-
-;;; stack frame offsets
-
-chainlenwmask   equ  esp + 0    ; high word: current chain len
-                    ; low word: s->wmask
-window      equ  esp + 4    ; local copy of s->window
-windowbestlen   equ  esp + 8    ; s->window + bestlen
-scanstart   equ  esp + 16   ; first two bytes of string
-scanend     equ  esp + 12   ; last two bytes of string
-scanalign   equ  esp + 20   ; dword-misalignment of string
-nicematch   equ  esp + 24   ; a good enough match size
-bestlen     equ  esp + 28   ; size of best match so far
-scan        equ  esp + 32   ; ptr to string wanting match
-
-LocalVarsSize   equ 36
-;   saved ebx   byte esp + 36
-;   saved edi   byte esp + 40
-;   saved esi   byte esp + 44
-;   saved ebp   byte esp + 48
-;   return address  byte esp + 52
-deflatestate    equ  esp + 56   ; the function arguments
-curmatch    equ  esp + 60
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-dsWSize     equ 36+zlib1222add
-dsWMask     equ 44+zlib1222add
-dsWindow    equ 48+zlib1222add
-dsPrev      equ 56+zlib1222add
-dsMatchLen  equ 88+zlib1222add
-dsPrevMatch equ 92+zlib1222add
-dsStrStart  equ 100+zlib1222add
-dsMatchStart    equ 104+zlib1222add
-dsLookahead equ 108+zlib1222add
-dsPrevLen   equ 112+zlib1222add
-dsMaxChainLen   equ 116+zlib1222add
-dsGoodMatch equ 132+zlib1222add
-dsNiceMatch equ 136+zlib1222add
-
-
-;;; match686.asm -- Pentium-Pro-optimized version of longest_match()
-;;; Written for zlib 1.1.2
-;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
-;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html
-;;;
-;;
-;;  This software is provided 'as-is', without any express or implied
-;;  warranty.  In no event will the authors be held liable for any damages
-;;  arising from the use of this software.
-;;
-;;  Permission is granted to anyone to use this software for any purpose,
-;;  including commercial applications, and to alter it and redistribute it
-;;  freely, subject to the following restrictions:
-;;
-;;  1. The origin of this software must not be misrepresented; you must not
-;;     claim that you wrote the original software. If you use this software
-;;     in a product, an acknowledgment in the product documentation would be
-;;     appreciated but is not required.
-;;  2. Altered source versions must be plainly marked as such, and must not be
-;;     misrepresented as being the original software
-;;  3. This notice may not be removed or altered from any source distribution.
-;;
-
-;GLOBAL _longest_match, _match_init
-
-
-;SECTION    .text
-
-;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)
-
-;_longest_match:
-    IFDEF NOUNDERLINE
-    longest_match       proc near
-    ELSE
-    _longest_match      proc near
-    ENDIF
-.FPO (9, 4, 0, 0, 1, 0)
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-        push    ebp
-        push    edi
-        push    esi
-        push    ebx
-        sub esp, LocalVarsSize
-
-;;; Retrieve the function arguments. ecx will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-        mov edx, [deflatestate]
-        mov ecx, [curmatch]
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov eax, [edx + dsPrevLen]
-        mov ebx, [edx + dsGoodMatch]
-        cmp eax, ebx
-        mov eax, [edx + dsWMask]
-        mov ebx, [edx + dsMaxChainLen]
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-        mov [chainlenwmask], ebx
-
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-        mov eax, [edx + dsNiceMatch]
-        mov ebx, [edx + dsLookahead]
-        cmp ebx, eax
-        jl  LookaheadLess
-        mov ebx, eax
-LookaheadLess:  mov [nicematch], ebx
-
-;;; register Bytef *scan = s->window + s->strstart;
-
-        mov esi, [edx + dsWindow]
-        mov [window], esi
-        mov ebp, [edx + dsStrStart]
-        lea edi, [esi + ebp]
-        mov [scan], edi
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-        mov eax, edi
-        neg eax
-        and eax, 3
-        mov [scanalign], eax
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-        mov eax, [edx + dsWSize]
-        sub eax, MIN_LOOKAHEAD
-        sub ebp, eax
-        jg  LimitPositive
-        xor ebp, ebp
-LimitPositive:
-
-;;; int best_len = s->prev_length;
-
-        mov eax, [edx + dsPrevLen]
-        mov [bestlen], eax
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-        add esi, eax
-        mov [windowbestlen], esi
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx   ebx, word ptr [edi]
-        mov [scanstart], ebx
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov [scanend], ebx
-        mov edi, [edx + dsPrev]
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-        jmp short LoopEntry
-
-align 4
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; ecx = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and ecx, edx
-        movzx   ecx, word ptr [edi + ecx*2]
-        cmp ecx, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-LoopEntry:  movzx   eax, word ptr [esi + ecx - 1]
-        cmp eax, ebx
-        jnz LookupLoop
-        mov eax, [window]
-        movzx   eax, word ptr [eax + ecx]
-        cmp eax, [scanstart]
-        jnz LookupLoop
-
-;;; Store the current value of chainlen.
-
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        mov esi, [window]
-        mov edi, [scan]
-        add esi, ecx
-        mov eax, [scanalign]
-        mov edx, 0fffffef8h; -(MAX_MATCH_8)
-        lea edi, [edi + eax + 0108h] ;MAX_MATCH_8]
-        lea esi, [esi + eax + 0108h] ;MAX_MATCH_8]
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust edx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (esi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-LoopCmps:
-        mov eax, [esi + edx]
-        xor eax, [edi + edx]
-        jnz LeaveLoopCmps
-        mov eax, [esi + edx + 4]
-        xor eax, [edi + edx + 4]
-        jnz LeaveLoopCmps4
-        add edx, 8
-        jnz LoopCmps
-        jmp short LenMaximum
-LeaveLoopCmps4: add edx, 4
-LeaveLoopCmps:  test    eax, 0000FFFFh
-        jnz LenLower
-        add edx,  2
-        shr eax, 16
-LenLower:   sub al, 1
-        adc edx, 0
-
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea eax, [edi + edx]
-        mov edi, [scan]
-        sub eax, edi
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        cmp eax, ebx
-        jg  LongerMatch
-        mov esi, [windowbestlen]
-        mov edi, [edx + dsPrev]
-        mov ebx, [scanend]
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:    mov ebx, [nicematch]
-        mov [bestlen], eax
-        mov [edx + dsMatchStart], ecx
-        cmp eax, ebx
-        jge LeaveNow
-        mov esi, [window]
-        add esi, eax
-        mov [windowbestlen], esi
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov edi, [edx + dsPrev]
-        mov [scanend], ebx
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum: mov edx, [deflatestate]
-        mov dword ptr [bestlen], MAX_MATCH
-        mov [edx + dsMatchStart], ecx
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        mov eax, [edx + dsLookahead]
-        cmp ebx, eax
-        jg  LookaheadRet
-        mov eax, ebx
-LookaheadRet:
-
-;;; Restore the stack and return from whence we came.
-
-        add esp, LocalVarsSize
-        pop ebx
-        pop esi
-        pop edi
-        pop ebp
-
-        ret
-; please don't remove this string !
-; Your can freely use match686 in any free or commercial app if you don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998",0dh,0ah
-
-
-    IFDEF NOUNDERLINE
-    longest_match       endp
-    ELSE
-    _longest_match      endp
-    ENDIF
-
-    IFDEF NOUNDERLINE
-    match_init      proc near
-                    ret
-    match_init      endp
-    ELSE
-    _match_init     proc near
-                    ret
-    _match_init     endp
-    ENDIF
-
-
-_TEXT   ends
-end
diff --git a/contrib/zlib/contrib/masmx86/readme.txt b/contrib/zlib/contrib/masmx86/readme.txt
deleted file mode 100644
index 3f8888679..000000000
--- a/contrib/zlib/contrib/masmx86/readme.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast().
-
-
-Use instructions
-----------------
-Assemble using MASM, and copy the object files into the zlib source
-directory, then run the appropriate makefile, as suggested below.  You can
-donwload MASM from here:
-
-    http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=7a1c9da0-0510-44a2-b042-7ef370530c64
-
-You can also get objects files here:
-
-    http://www.winimage.com/zLibDll/zlib124_masm_obj.zip
-
-Build instructions
-------------------
-* With Microsoft C and MASM:
-nmake -f win32/Makefile.msc LOC="-DASMV -DASMINF" OBJA="match686.obj inffas32.obj"
-
-* With Borland C and TASM:
-make -f win32/Makefile.bor LOCAL_ZLIB="-DASMV -DASMINF" OBJA="match686.obj inffas32.obj" OBJPA="+match686c.obj+match686.obj+inffas32.obj"
-
diff --git a/contrib/zlib/contrib/minizip/Makefile.am b/contrib/zlib/contrib/minizip/Makefile.am
deleted file mode 100644
index d343011eb..000000000
--- a/contrib/zlib/contrib/minizip/Makefile.am
+++ /dev/null
@@ -1,45 +0,0 @@
-lib_LTLIBRARIES = libminizip.la
-
-if COND_DEMOS
-bin_PROGRAMS = miniunzip minizip
-endif
-
-zlib_top_srcdir = $(top_srcdir)/../..
-zlib_top_builddir = $(top_builddir)/../..
-
-AM_CPPFLAGS = -I$(zlib_top_srcdir)
-AM_LDFLAGS = -L$(zlib_top_builddir)
-
-if WIN32
-iowin32_src = iowin32.c
-iowin32_h = iowin32.h
-endif
-
-libminizip_la_SOURCES = \
-	ioapi.c \
-	mztools.c \
-	unzip.c \
-	zip.c \
-	${iowin32_src}
-
-libminizip_la_LDFLAGS = $(AM_LDFLAGS) -version-info 1:0:0 -lz
-
-minizip_includedir = $(includedir)/minizip
-minizip_include_HEADERS = \
-	crypt.h \
-	ioapi.h \
-	mztools.h \
-	unzip.h \
-	zip.h \
-	${iowin32_h}
-
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = minizip.pc
-
-EXTRA_PROGRAMS = miniunzip minizip
-
-miniunzip_SOURCES = miniunz.c
-miniunzip_LDADD = libminizip.la
-
-minizip_SOURCES = minizip.c
-minizip_LDADD = libminizip.la -lz
diff --git a/contrib/zlib/contrib/minizip/MiniZip64_Changes.txt b/contrib/zlib/contrib/minizip/MiniZip64_Changes.txt
deleted file mode 100644
index 13a1bd91a..000000000
--- a/contrib/zlib/contrib/minizip/MiniZip64_Changes.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-
-MiniZip 1.1 was derrived from MiniZip at version 1.01f
-
-Change in 1.0 (Okt 2009)
- - **TODO - Add history**
-
diff --git a/contrib/zlib/contrib/minizip/MiniZip64_info.txt b/contrib/zlib/contrib/minizip/MiniZip64_info.txt
deleted file mode 100644
index 57d715242..000000000
--- a/contrib/zlib/contrib/minizip/MiniZip64_info.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-MiniZip - Copyright (c) 1998-2010 - by Gilles Vollant - version 1.1 64 bits from Mathias Svensson
-
-Introduction
----------------------
-MiniZip 1.1 is built from MiniZip 1.0 by Gilles Vollant ( http://www.winimage.com/zLibDll/minizip.html )
-
-When adding ZIP64 support into minizip it would result into risk of breaking compatibility with minizip 1.0.
-All possible work was done for compatibility.
-
-
-Background
----------------------
-When adding ZIP64 support Mathias Svensson found that Even Rouault have added ZIP64 
-support for unzip.c into minizip for a open source project called gdal ( http://www.gdal.org/ )
-
-That was used as a starting point. And after that ZIP64 support was added to zip.c
-some refactoring and code cleanup was also done.
-
-
-Changed from MiniZip 1.0 to MiniZip 1.1
----------------------------------------
-* Added ZIP64 support for unzip ( by Even Rouault )
-* Added ZIP64 support for zip ( by Mathias Svensson )
-* Reverted some changed that Even Rouault did.
-* Bunch of patches received from Gulles Vollant that he received for MiniZip from various users.
-* Added unzip patch for BZIP Compression method (patch create by Daniel Borca)
-* Added BZIP Compress method for zip
-* Did some refactoring and code cleanup
-
-
-Credits
-
- Gilles Vollant    - Original MiniZip author
- Even Rouault      - ZIP64 unzip Support
- Daniel Borca      - BZip Compression method support in unzip
- Mathias Svensson  - ZIP64 zip support
- Mathias Svensson  - BZip Compression method support in zip
-
- Resources
-
- ZipLayout   http://result42.com/projects/ZipFileLayout
-             Command line tool for Windows that shows the layout and information of the headers in a zip archive.
-             Used when debugging and validating the creation of zip files using MiniZip64
-
-
- ZIP App Note  http://www.pkware.com/documents/casestudies/APPNOTE.TXT
-               Zip File specification
-
-
-Notes.
- * To be able to use BZip compression method in zip64.c or unzip64.c the BZIP2 lib is needed and HAVE_BZIP2 need to be defined.
-
-License
-----------------------------------------------------------
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-----------------------------------------------------------
-
diff --git a/contrib/zlib/contrib/minizip/configure.ac b/contrib/zlib/contrib/minizip/configure.ac
deleted file mode 100644
index 5b1197097..000000000
--- a/contrib/zlib/contrib/minizip/configure.ac
+++ /dev/null
@@ -1,32 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_INIT([minizip], [1.2.11], [bugzilla.redhat.com])
-AC_CONFIG_SRCDIR([minizip.c])
-AM_INIT_AUTOMAKE([foreign])
-LT_INIT
-
-AC_MSG_CHECKING([whether to build example programs])
-AC_ARG_ENABLE([demos], AC_HELP_STRING([--enable-demos], [build example programs]))
-AM_CONDITIONAL([COND_DEMOS], [test "$enable_demos" = yes])
-if test "$enable_demos" = yes
-then
-	AC_MSG_RESULT([yes])
-else
-	AC_MSG_RESULT([no])
-fi
-
-case "${host}" in
-	*-mingw* | mingw*)
-		WIN32="yes"
-		;;
-	*)
-		;;
-esac
-AM_CONDITIONAL([WIN32], [test "${WIN32}" = "yes"])
-
-
-AC_SUBST([HAVE_UNISTD_H], [0])
-AC_CHECK_HEADER([unistd.h], [HAVE_UNISTD_H=1], [])
-AC_CONFIG_FILES([Makefile minizip.pc])
-AC_OUTPUT
diff --git a/contrib/zlib/contrib/minizip/crypt.h b/contrib/zlib/contrib/minizip/crypt.h
deleted file mode 100644
index 1e9e8200b..000000000
--- a/contrib/zlib/contrib/minizip/crypt.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* crypt.h -- base code for crypt/uncrypt ZIPfile
-
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This code is a modified version of crypting code in Infozip distribution
-
-   The encryption/decryption parts of this source code (as opposed to the
-   non-echoing password parts) were originally written in Europe.  The
-   whole source package can be freely distributed, including from the USA.
-   (Prior to January 2000, re-export from the US was a violation of US law.)
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-
-   This code support the "Traditional PKWARE Encryption".
-
-   The new AES encryption added on Zip format by Winzip (see the page
-   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
-   Encryption is not supported.
-*/
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-/***********************************************************************
- * Return the next byte in the pseudo-random sequence
- */
-static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
-{
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
-    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-/***********************************************************************
- * Update the encryption keys with the next byte of plain text
- */
-static int update_keys(unsigned long* pkeys,const z_crc_t* pcrc_32_tab,int c)
-{
-    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-      register int keyshift = (int)((*(pkeys+1)) >> 24);
-      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-
-/***********************************************************************
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
-static void init_keys(const char* passwd,unsigned long* pkeys,const z_crc_t* pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != '\0') {
-        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
-        passwd++;
-    }
-}
-
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
-
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-
-#define RAND_HEAD_LEN  12
-   /* "last resort" source for second part of crypt seed pattern */
-#  ifndef ZCR_SEED2
-#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#  endif
-
-static int crypthead(const char* passwd,      /* password string */
-                     unsigned char* buf,      /* where to write header */
-                     int bufSize,
-                     unsigned long* pkeys,
-                     const z_crc_t* pcrc_32_tab,
-                     unsigned long crcForCrypting)
-{
-    int n;                       /* index in random header */
-    int t;                       /* temporary */
-    int c;                       /* random byte */
-    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
-    static unsigned calls = 0;   /* ensure different random header each time */
-
-    if (bufSize<RAND_HEAD_LEN)
-      return 0;
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
-     * output of rand() to get less predictability, since rand() is
-     * often poorly implemented.
-     */
-    if (++calls == 1)
-    {
-        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-    }
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        c = (rand() >> 7) & 0xff;
-        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
-    }
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
-    }
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
-    return n;
-}
-
-#endif
diff --git a/contrib/zlib/contrib/minizip/ioapi.c b/contrib/zlib/contrib/minizip/ioapi.c
deleted file mode 100644
index 7f5c191b2..000000000
--- a/contrib/zlib/contrib/minizip/ioapi.c
+++ /dev/null
@@ -1,247 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-*/
-
-#if defined(_WIN32) && (!(defined(_CRT_SECURE_NO_WARNINGS)))
-        #define _CRT_SECURE_NO_WARNINGS
-#endif
-
-#if defined(__APPLE__) || defined(IOAPI_NO_64)
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-#include "ioapi.h"
-
-voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)
-{
-    if (pfilefunc->zfile_func64.zopen64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);
-    else
-    {
-        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);
-    }
-}
-
-long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
-{
-    if (pfilefunc->zfile_func64.zseek64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
-    else
-    {
-        uLong offsetTruncated = (uLong)offset;
-        if (offsetTruncated != offset)
-            return -1;
-        else
-            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);
-    }
-}
-
-ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)
-{
-    if (pfilefunc->zfile_func64.zseek64_file != NULL)
-        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);
-    else
-    {
-        uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);
-        if ((tell_uLong) == MAXU32)
-            return (ZPOS64_T)-1;
-        else
-            return tell_uLong;
-    }
-}
-
-void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)
-{
-    p_filefunc64_32->zfile_func64.zopen64_file = NULL;
-    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
-    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
-    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
-    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
-    p_filefunc64_32->zfile_func64.ztell64_file = NULL;
-    p_filefunc64_32->zfile_func64.zseek64_file = NULL;
-    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
-    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
-    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
-    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
-    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
-}
-
-
-
-static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename, int mode));
-static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf,uLong size));
-static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
-static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
-static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));
-
-static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)
-{
-    FILE* file = NULL;
-    const char* mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        mode_fopen = "rb";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        mode_fopen = "r+b";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        mode_fopen = "wb";
-
-    if ((filename!=NULL) && (mode_fopen != NULL))
-        file = fopen(filename, mode_fopen);
-    return file;
-}
-
-static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)
-{
-    FILE* file = NULL;
-    const char* mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        mode_fopen = "rb";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        mode_fopen = "r+b";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        mode_fopen = "wb";
-
-    if ((filename!=NULL) && (mode_fopen != NULL))
-        file = FOPEN_FUNC((const char*)filename, mode_fopen);
-    return file;
-}
-
-
-static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)
-{
-    uLong ret;
-    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)
-{
-    uLong ret;
-    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
-{
-    long ret;
-    ret = ftell((FILE *)stream);
-    return ret;
-}
-
-
-static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)
-{
-    ZPOS64_T ret;
-    ret = FTELLO_FUNC((FILE *)stream);
-    return ret;
-}
-
-static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)
-{
-    int fseek_origin=0;
-    long ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        fseek_origin = SEEK_CUR;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        fseek_origin = SEEK_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        fseek_origin = SEEK_SET;
-        break;
-    default: return -1;
-    }
-    ret = 0;
-    if (fseek((FILE *)stream, offset, fseek_origin) != 0)
-        ret = -1;
-    return ret;
-}
-
-static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
-{
-    int fseek_origin=0;
-    long ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        fseek_origin = SEEK_CUR;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        fseek_origin = SEEK_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        fseek_origin = SEEK_SET;
-        break;
-    default: return -1;
-    }
-    ret = 0;
-
-    if(FSEEKO_FUNC((FILE *)stream, offset, fseek_origin) != 0)
-                        ret = -1;
-
-    return ret;
-}
-
-
-static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)
-{
-    int ret;
-    ret = fclose((FILE *)stream);
-    return ret;
-}
-
-static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)
-{
-    int ret;
-    ret = ferror((FILE *)stream);
-    return ret;
-}
-
-void fill_fopen_filefunc (pzlib_filefunc_def)
-  zlib_filefunc_def* pzlib_filefunc_def;
-{
-    pzlib_filefunc_def->zopen_file = fopen_file_func;
-    pzlib_filefunc_def->zread_file = fread_file_func;
-    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
-    pzlib_filefunc_def->ztell_file = ftell_file_func;
-    pzlib_filefunc_def->zseek_file = fseek_file_func;
-    pzlib_filefunc_def->zclose_file = fclose_file_func;
-    pzlib_filefunc_def->zerror_file = ferror_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-void fill_fopen64_filefunc (zlib_filefunc64_def*  pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = fopen64_file_func;
-    pzlib_filefunc_def->zread_file = fread_file_func;
-    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
-    pzlib_filefunc_def->ztell64_file = ftell64_file_func;
-    pzlib_filefunc_def->zseek64_file = fseek64_file_func;
-    pzlib_filefunc_def->zclose_file = fclose_file_func;
-    pzlib_filefunc_def->zerror_file = ferror_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
diff --git a/contrib/zlib/contrib/minizip/ioapi.h b/contrib/zlib/contrib/minizip/ioapi.h
deleted file mode 100644
index 8dcbdb06e..000000000
--- a/contrib/zlib/contrib/minizip/ioapi.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         Changes
-
-    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)
-    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.
-               More if/def section may be needed to support other platforms
-    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.
-                          (but you should use iowin32.c for windows instead)
-
-*/
-
-#ifndef _ZLIBIOAPI64_H
-#define _ZLIBIOAPI64_H
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-
-  // Linux needs this to support file operation on files larger then 4+GB
-  // But might need better if/def to select just the platforms that needs them.
-
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "zlib.h"
-
-#if defined(USE_FILE32API)
-#define fopen64 fopen
-#define ftello64 ftell
-#define fseeko64 fseek
-#else
-#ifdef __FreeBSD__
-#define fopen64 fopen
-#define ftello64 ftello
-#define fseeko64 fseeko
-#endif
-#ifdef _MSC_VER
- #define fopen64 fopen
- #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
-  #define ftello64 _ftelli64
-  #define fseeko64 _fseeki64
- #else // old MSC
-  #define ftello64 ftell
-  #define fseeko64 fseek
- #endif
-#endif
-#endif
-
-/*
-#ifndef ZPOS64_T
-  #ifdef _WIN32
-                #define ZPOS64_T fpos_t
-  #else
-    #include <stdint.h>
-    #define ZPOS64_T uint64_t
-  #endif
-#endif
-*/
-
-#ifdef HAVE_MINIZIP64_CONF_H
-#include "mz64conf.h"
-#endif
-
-/* a type choosen by DEFINE */
-#ifdef HAVE_64BIT_INT_CUSTOM
-typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
-#else
-#ifdef HAS_STDINT_H
-#include "stdint.h"
-typedef uint64_t ZPOS64_T;
-#else
-
-/* Maximum unsigned 32-bit value used as placeholder for zip64 */
-#define MAXU32 0xffffffff
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef unsigned __int64 ZPOS64_T;
-#else
-typedef unsigned long long int ZPOS64_T;
-#endif
-#endif
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define ZLIB_FILEFUNC_SEEK_CUR (1)
-#define ZLIB_FILEFUNC_SEEK_END (2)
-#define ZLIB_FILEFUNC_SEEK_SET (0)
-
-#define ZLIB_FILEFUNC_MODE_READ      (1)
-#define ZLIB_FILEFUNC_MODE_WRITE     (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
-
-#define ZLIB_FILEFUNC_MODE_EXISTING (4)
-#define ZLIB_FILEFUNC_MODE_CREATE   (8)
-
-
-#ifndef ZCALLBACK
- #if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-   #define ZCALLBACK CALLBACK
- #else
-   #define ZCALLBACK
- #endif
-#endif
-
-
-
-
-typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, const char* filename, int mode));
-typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
-typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
-
-typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
-
-
-/* here is the "old" 32 bits structure structure */
-typedef struct zlib_filefunc_def_s
-{
-    open_file_func      zopen_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell_file_func      ztell_file;
-    seek_file_func      zseek_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc_def;
-
-typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
-
-typedef struct zlib_filefunc64_def_s
-{
-    open64_file_func    zopen64_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell64_file_func    ztell64_file;
-    seek64_file_func    zseek64_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc64_def;
-
-void fill_fopen64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-/* now internal definition, only for zip.c and unzip.h */
-typedef struct zlib_filefunc64_32_def_s
-{
-    zlib_filefunc64_def zfile_func64;
-    open_file_func      zopen32_file;
-    tell_file_func      ztell32_file;
-    seek_file_func      zseek32_file;
-} zlib_filefunc64_32_def;
-
-
-#define ZREAD64(filefunc,filestream,buf,size)     ((*((filefunc).zfile_func64.zread_file))   ((filefunc).zfile_func64.opaque,filestream,buf,size))
-#define ZWRITE64(filefunc,filestream,buf,size)    ((*((filefunc).zfile_func64.zwrite_file))  ((filefunc).zfile_func64.opaque,filestream,buf,size))
-//#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))
-//#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))
-#define ZCLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zclose_file))  ((filefunc).zfile_func64.opaque,filestream))
-#define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
-
-voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
-long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
-ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
-
-void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
-
-#define ZOPEN64(filefunc,filename,mode)         (call_zopen64((&(filefunc)),(filename),(mode)))
-#define ZTELL64(filefunc,filestream)            (call_ztell64((&(filefunc)),(filestream)))
-#define ZSEEK64(filefunc,filestream,pos,mode)   (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/contrib/zlib/contrib/minizip/iowin32.c b/contrib/zlib/contrib/minizip/iowin32.c
deleted file mode 100644
index 274f39eb1..000000000
--- a/contrib/zlib/contrib/minizip/iowin32.c
+++ /dev/null
@@ -1,462 +0,0 @@
-/* iowin32.c -- IO base function header for compress/uncompress .zip
-     Version 1.1, February 14h, 2010
-     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-     For more info read MiniZip_info.txt
-
-*/
-
-#include <stdlib.h>
-
-#include "zlib.h"
-#include "ioapi.h"
-#include "iowin32.h"
-
-#ifndef INVALID_HANDLE_VALUE
-#define INVALID_HANDLE_VALUE (0xFFFFFFFF)
-#endif
-
-#ifndef INVALID_SET_FILE_POINTER
-#define INVALID_SET_FILE_POINTER ((DWORD)-1)
-#endif
-
-
-// see Include/shared/winapifamily.h in the Windows Kit
-#if defined(WINAPI_FAMILY_PARTITION) && (!(defined(IOWIN32_USING_WINRT_API)))
-#if WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
-#define IOWIN32_USING_WINRT_API 1
-#endif
-#endif
-
-voidpf  ZCALLBACK win32_open_file_func  OF((voidpf opaque, const char* filename, int mode));
-uLong   ZCALLBACK win32_read_file_func  OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-uLong   ZCALLBACK win32_write_file_func OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-ZPOS64_T ZCALLBACK win32_tell64_file_func  OF((voidpf opaque, voidpf stream));
-long    ZCALLBACK win32_seek64_file_func  OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-int     ZCALLBACK win32_close_file_func OF((voidpf opaque, voidpf stream));
-int     ZCALLBACK win32_error_file_func OF((voidpf opaque, voidpf stream));
-
-typedef struct
-{
-    HANDLE hf;
-    int error;
-} WIN32FILE_IOWIN;
-
-
-static void win32_translate_open_mode(int mode,
-                                      DWORD* lpdwDesiredAccess,
-                                      DWORD* lpdwCreationDisposition,
-                                      DWORD* lpdwShareMode,
-                                      DWORD* lpdwFlagsAndAttributes)
-{
-    *lpdwDesiredAccess = *lpdwShareMode = *lpdwFlagsAndAttributes = *lpdwCreationDisposition = 0;
-
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-    {
-        *lpdwDesiredAccess = GENERIC_READ;
-        *lpdwCreationDisposition = OPEN_EXISTING;
-        *lpdwShareMode = FILE_SHARE_READ;
-    }
-    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-    {
-        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        *lpdwCreationDisposition = OPEN_EXISTING;
-    }
-    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-    {
-        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        *lpdwCreationDisposition = CREATE_ALWAYS;
-    }
-}
-
-static voidpf win32_build_iowin(HANDLE hFile)
-{
-    voidpf ret=NULL;
-
-    if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
-    {
-        WIN32FILE_IOWIN w32fiow;
-        w32fiow.hf = hFile;
-        w32fiow.error = 0;
-        ret = malloc(sizeof(WIN32FILE_IOWIN));
-
-        if (ret==NULL)
-            CloseHandle(hFile);
-        else
-            *((WIN32FILE_IOWIN*)ret) = w32fiow;
-    }
-    return ret;
-}
-
-voidpf ZCALLBACK win32_open64_file_func (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-#ifdef IOWIN32_USING_WINRT_API
-#ifdef UNICODE
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-    {
-        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
-        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
-        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
-    }
-#endif
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-#endif
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open64_file_funcA (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-#ifdef IOWIN32_USING_WINRT_API
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-    {
-        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
-        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
-        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
-    }
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-#endif
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open64_file_funcW (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-#ifdef IOWIN32_USING_WINRT_API
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile2((LPCWSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition,NULL);
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-#endif
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open_file_func (voidpf opaque,const char* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-#ifdef IOWIN32_USING_WINRT_API
-#ifdef UNICODE
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-    {
-        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
-        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
-        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
-    }
-#endif
-#else
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-#endif
-
-    return win32_build_iowin(hFile);
-}
-
-
-uLong ZCALLBACK win32_read_file_func (voidpf opaque, voidpf stream, void* buf,uLong size)
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-
-    if (hFile != NULL)
-    {
-        if (!ReadFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-    }
-
-    return ret;
-}
-
-
-uLong ZCALLBACK win32_write_file_func (voidpf opaque,voidpf stream,const void* buf,uLong size)
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-
-    if (hFile != NULL)
-    {
-        if (!WriteFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-    }
-
-    return ret;
-}
-
-static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *newPos,  DWORD dwMoveMethod)
-{
-#ifdef IOWIN32_USING_WINRT_API
-    return SetFilePointerEx(hFile, pos, newPos, dwMoveMethod);
-#else
-    LONG lHigh = pos.HighPart;
-    DWORD dwNewPos = SetFilePointer(hFile, pos.LowPart, &lHigh, dwMoveMethod);
-    BOOL fOk = TRUE;
-    if (dwNewPos == 0xFFFFFFFF)
-        if (GetLastError() != NO_ERROR)
-            fOk = FALSE;
-    if ((newPos != NULL) && (fOk))
-    {
-        newPos->LowPart = dwNewPos;
-        newPos->HighPart = lHigh;
-    }
-    return fOk;
-#endif
-}
-
-long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)
-{
-    long ret=-1;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    if (hFile != NULL)
-    {
-        LARGE_INTEGER pos;
-        pos.QuadPart = 0;
-
-        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=(long)pos.LowPart;
-    }
-    return ret;
-}
-
-ZPOS64_T ZCALLBACK win32_tell64_file_func (voidpf opaque, voidpf stream)
-{
-    ZPOS64_T ret= (ZPOS64_T)-1;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream)->hf;
-
-    if (hFile)
-    {
-        LARGE_INTEGER pos;
-        pos.QuadPart = 0;
-
-        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = (ZPOS64_T)-1;
-        }
-        else
-            ret=pos.QuadPart;
-    }
-    return ret;
-}
-
-
-long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)
-{
-    DWORD dwMoveMethod=0xFFFFFFFF;
-    HANDLE hFile = NULL;
-
-    long ret=-1;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        dwMoveMethod = FILE_CURRENT;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        dwMoveMethod = FILE_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        dwMoveMethod = FILE_BEGIN;
-        break;
-    default: return -1;
-    }
-
-    if (hFile != NULL)
-    {
-        LARGE_INTEGER pos;
-        pos.QuadPart = offset;
-        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=0;
-    }
-    return ret;
-}
-
-long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)
-{
-    DWORD dwMoveMethod=0xFFFFFFFF;
-    HANDLE hFile = NULL;
-    long ret=-1;
-
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream)->hf;
-
-    switch (origin)
-    {
-        case ZLIB_FILEFUNC_SEEK_CUR :
-            dwMoveMethod = FILE_CURRENT;
-            break;
-        case ZLIB_FILEFUNC_SEEK_END :
-            dwMoveMethod = FILE_END;
-            break;
-        case ZLIB_FILEFUNC_SEEK_SET :
-            dwMoveMethod = FILE_BEGIN;
-            break;
-        default: return -1;
-    }
-
-    if (hFile)
-    {
-        LARGE_INTEGER pos;
-        pos.QuadPart = offset;
-        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=0;
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_close_file_func (voidpf opaque, voidpf stream)
-{
-    int ret=-1;
-
-    if (stream!=NULL)
-    {
-        HANDLE hFile;
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-        if (hFile != NULL)
-        {
-            CloseHandle(hFile);
-            ret=0;
-        }
-        free(stream);
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_error_file_func (voidpf opaque,voidpf stream)
-{
-    int ret=-1;
-    if (stream!=NULL)
-    {
-        ret = ((WIN32FILE_IOWIN*)stream) -> error;
-    }
-    return ret;
-}
-
-void fill_win32_filefunc (zlib_filefunc_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen_file = win32_open_file_func;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell_file = win32_tell_file_func;
-    pzlib_filefunc_def->zseek_file = win32_seek_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-void fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_func;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-
-void fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-
-void fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
diff --git a/contrib/zlib/contrib/minizip/iowin32.h b/contrib/zlib/contrib/minizip/iowin32.h
deleted file mode 100644
index 0ca0969a7..000000000
--- a/contrib/zlib/contrib/minizip/iowin32.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* iowin32.h -- IO base function header for compress/uncompress .zip
-     Version 1.1, February 14h, 2010
-     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-*/
-
-#include <windows.h>
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void fill_win32_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-void fill_win32_filefunc64 OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64A OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64W OF((zlib_filefunc64_def* pzlib_filefunc_def));
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/contrib/zlib/contrib/minizip/make_vms.com b/contrib/zlib/contrib/minizip/make_vms.com
deleted file mode 100644
index 9ac13a98f..000000000
--- a/contrib/zlib/contrib/minizip/make_vms.com
+++ /dev/null
@@ -1,25 +0,0 @@
-$ if f$search("ioapi.h_orig") .eqs. "" then copy ioapi.h ioapi.h_orig
-$ open/write zdef vmsdefs.h
-$ copy sys$input: zdef
-$ deck
-#define unix
-#define fill_zlib_filefunc64_32_def_from_filefunc32 fillzffunc64from
-#define Write_Zip64EndOfCentralDirectoryLocator Write_Zip64EoDLocator
-#define Write_Zip64EndOfCentralDirectoryRecord Write_Zip64EoDRecord
-#define Write_EndOfCentralDirectoryRecord Write_EoDRecord
-$ eod
-$ close zdef
-$ copy vmsdefs.h,ioapi.h_orig ioapi.h
-$ cc/include=[--]/prefix=all ioapi.c
-$ cc/include=[--]/prefix=all miniunz.c
-$ cc/include=[--]/prefix=all unzip.c
-$ cc/include=[--]/prefix=all minizip.c
-$ cc/include=[--]/prefix=all zip.c
-$ link miniunz,unzip,ioapi,[--]libz.olb/lib
-$ link minizip,zip,ioapi,[--]libz.olb/lib
-$ mcr []minizip test minizip_info.txt
-$ mcr []miniunz -l test.zip
-$ rename minizip_info.txt; minizip_info.txt_old
-$ mcr []miniunz test.zip
-$ delete test.zip;*
-$exit
diff --git a/contrib/zlib/contrib/minizip/miniunz.c b/contrib/zlib/contrib/minizip/miniunz.c
deleted file mode 100644
index 3d65401be..000000000
--- a/contrib/zlib/contrib/minizip/miniunz.c
+++ /dev/null
@@ -1,660 +0,0 @@
-/*
-   miniunz.c
-   Version 1.1, February 14h, 2010
-   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-*/
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-#endif
-
-#ifdef __APPLE__
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef _WIN32
-# include <direct.h>
-# include <io.h>
-#else
-# include <unistd.h>
-# include <utime.h>
-#endif
-
-
-#include "unzip.h"
-
-#define CASESENSITIVITY (0)
-#define WRITEBUFFERSIZE (8192)
-#define MAXFILENAME (256)
-
-#ifdef _WIN32
-#define USEWIN32IOAPI
-#include "iowin32.h"
-#endif
-/*
-  mini unzip, demo of unzip package
-
-  usage :
-  Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]
-
-  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT
-    if it exists
-*/
-
-
-/* change_file_date : change the date/time of a file
-    filename : the filename of the file where date/time must be modified
-    dosdate : the new date at the MSDos format (4 bytes)
-    tmu_date : the SAME new date at the tm_unz format */
-void change_file_date(filename,dosdate,tmu_date)
-    const char *filename;
-    uLong dosdate;
-    tm_unz tmu_date;
-{
-#ifdef _WIN32
-  HANDLE hFile;
-  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;
-
-  hFile = CreateFileA(filename,GENERIC_READ | GENERIC_WRITE,
-                      0,NULL,OPEN_EXISTING,0,NULL);
-  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);
-  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);
-  LocalFileTimeToFileTime(&ftLocal,&ftm);
-  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);
-  CloseHandle(hFile);
-#else
-#ifdef unix || __APPLE__
-  struct utimbuf ut;
-  struct tm newdate;
-  newdate.tm_sec = tmu_date.tm_sec;
-  newdate.tm_min=tmu_date.tm_min;
-  newdate.tm_hour=tmu_date.tm_hour;
-  newdate.tm_mday=tmu_date.tm_mday;
-  newdate.tm_mon=tmu_date.tm_mon;
-  if (tmu_date.tm_year > 1900)
-      newdate.tm_year=tmu_date.tm_year - 1900;
-  else
-      newdate.tm_year=tmu_date.tm_year ;
-  newdate.tm_isdst=-1;
-
-  ut.actime=ut.modtime=mktime(&newdate);
-  utime(filename,&ut);
-#endif
-#endif
-}
-
-
-/* mymkdir and change_file_date are not 100 % portable
-   As I don't know well Unix, I wait feedback for the unix portion */
-
-int mymkdir(dirname)
-    const char* dirname;
-{
-    int ret=0;
-#ifdef _WIN32
-    ret = _mkdir(dirname);
-#elif unix
-    ret = mkdir (dirname,0775);
-#elif __APPLE__
-    ret = mkdir (dirname,0775);
-#endif
-    return ret;
-}
-
-int makedir (newdir)
-    char *newdir;
-{
-  char *buffer ;
-  char *p;
-  int  len = (int)strlen(newdir);
-
-  if (len <= 0)
-    return 0;
-
-  buffer = (char*)malloc(len+1);
-        if (buffer==NULL)
-        {
-                printf("Error allocating memory\n");
-                return UNZ_INTERNALERROR;
-        }
-  strcpy(buffer,newdir);
-
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mymkdir(buffer) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mymkdir(buffer) == -1) && (errno == ENOENT))
-        {
-          printf("couldn't create directory %s\n",buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-void do_banner()
-{
-    printf("MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\n");
-    printf("more info at http://www.winimage.com/zLibDll/unzip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\n\n" \
-           "  -e  Extract without pathname (junk paths)\n" \
-           "  -x  Extract with pathname\n" \
-           "  -v  list files\n" \
-           "  -l  list files\n" \
-           "  -d  directory to extract into\n" \
-           "  -o  overwrite files without prompting\n" \
-           "  -p  extract crypted file using password\n\n");
-}
-
-void Display64BitsSize(ZPOS64_T n, int size_char)
-{
-  /* to avoid compatibility problem , we do here the conversion */
-  char number[21];
-  int offset=19;
-  int pos_string = 19;
-  number[20]=0;
-  for (;;) {
-      number[offset]=(char)((n%10)+'0');
-      if (number[offset] != '0')
-          pos_string=offset;
-      n/=10;
-      if (offset==0)
-          break;
-      offset--;
-  }
-  {
-      int size_display_string = 19-pos_string;
-      while (size_char > size_display_string)
-      {
-          size_char--;
-          printf(" ");
-      }
-  }
-
-  printf("%s",&number[pos_string]);
-}
-
-int do_list(uf)
-    unzFile uf;
-{
-    uLong i;
-    unz_global_info64 gi;
-    int err;
-
-    err = unzGetGlobalInfo64(uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-    printf("  Length  Method     Size Ratio   Date    Time   CRC-32     Name\n");
-    printf("  ------  ------     ---- -----   ----    ----   ------     ----\n");
-    for (i=0;i<gi.number_entry;i++)
-    {
-        char filename_inzip[256];
-        unz_file_info64 file_info;
-        uLong ratio=0;
-        const char *string_method;
-        char charCrypt=' ';
-        err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-            break;
-        }
-        if (file_info.uncompressed_size>0)
-            ratio = (uLong)((file_info.compressed_size*100)/file_info.uncompressed_size);
-
-        /* display a '*' if the file is crypted */
-        if ((file_info.flag & 1) != 0)
-            charCrypt='*';
-
-        if (file_info.compression_method==0)
-            string_method="Stored";
-        else
-        if (file_info.compression_method==Z_DEFLATED)
-        {
-            uInt iLevel=(uInt)((file_info.flag & 0x6)/2);
-            if (iLevel==0)
-              string_method="Defl:N";
-            else if (iLevel==1)
-              string_method="Defl:X";
-            else if ((iLevel==2) || (iLevel==3))
-              string_method="Defl:F"; /* 2:fast , 3 : extra fast*/
-        }
-        else
-        if (file_info.compression_method==Z_BZIP2ED)
-        {
-              string_method="BZip2 ";
-        }
-        else
-            string_method="Unkn. ";
-
-        Display64BitsSize(file_info.uncompressed_size,7);
-        printf("  %6s%c",string_method,charCrypt);
-        Display64BitsSize(file_info.compressed_size,7);
-        printf(" %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n",
-                ratio,
-                (uLong)file_info.tmu_date.tm_mon + 1,
-                (uLong)file_info.tmu_date.tm_mday,
-                (uLong)file_info.tmu_date.tm_year % 100,
-                (uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,
-                (uLong)file_info.crc,filename_inzip);
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-
-int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)
-    unzFile uf;
-    const int* popt_extract_without_path;
-    int* popt_overwrite;
-    const char* password;
-{
-    char filename_inzip[256];
-    char* filename_withoutpath;
-    char* p;
-    int err=UNZ_OK;
-    FILE *fout=NULL;
-    void* buf;
-    uInt size_buf;
-
-    unz_file_info64 file_info;
-    uLong ratio=0;
-    err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-
-    if (err!=UNZ_OK)
-    {
-        printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-        return err;
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return UNZ_INTERNALERROR;
-    }
-
-    p = filename_withoutpath = filename_inzip;
-    while ((*p) != '\0')
-    {
-        if (((*p)=='/') || ((*p)=='\\'))
-            filename_withoutpath = p+1;
-        p++;
-    }
-
-    if ((*filename_withoutpath)=='\0')
-    {
-        if ((*popt_extract_without_path)==0)
-        {
-            printf("creating directory: %s\n",filename_inzip);
-            mymkdir(filename_inzip);
-        }
-    }
-    else
-    {
-        const char* write_filename;
-        int skip=0;
-
-        if ((*popt_extract_without_path)==0)
-            write_filename = filename_inzip;
-        else
-            write_filename = filename_withoutpath;
-
-        err = unzOpenCurrentFilePassword(uf,password);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzOpenCurrentFilePassword\n",err);
-        }
-
-        if (((*popt_overwrite)==0) && (err==UNZ_OK))
-        {
-            char rep=0;
-            FILE* ftestexist;
-            ftestexist = FOPEN_FUNC(write_filename,"rb");
-            if (ftestexist!=NULL)
-            {
-                fclose(ftestexist);
-                do
-                {
-                    char answer[128];
-                    int ret;
-
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: ",write_filename);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1)
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-            }
-
-            if (rep == 'N')
-                skip = 1;
-
-            if (rep == 'A')
-                *popt_overwrite=1;
-        }
-
-        if ((skip==0) && (err==UNZ_OK))
-        {
-            fout=FOPEN_FUNC(write_filename,"wb");
-            /* some zipfile don't contain directory alone before file */
-            if ((fout==NULL) && ((*popt_extract_without_path)==0) &&
-                                (filename_withoutpath!=(char*)filename_inzip))
-            {
-                char c=*(filename_withoutpath-1);
-                *(filename_withoutpath-1)='\0';
-                makedir(write_filename);
-                *(filename_withoutpath-1)=c;
-                fout=FOPEN_FUNC(write_filename,"wb");
-            }
-
-            if (fout==NULL)
-            {
-                printf("error opening %s\n",write_filename);
-            }
-        }
-
-        if (fout!=NULL)
-        {
-            printf(" extracting: %s\n",write_filename);
-
-            do
-            {
-                err = unzReadCurrentFile(uf,buf,size_buf);
-                if (err<0)
-                {
-                    printf("error %d with zipfile in unzReadCurrentFile\n",err);
-                    break;
-                }
-                if (err>0)
-                    if (fwrite(buf,err,1,fout)!=1)
-                    {
-                        printf("error in writing extracted file\n");
-                        err=UNZ_ERRNO;
-                        break;
-                    }
-            }
-            while (err>0);
-            if (fout)
-                    fclose(fout);
-
-            if (err==0)
-                change_file_date(write_filename,file_info.dosDate,
-                                 file_info.tmu_date);
-        }
-
-        if (err==UNZ_OK)
-        {
-            err = unzCloseCurrentFile (uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzCloseCurrentFile\n",err);
-            }
-        }
-        else
-            unzCloseCurrentFile(uf); /* don't lose the error */
-    }
-
-    free(buf);
-    return err;
-}
-
-
-int do_extract(uf,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    uLong i;
-    unz_global_info64 gi;
-    int err;
-    FILE* fout=NULL;
-
-    err = unzGetGlobalInfo64(uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-
-    for (i=0;i<gi.number_entry;i++)
-    {
-        if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) != UNZ_OK)
-            break;
-
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    const char* filename;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    int err = UNZ_OK;
-    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)
-    {
-        printf("file %s not found in the zipfile\n",filename);
-        return 2;
-    }
-
-    if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) == UNZ_OK)
-        return 0;
-    else
-        return 1;
-}
-
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    const char *zipfilename=NULL;
-    const char *filename_to_extract=NULL;
-    const char *password=NULL;
-    char filename_try[MAXFILENAME+16] = "";
-    int i;
-    int ret_value=0;
-    int opt_do_list=0;
-    int opt_do_extract=1;
-    int opt_do_extract_withoutpath=0;
-    int opt_overwrite=0;
-    int opt_extractdir=0;
-    const char *dirname=NULL;
-    unzFile uf=NULL;
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='l') || (c=='L'))
-                        opt_do_list = 1;
-                    if ((c=='v') || (c=='V'))
-                        opt_do_list = 1;
-                    if ((c=='x') || (c=='X'))
-                        opt_do_extract = 1;
-                    if ((c=='e') || (c=='E'))
-                        opt_do_extract = opt_do_extract_withoutpath = 1;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite=1;
-                    if ((c=='d') || (c=='D'))
-                    {
-                        opt_extractdir=1;
-                        dirname=argv[i+1];
-                    }
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-            {
-                if (zipfilename == NULL)
-                    zipfilename = argv[i];
-                else if ((filename_to_extract==NULL) && (!opt_extractdir))
-                        filename_to_extract = argv[i] ;
-            }
-        }
-    }
-
-    if (zipfilename!=NULL)
-    {
-
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc64_def ffunc;
-#        endif
-
-        strncpy(filename_try, zipfilename,MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-#        ifdef USEWIN32IOAPI
-        fill_win32_filefunc64A(&ffunc);
-        uf = unzOpen2_64(zipfilename,&ffunc);
-#        else
-        uf = unzOpen64(zipfilename);
-#        endif
-        if (uf==NULL)
-        {
-            strcat(filename_try,".zip");
-#            ifdef USEWIN32IOAPI
-            uf = unzOpen2_64(filename_try,&ffunc);
-#            else
-            uf = unzOpen64(filename_try);
-#            endif
-        }
-    }
-
-    if (uf==NULL)
-    {
-        printf("Cannot open %s or %s.zip\n",zipfilename,zipfilename);
-        return 1;
-    }
-    printf("%s opened\n",filename_try);
-
-    if (opt_do_list==1)
-        ret_value = do_list(uf);
-    else if (opt_do_extract==1)
-    {
-#ifdef _WIN32
-        if (opt_extractdir && _chdir(dirname))
-#else
-        if (opt_extractdir && chdir(dirname))
-#endif
-        {
-          printf("Error changing into %s, aborting\n", dirname);
-          exit(-1);
-        }
-
-        if (filename_to_extract == NULL)
-            ret_value = do_extract(uf, opt_do_extract_withoutpath, opt_overwrite, password);
-        else
-            ret_value = do_extract_onefile(uf, filename_to_extract, opt_do_extract_withoutpath, opt_overwrite, password);
-    }
-
-    unzClose(uf);
-
-    return ret_value;
-}
diff --git a/contrib/zlib/contrib/minizip/miniunzip.1 b/contrib/zlib/contrib/minizip/miniunzip.1
deleted file mode 100644
index 111ac6919..000000000
--- a/contrib/zlib/contrib/minizip/miniunzip.1
+++ /dev/null
@@ -1,63 +0,0 @@
-.\"                                      Hey, EMACS: -*- nroff -*-
-.TH miniunzip 1 "Nov 7, 2001"
-.\" Please adjust this date whenever revising the manpage.
-.\"
-.\" Some roff macros, for reference:
-.\" .nh        disable hyphenation
-.\" .hy        enable hyphenation
-.\" .ad l      left justify
-.\" .ad b      justify to both left and right margins
-.\" .nf        disable filling
-.\" .fi        enable filling
-.\" .br        insert line break
-.\" .sp <n>    insert n+1 empty lines
-.\" for manpage-specific macros, see man(7)
-.SH NAME
-miniunzip - uncompress and examine ZIP archives
-.SH SYNOPSIS
-.B miniunzip
-.RI [ -exvlo ]
-zipfile [ files_to_extract ] [-d tempdir]
-.SH DESCRIPTION
-.B minizip
-is a simple tool which allows the extraction of compressed file
-archives in the ZIP format used by the MS-DOS utility PKZIP.  It was
-written as a demonstration of the
-.IR zlib (3)
-library and therefore lack many of the features of the
-.IR unzip (1)
-program.
-.SH OPTIONS
-A number of options are supported.  With the exception of
-.BI \-d\  tempdir
-these must be supplied before any
-other arguments and are:
-.TP
-.BI \-l\ ,\ \-\-v
-List the files in the archive without extracting them.
-.TP
-.B \-o
-Overwrite files without prompting for confirmation.
-.TP
-.B \-x
-Extract files (default).
-.PP
-The
-.I zipfile
-argument is the name of the archive to process. The next argument can be used
-to specify a single file to extract from the archive.
-
-Lastly, the following option can be specified at the end of the command-line:
-.TP
-.BI \-d\  tempdir
-Extract the archive in the directory
-.I tempdir
-rather than the current directory.
-.SH SEE ALSO
-.BR minizip (1),
-.BR zlib (3),
-.BR unzip (1).
-.SH AUTHOR
-This program was written by Gilles Vollant.  This manual page was
-written by Mark Brown <broonie@sirena.org.uk>. The -d tempdir option
-was added by Dirk Eddelbuettel <edd@debian.org>.
diff --git a/contrib/zlib/contrib/minizip/minizip.1 b/contrib/zlib/contrib/minizip/minizip.1
deleted file mode 100644
index 1154484c1..000000000
--- a/contrib/zlib/contrib/minizip/minizip.1
+++ /dev/null
@@ -1,46 +0,0 @@
-.\"                                      Hey, EMACS: -*- nroff -*-
-.TH minizip 1 "May 2, 2001"
-.\" Please adjust this date whenever revising the manpage.
-.\"
-.\" Some roff macros, for reference:
-.\" .nh        disable hyphenation
-.\" .hy        enable hyphenation
-.\" .ad l      left justify
-.\" .ad b      justify to both left and right margins
-.\" .nf        disable filling
-.\" .fi        enable filling
-.\" .br        insert line break
-.\" .sp <n>    insert n+1 empty lines
-.\" for manpage-specific macros, see man(7)
-.SH NAME
-minizip - create ZIP archives
-.SH SYNOPSIS
-.B minizip
-.RI [ -o ]
-zipfile [ " files" ... ]
-.SH DESCRIPTION
-.B minizip
-is a simple tool which allows the creation of compressed file archives
-in the ZIP format used by the MS-DOS utility PKZIP.  It was written as
-a demonstration of the
-.IR zlib (3)
-library and therefore lack many of the features of the
-.IR zip (1)
-program.
-.SH OPTIONS
-The first argument supplied is the name of the ZIP archive to create or
-.RI -o
-in which case it is ignored and the second argument treated as the
-name of the ZIP file.  If the ZIP file already exists it will be
-overwritten.
-.PP
-Subsequent arguments specify a list of files to place in the ZIP
-archive.  If none are specified then an empty archive will be created.
-.SH SEE ALSO
-.BR miniunzip (1),
-.BR zlib (3),
-.BR zip (1).
-.SH AUTHOR
-This program was written by Gilles Vollant.  This manual page was
-written by Mark Brown <broonie@sirena.org.uk>.
-
diff --git a/contrib/zlib/contrib/minizip/minizip.c b/contrib/zlib/contrib/minizip/minizip.c
deleted file mode 100644
index 4288962ec..000000000
--- a/contrib/zlib/contrib/minizip/minizip.c
+++ /dev/null
@@ -1,520 +0,0 @@
-/*
-   minizip.c
-   Version 1.1, February 14h, 2010
-   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-*/
-
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-#endif
-
-#ifdef __APPLE__
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef _WIN32
-# include <direct.h>
-# include <io.h>
-#else
-# include <unistd.h>
-# include <utime.h>
-# include <sys/types.h>
-# include <sys/stat.h>
-#endif
-
-#include "zip.h"
-
-#ifdef _WIN32
-        #define USEWIN32IOAPI
-        #include "iowin32.h"
-#endif
-
-
-
-#define WRITEBUFFERSIZE (16384)
-#define MAXFILENAME (256)
-
-#ifdef _WIN32
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret = 0;
-  {
-      FILETIME ftLocal;
-      HANDLE hFind;
-      WIN32_FIND_DATAA ff32;
-
-      hFind = FindFirstFileA(f,&ff32);
-      if (hFind != INVALID_HANDLE_VALUE)
-      {
-        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);
-        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);
-        FindClose(hFind);
-        ret = 1;
-      }
-  }
-  return ret;
-}
-#else
-#ifdef unix || __APPLE__
-uLong filetime(f, tmzip, dt)
-    char *f;               /* name of file to get info on */
-    tm_zip *tmzip;         /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret=0;
-  struct stat s;        /* results of stat() */
-  struct tm* filedate;
-  time_t tm_t=0;
-
-  if (strcmp(f,"-")!=0)
-  {
-    char name[MAXFILENAME+1];
-    int len = strlen(f);
-    if (len > MAXFILENAME)
-      len = MAXFILENAME;
-
-    strncpy(name, f,MAXFILENAME-1);
-    /* strncpy doesnt append the trailing NULL, of the string is too long. */
-    name[ MAXFILENAME ] = '\0';
-
-    if (name[len - 1] == '/')
-      name[len - 1] = '\0';
-    /* not all systems allow stat'ing a file with / appended */
-    if (stat(name,&s)==0)
-    {
-      tm_t = s.st_mtime;
-      ret = 1;
-    }
-  }
-  filedate = localtime(&tm_t);
-
-  tmzip->tm_sec  = filedate->tm_sec;
-  tmzip->tm_min  = filedate->tm_min;
-  tmzip->tm_hour = filedate->tm_hour;
-  tmzip->tm_mday = filedate->tm_mday;
-  tmzip->tm_mon  = filedate->tm_mon ;
-  tmzip->tm_year = filedate->tm_year;
-
-  return ret;
-}
-#else
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-    return 0;
-}
-#endif
-#endif
-
-
-
-
-int check_exist_file(filename)
-    const char* filename;
-{
-    FILE* ftestexist;
-    int ret = 1;
-    ftestexist = FOPEN_FUNC(filename,"rb");
-    if (ftestexist==NULL)
-        ret = 0;
-    else
-        fclose(ftestexist);
-    return ret;
-}
-
-void do_banner()
-{
-    printf("MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\n");
-    printf("more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\n\n" \
-           "  -o  Overwrite existing file.zip\n" \
-           "  -a  Append to existing file.zip\n" \
-           "  -0  Store only\n" \
-           "  -1  Compress faster\n" \
-           "  -9  Compress better\n\n" \
-           "  -j  exclude path. store only the file name.\n\n");
-}
-
-/* calculate the CRC32 of a file,
-   because to encrypt a file, we need known the CRC32 of the file before */
-int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)
-{
-   unsigned long calculate_crc=0;
-   int err=ZIP_OK;
-   FILE * fin = FOPEN_FUNC(filenameinzip,"rb");
-
-   unsigned long size_read = 0;
-   unsigned long total_read = 0;
-   if (fin==NULL)
-   {
-       err = ZIP_ERRNO;
-   }
-
-    if (err == ZIP_OK)
-        do
-        {
-            err = ZIP_OK;
-            size_read = (int)fread(buf,1,size_buf,fin);
-            if (size_read < size_buf)
-                if (feof(fin)==0)
-            {
-                printf("error in reading %s\n",filenameinzip);
-                err = ZIP_ERRNO;
-            }
-
-            if (size_read>0)
-                calculate_crc = crc32(calculate_crc,buf,size_read);
-            total_read += size_read;
-
-        } while ((err == ZIP_OK) && (size_read>0));
-
-    if (fin)
-        fclose(fin);
-
-    *result_crc=calculate_crc;
-    printf("file %s crc %lx\n", filenameinzip, calculate_crc);
-    return err;
-}
-
-int isLargeFile(const char* filename)
-{
-  int largeFile = 0;
-  ZPOS64_T pos = 0;
-  FILE* pFile = FOPEN_FUNC(filename, "rb");
-
-  if(pFile != NULL)
-  {
-    int n = FSEEKO_FUNC(pFile, 0, SEEK_END);
-    pos = FTELLO_FUNC(pFile);
-
-                printf("File : %s is %lld bytes\n", filename, pos);
-
-    if(pos >= 0xffffffff)
-     largeFile = 1;
-
-                fclose(pFile);
-  }
-
- return largeFile;
-}
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    int i;
-    int opt_overwrite=0;
-    int opt_compress_level=Z_DEFAULT_COMPRESSION;
-    int opt_exclude_path=0;
-    int zipfilenamearg = 0;
-    char filename_try[MAXFILENAME+16];
-    int zipok;
-    int err=0;
-    int size_buf=0;
-    void* buf=NULL;
-    const char* password=NULL;
-
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite = 1;
-                    if ((c=='a') || (c=='A'))
-                        opt_overwrite = 2;
-                    if ((c>='0') && (c<='9'))
-                        opt_compress_level = c-'0';
-                    if ((c=='j') || (c=='J'))
-                        opt_exclude_path = 1;
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-            {
-                if (zipfilenamearg == 0)
-                {
-                    zipfilenamearg = i ;
-                }
-            }
-        }
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return ZIP_INTERNALERROR;
-    }
-
-    if (zipfilenamearg==0)
-    {
-        zipok=0;
-    }
-    else
-    {
-        int i,len;
-        int dot_found=0;
-
-        zipok = 1 ;
-        strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-        len=(int)strlen(filename_try);
-        for (i=0;i<len;i++)
-            if (filename_try[i]=='.')
-                dot_found=1;
-
-        if (dot_found==0)
-            strcat(filename_try,".zip");
-
-        if (opt_overwrite==2)
-        {
-            /* if the file don't exist, we not append file */
-            if (check_exist_file(filename_try)==0)
-                opt_overwrite=1;
-        }
-        else
-        if (opt_overwrite==0)
-            if (check_exist_file(filename_try)!=0)
-            {
-                char rep=0;
-                do
-                {
-                    char answer[128];
-                    int ret;
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : ",filename_try);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1)
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-                if (rep=='N')
-                    zipok = 0;
-                if (rep=='A')
-                    opt_overwrite = 2;
-            }
-    }
-
-    if (zipok==1)
-    {
-        zipFile zf;
-        int errclose;
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc64_def ffunc;
-        fill_win32_filefunc64A(&ffunc);
-        zf = zipOpen2_64(filename_try,(opt_overwrite==2) ? 2 : 0,NULL,&ffunc);
-#        else
-        zf = zipOpen64(filename_try,(opt_overwrite==2) ? 2 : 0);
-#        endif
-
-        if (zf == NULL)
-        {
-            printf("error opening %s\n",filename_try);
-            err= ZIP_ERRNO;
-        }
-        else
-            printf("creating %s\n",filename_try);
-
-        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)
-        {
-            if (!((((*(argv[i]))=='-') || ((*(argv[i]))=='/')) &&
-                  ((argv[i][1]=='o') || (argv[i][1]=='O') ||
-                   (argv[i][1]=='a') || (argv[i][1]=='A') ||
-                   (argv[i][1]=='p') || (argv[i][1]=='P') ||
-                   ((argv[i][1]>='0') || (argv[i][1]<='9'))) &&
-                  (strlen(argv[i]) == 2)))
-            {
-                FILE * fin;
-                int size_read;
-                const char* filenameinzip = argv[i];
-                const char *savefilenameinzip;
-                zip_fileinfo zi;
-                unsigned long crcFile=0;
-                int zip64 = 0;
-
-                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =
-                zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;
-                zi.dosDate = 0;
-                zi.internal_fa = 0;
-                zi.external_fa = 0;
-                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);
-
-/*
-                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL / * comment * /,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level);
-*/
-                if ((password != NULL) && (err==ZIP_OK))
-                    err = getFileCrc(filenameinzip,buf,size_buf,&crcFile);
-
-                zip64 = isLargeFile(filenameinzip);
-
-                                                         /* The path name saved, should not include a leading slash. */
-               /*if it did, windows/xp and dynazip couldn't read the zip file. */
-                 savefilenameinzip = filenameinzip;
-                 while( savefilenameinzip[0] == '\\' || savefilenameinzip[0] == '/' )
-                 {
-                     savefilenameinzip++;
-                 }
-
-                 /*should the zip file contain any path at all?*/
-                 if( opt_exclude_path )
-                 {
-                     const char *tmpptr;
-                     const char *lastslash = 0;
-                     for( tmpptr = savefilenameinzip; *tmpptr; tmpptr++)
-                     {
-                         if( *tmpptr == '\\' || *tmpptr == '/')
-                         {
-                             lastslash = tmpptr;
-                         }
-                     }
-                     if( lastslash != NULL )
-                     {
-                         savefilenameinzip = lastslash+1; // base filename follows last slash.
-                     }
-                 }
-
-                 /**/
-                err = zipOpenNewFileInZip3_64(zf,savefilenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL /* comment*/,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level,0,
-                                 /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 password,crcFile, zip64);
-
-                if (err != ZIP_OK)
-                    printf("error in opening %s in zipfile\n",filenameinzip);
-                else
-                {
-                    fin = FOPEN_FUNC(filenameinzip,"rb");
-                    if (fin==NULL)
-                    {
-                        err=ZIP_ERRNO;
-                        printf("error in opening %s for reading\n",filenameinzip);
-                    }
-                }
-
-                if (err == ZIP_OK)
-                    do
-                    {
-                        err = ZIP_OK;
-                        size_read = (int)fread(buf,1,size_buf,fin);
-                        if (size_read < size_buf)
-                            if (feof(fin)==0)
-                        {
-                            printf("error in reading %s\n",filenameinzip);
-                            err = ZIP_ERRNO;
-                        }
-
-                        if (size_read>0)
-                        {
-                            err = zipWriteInFileInZip (zf,buf,size_read);
-                            if (err<0)
-                            {
-                                printf("error in writing %s in the zipfile\n",
-                                                 filenameinzip);
-                            }
-
-                        }
-                    } while ((err == ZIP_OK) && (size_read>0));
-
-                if (fin)
-                    fclose(fin);
-
-                if (err<0)
-                    err=ZIP_ERRNO;
-                else
-                {
-                    err = zipCloseFileInZip(zf);
-                    if (err!=ZIP_OK)
-                        printf("error in closing %s in the zipfile\n",
-                                    filenameinzip);
-                }
-            }
-        }
-        errclose = zipClose(zf,NULL);
-        if (errclose != ZIP_OK)
-            printf("error in closing %s\n",filename_try);
-    }
-    else
-    {
-       do_help();
-    }
-
-    free(buf);
-    return 0;
-}
diff --git a/contrib/zlib/contrib/minizip/minizip.pc.in b/contrib/zlib/contrib/minizip/minizip.pc.in
deleted file mode 100644
index 69b5b7fdc..000000000
--- a/contrib/zlib/contrib/minizip/minizip.pc.in
+++ /dev/null
@@ -1,12 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@/minizip
-
-Name: minizip
-Description: Minizip zip file manipulation library
-Requires:
-Version: @PACKAGE_VERSION@
-Libs: -L${libdir} -lminizip
-Libs.private: -lz
-Cflags: -I${includedir}
diff --git a/contrib/zlib/contrib/minizip/mztools.c b/contrib/zlib/contrib/minizip/mztools.c
deleted file mode 100644
index 96891c2e0..000000000
--- a/contrib/zlib/contrib/minizip/mztools.c
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-/* Code */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-#include "unzip.h"
-
-#define READ_8(adr)  ((unsigned char)*(adr))
-#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )
-#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )
-
-#define WRITE_8(buff, n) do { \
-  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \
-} while(0)
-#define WRITE_16(buff, n) do { \
-  WRITE_8((unsigned char*)(buff), n); \
-  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \
-} while(0)
-#define WRITE_32(buff, n) do { \
-  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \
-  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \
-} while(0)
-
-extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)
-const char* file;
-const char* fileOut;
-const char* fileOutTmp;
-uLong* nRecovered;
-uLong* bytesRecovered;
-{
-  int err = Z_OK;
-  FILE* fpZip = fopen(file, "rb");
-  FILE* fpOut = fopen(fileOut, "wb");
-  FILE* fpOutCD = fopen(fileOutTmp, "wb");
-  if (fpZip != NULL &&  fpOut != NULL) {
-    int entries = 0;
-    uLong totalBytes = 0;
-    char header[30];
-    char filename[1024];
-    char extra[1024];
-    int offset = 0;
-    int offsetCD = 0;
-    while ( fread(header, 1, 30, fpZip) == 30 ) {
-      int currentOffset = offset;
-
-      /* File entry */
-      if (READ_32(header) == 0x04034b50) {
-        unsigned int version = READ_16(header + 4);
-        unsigned int gpflag = READ_16(header + 6);
-        unsigned int method = READ_16(header + 8);
-        unsigned int filetime = READ_16(header + 10);
-        unsigned int filedate = READ_16(header + 12);
-        unsigned int crc = READ_32(header + 14); /* crc */
-        unsigned int cpsize = READ_32(header + 18); /* compressed size */
-        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */
-        unsigned int fnsize = READ_16(header + 26); /* file name length */
-        unsigned int extsize = READ_16(header + 28); /* extra field length */
-        filename[0] = extra[0] = '\0';
-
-        /* Header */
-        if (fwrite(header, 1, 30, fpOut) == 30) {
-          offset += 30;
-        } else {
-          err = Z_ERRNO;
-          break;
-        }
-
-        /* Filename */
-        if (fnsize > 0) {
-          if (fnsize < sizeof(filename)) {
-            if (fread(filename, 1, fnsize, fpZip) == fnsize) {
-                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {
-                offset += fnsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        } else {
-          err = Z_STREAM_ERROR;
-          break;
-        }
-
-        /* Extra field */
-        if (extsize > 0) {
-          if (extsize < sizeof(extra)) {
-            if (fread(extra, 1, extsize, fpZip) == extsize) {
-              if (fwrite(extra, 1, extsize, fpOut) == extsize) {
-                offset += extsize;
-                } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-
-        /* Data */
-        {
-          int dataSize = cpsize;
-          if (dataSize == 0) {
-            dataSize = uncpsize;
-          }
-          if (dataSize > 0) {
-            char* data = malloc(dataSize);
-            if (data != NULL) {
-              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {
-                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {
-                  offset += dataSize;
-                  totalBytes += dataSize;
-                } else {
-                  err = Z_ERRNO;
-                }
-              } else {
-                err = Z_ERRNO;
-              }
-              free(data);
-              if (err != Z_OK) {
-                break;
-              }
-            } else {
-              err = Z_MEM_ERROR;
-              break;
-            }
-          }
-        }
-
-        /* Central directory entry */
-        {
-          char header[46];
-          char* comment = "";
-          int comsize = (int) strlen(comment);
-          WRITE_32(header, 0x02014b50);
-          WRITE_16(header + 4, version);
-          WRITE_16(header + 6, version);
-          WRITE_16(header + 8, gpflag);
-          WRITE_16(header + 10, method);
-          WRITE_16(header + 12, filetime);
-          WRITE_16(header + 14, filedate);
-          WRITE_32(header + 16, crc);
-          WRITE_32(header + 20, cpsize);
-          WRITE_32(header + 24, uncpsize);
-          WRITE_16(header + 28, fnsize);
-          WRITE_16(header + 30, extsize);
-          WRITE_16(header + 32, comsize);
-          WRITE_16(header + 34, 0);     /* disk # */
-          WRITE_16(header + 36, 0);     /* int attrb */
-          WRITE_32(header + 38, 0);     /* ext attrb */
-          WRITE_32(header + 42, currentOffset);
-          /* Header */
-          if (fwrite(header, 1, 46, fpOutCD) == 46) {
-            offsetCD += 46;
-
-            /* Filename */
-            if (fnsize > 0) {
-              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {
-                offsetCD += fnsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_STREAM_ERROR;
-              break;
-            }
-
-            /* Extra field */
-            if (extsize > 0) {
-              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {
-                offsetCD += extsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-
-            /* Comment field */
-            if (comsize > 0) {
-              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {
-                offsetCD += comsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-
-
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-
-        /* Success */
-        entries++;
-
-      } else {
-        break;
-      }
-    }
-
-    /* Final central directory  */
-    {
-      int entriesZip = entries;
-      char header[22];
-      char* comment = ""; // "ZIP File recovered by zlib/minizip/mztools";
-      int comsize = (int) strlen(comment);
-      if (entriesZip > 0xffff) {
-        entriesZip = 0xffff;
-      }
-      WRITE_32(header, 0x06054b50);
-      WRITE_16(header + 4, 0);    /* disk # */
-      WRITE_16(header + 6, 0);    /* disk # */
-      WRITE_16(header + 8, entriesZip);   /* hack */
-      WRITE_16(header + 10, entriesZip);  /* hack */
-      WRITE_32(header + 12, offsetCD);    /* size of CD */
-      WRITE_32(header + 16, offset);      /* offset to CD */
-      WRITE_16(header + 20, comsize);     /* comment */
-
-      /* Header */
-      if (fwrite(header, 1, 22, fpOutCD) == 22) {
-
-        /* Comment field */
-        if (comsize > 0) {
-          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {
-            err = Z_ERRNO;
-          }
-        }
-
-      } else {
-        err = Z_ERRNO;
-      }
-    }
-
-    /* Final merge (file + central directory) */
-    fclose(fpOutCD);
-    if (err == Z_OK) {
-      fpOutCD = fopen(fileOutTmp, "rb");
-      if (fpOutCD != NULL) {
-        int nRead;
-        char buffer[8192];
-        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {
-          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-        fclose(fpOutCD);
-      }
-    }
-
-    /* Close */
-    fclose(fpZip);
-    fclose(fpOut);
-
-    /* Wipe temporary file */
-    (void)remove(fileOutTmp);
-
-    /* Number of recovered entries */
-    if (err == Z_OK) {
-      if (nRecovered != NULL) {
-        *nRecovered = entries;
-      }
-      if (bytesRecovered != NULL) {
-        *bytesRecovered = totalBytes;
-      }
-    }
-  } else {
-    err = Z_STREAM_ERROR;
-  }
-  return err;
-}
diff --git a/contrib/zlib/contrib/minizip/mztools.h b/contrib/zlib/contrib/minizip/mztools.h
deleted file mode 100644
index a49a426ec..000000000
--- a/contrib/zlib/contrib/minizip/mztools.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-#ifndef _zip_tools_H
-#define _zip_tools_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#include "unzip.h"
-
-/* Repair a ZIP file (missing central directory)
-   file: file to recover
-   fileOut: output file after recovery
-   fileOutTmp: temporary file name used for recovery
-*/
-extern int ZEXPORT unzRepair(const char* file,
-                             const char* fileOut,
-                             const char* fileOutTmp,
-                             uLong* nRecovered,
-                             uLong* bytesRecovered);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
diff --git a/contrib/zlib/contrib/minizip/unzip.c b/contrib/zlib/contrib/minizip/unzip.c
deleted file mode 100644
index bcfb9416e..000000000
--- a/contrib/zlib/contrib/minizip/unzip.c
+++ /dev/null
@@ -1,2125 +0,0 @@
-/* unzip.c -- IO for uncompress .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-
-  ------------------------------------------------------------------------------------
-  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
-  compatibility with older software. The following is from the original crypt.c.
-  Code woven in by Terry Thorsen 1/2003.
-
-  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
-
-  See the accompanying file LICENSE, version 2000-Apr-09 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, all these files are missing, the Info-ZIP license
-  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
-
-        crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
-
-  The encryption/decryption parts of this source code (as opposed to the
-  non-echoing password parts) were originally written in Europe.  The
-  whole source package can be freely distributed, including from the USA.
-  (Prior to January 2000, re-export from the US was a violation of US law.)
-
-        This encryption code is a direct transcription of the algorithm from
-  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-  file (appnote.txt) is distributed with the PKZIP program (even in the
-  version without encryption capabilities).
-
-        ------------------------------------------------------------------------------------
-
-        Changes in unzip.c
-
-        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos
-  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*
-  2007-2008 - Even Rouault - Remove old C style function prototypes
-  2007-2008 - Even Rouault - Add unzip support for ZIP64
-
-        Copyright (C) 2007-2008 Even Rouault
-
-
-        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).
-  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
-                                should only read the compressed/uncompressed size from the Zip64 format if
-                                the size from normal header was 0xFFFFFFFF
-  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
-        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
-                                Patch created by Daniel Borca
-
-  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
-
-  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson
-
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#ifndef NOUNCRYPT
-        #define NOUNCRYPT
-#endif
-
-#include "zlib.h"
-#include "unzip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-
-#ifndef CASESENSITIVITYDEFAULT_NO
-#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
-#    define CASESENSITIVITYDEFAULT_NO
-#  endif
-#endif
-
-
-#ifndef UNZ_BUFSIZE
-#define UNZ_BUFSIZE (16384)
-#endif
-
-#ifndef UNZ_MAXFILENAMEINZIP
-#define UNZ_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-
-
-const char unz_copyright[] =
-   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-/* unz_file_info_interntal contain internal info about a file in zipfile*/
-typedef struct unz_file_info64_internal_s
-{
-    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */
-} unz_file_info64_internal;
-
-
-/* file_in_zip_read_info_s contain internal information about a file in zipfile,
-    when reading and decompress it */
-typedef struct
-{
-    char  *read_buffer;         /* internal buffer for compressed data */
-    z_stream stream;            /* zLib stream structure for inflate */
-
-#ifdef HAVE_BZIP2
-    bz_stream bstream;          /* bzLib stream structure for bziped */
-#endif
-
-    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
-    uLong stream_initialised;   /* flag set if stream structure is initialised*/
-
-    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */
-    uInt  size_local_extrafield;/* size of the local extra field */
-    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/
-    ZPOS64_T total_out_64;
-
-    uLong crc32;                /* crc32 of all data uncompressed */
-    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
-    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
-    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
-    zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    uLong compression_method;   /* compression method (0==store) */
-    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    int   raw;
-} file_in_zip64_read_info_s;
-
-
-/* unz64_s contain internal information about the zipfile
-*/
-typedef struct
-{
-    zlib_filefunc64_32_def z_filefunc;
-    int is64bitOpenFunction;
-    voidpf filestream;        /* io structore of the zipfile */
-    unz_global_info64 gi;       /* public global information */
-    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    ZPOS64_T num_file;             /* number of the current file in the zipfile*/
-    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/
-    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/
-    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/
-
-    ZPOS64_T size_central_dir;     /* size of the central directory  */
-    ZPOS64_T offset_central_dir;   /* offset of start of central directory with
-                                   respect to the starting disk number */
-
-    unz_file_info64 cur_file_info; /* public info about the current file in zip*/
-    unz_file_info64_internal cur_file_info_internal; /* private info about it*/
-    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current
-                                        file if we are decompressing it */
-    int encrypted;
-
-    int isZip64;
-
-#    ifndef NOUNCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const z_crc_t* pcrc_32_tab;
-#    endif
-} unz64_s;
-
-
-#ifndef NOUNCRYPT
-#include "crypt.h"
-#endif
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been successfully opened for reading.
-*/
-
-
-local int unz64local_getByte OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)
-{
-    unsigned char c;
-    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return UNZ_OK;
-    }
-    else
-    {
-        if (ZERROR64(*pzlib_filefunc_def,filestream))
-            return UNZ_ERRNO;
-        else
-            return UNZ_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int unz64local_getShort OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                             voidpf filestream,
-                             uLong *pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unz64local_getLong OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                            voidpf filestream,
-                            uLong *pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unz64local_getLong64 OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    ZPOS64_T *pX));
-
-
-local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                            voidpf filestream,
-                            ZPOS64_T *pX)
-{
-    ZPOS64_T x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (ZPOS64_T)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<24;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<32;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<40;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<48;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<56;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-/* My own strcmpi / strcasecmp */
-local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)
-{
-    for (;;)
-    {
-        char c1=*(fileName1++);
-        char c2=*(fileName2++);
-        if ((c1>='a') && (c1<='z'))
-            c1 -= 0x20;
-        if ((c2>='a') && (c2<='z'))
-            c2 -= 0x20;
-        if (c1=='\0')
-            return ((c2=='\0') ? 0 : -1);
-        if (c2=='\0')
-            return 1;
-        if (c1<c2)
-            return -1;
-        if (c1>c2)
-            return 1;
-    }
-}
-
-
-#ifdef  CASESENSITIVITYDEFAULT_NO
-#define CASESENSITIVITYDEFAULTVALUE 2
-#else
-#define CASESENSITIVITYDEFAULTVALUE 1
-#endif
-
-#ifndef STRCMPCASENOSENTIVEFUNCTION
-#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
-#endif
-
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-        (like 1 on Unix, 2 on Windows)
-
-*/
-extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,
-                                                 const char*  fileName2,
-                                                 int iCaseSensitivity)
-
-{
-    if (iCaseSensitivity==0)
-        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
-
-    if (iCaseSensitivity==1)
-        return strcmp(fileName1,fileName2);
-
-    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-    unsigned char* buf;
-    ZPOS64_T uSizeFile;
-    ZPOS64_T uBackRead;
-    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-    ZPOS64_T uPosFound=0;
-
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize;
-        ZPOS64_T uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-
-
-/*
-  Locate the Central directory 64 of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T unz64local_SearchCentralDir64 OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                                      voidpf filestream)
-{
-    unsigned char* buf;
-    ZPOS64_T uSizeFile;
-    ZPOS64_T uBackRead;
-    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-    ZPOS64_T uPosFound=0;
-    uLong uL;
-                ZPOS64_T relativeOffset;
-
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize;
-        ZPOS64_T uReadPos;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    if (uPosFound == 0)
-        return 0;
-
-    /* Zip64 end of central directory locator */
-    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return 0;
-
-    /* the signature, already checked */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-
-    /* number of the disk with the start of the zip64 end of  central directory */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-    if (uL != 0)
-        return 0;
-
-    /* relative offset of the zip64 end of central directory record */
-    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)
-        return 0;
-
-    /* total number of disks */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-    if (uL != 1)
-        return 0;
-
-    /* Goto end of central directory record */
-    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return 0;
-
-     /* the signature */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-
-    if (uL != 0x06064b50)
-        return 0;
-
-    return relativeOffset;
-}
-
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
-     "zlib/zlib114.zip".
-     If the zipfile cannot be opened (file doesn't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-local unzFile unzOpenInternal (const void *path,
-                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
-                               int is64bitOpenFunction)
-{
-    unz64_s us;
-    unz64_s *s;
-    ZPOS64_T central_pos;
-    uLong   uL;
-
-    uLong number_disk;          /* number of the current dist, used for
-                                   spaning ZIP, unsupported, always 0*/
-    uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                   for spaning ZIP, unsupported, always 0*/
-    ZPOS64_T number_entry_CD;      /* total number of entries in
-                                   the central dir
-                                   (same than number_entry on nospan) */
-
-    int err=UNZ_OK;
-
-    if (unz_copyright[0]!=' ')
-        return NULL;
-
-    us.z_filefunc.zseek32_file = NULL;
-    us.z_filefunc.ztell32_file = NULL;
-    if (pzlib_filefunc64_32_def==NULL)
-        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);
-    else
-        us.z_filefunc = *pzlib_filefunc64_32_def;
-    us.is64bitOpenFunction = is64bitOpenFunction;
-
-
-
-    us.filestream = ZOPEN64(us.z_filefunc,
-                                                 path,
-                                                 ZLIB_FILEFUNC_MODE_READ |
-                                                 ZLIB_FILEFUNC_MODE_EXISTING);
-    if (us.filestream==NULL)
-        return NULL;
-
-    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);
-    if (central_pos)
-    {
-        uLong uS;
-        ZPOS64_T uL64;
-
-        us.isZip64 = 1;
-
-        if (ZSEEK64(us.z_filefunc, us.filestream,
-                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-        /* the signature, already checked */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* size of zip64 end of central directory record */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* version made by */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* version needed to extract */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of this disk */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central directory on this disk */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central directory */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        if ((number_entry_CD!=us.gi.number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=UNZ_BADZIPFILE;
-
-        /* size of the central directory */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* offset of start of central directory with respect to the
-          starting disk number */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        us.gi.size_comment = 0;
-    }
-    else
-    {
-        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);
-        if (central_pos==0)
-            err=UNZ_ERRNO;
-
-        us.isZip64 = 0;
-
-        if (ZSEEK64(us.z_filefunc, us.filestream,
-                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=UNZ_ERRNO;
-
-        /* the signature, already checked */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of this disk */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central dir on this disk */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.gi.number_entry = uL;
-
-        /* total number of entries in the central dir */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        number_entry_CD = uL;
-
-        if ((number_entry_CD!=us.gi.number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=UNZ_BADZIPFILE;
-
-        /* size of the central directory */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.size_central_dir = uL;
-
-        /* offset of start of central directory with respect to the
-            starting disk number */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.offset_central_dir = uL;
-
-        /* zipfile comment length */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
-            err=UNZ_ERRNO;
-    }
-
-    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
-        (err==UNZ_OK))
-        err=UNZ_BADZIPFILE;
-
-    if (err!=UNZ_OK)
-    {
-        ZCLOSE64(us.z_filefunc, us.filestream);
-        return NULL;
-    }
-
-    us.byte_before_the_zipfile = central_pos -
-                            (us.offset_central_dir+us.size_central_dir);
-    us.central_pos = central_pos;
-    us.pfile_in_zip_read = NULL;
-    us.encrypted = 0;
-
-
-    s=(unz64_s*)ALLOC(sizeof(unz64_s));
-    if( s != NULL)
-    {
-        *s=us;
-        unzGoToFirstFile((unzFile)s);
-    }
-    return (unzFile)s;
-}
-
-
-extern unzFile ZEXPORT unzOpen2 (const char *path,
-                                        zlib_filefunc_def* pzlib_filefunc32_def)
-{
-    if (pzlib_filefunc32_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);
-    }
-    else
-        return unzOpenInternal(path, NULL, 0);
-}
-
-extern unzFile ZEXPORT unzOpen2_64 (const void *path,
-                                     zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    if (pzlib_filefunc_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
-        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
-        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);
-    }
-    else
-        return unzOpenInternal(path, NULL, 1);
-}
-
-extern unzFile ZEXPORT unzOpen (const char *path)
-{
-    return unzOpenInternal(path, NULL, 0);
-}
-
-extern unzFile ZEXPORT unzOpen64 (const void *path)
-{
-    return unzOpenInternal(path, NULL, 1);
-}
-
-/*
-  Close a ZipFile opened with unzOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzCloseCurrentFile before call unzClose.
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzClose (unzFile file)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    if (s->pfile_in_zip_read!=NULL)
-        unzCloseCurrentFile(file);
-
-    ZCLOSE64(s->z_filefunc, s->filestream);
-    TRYFREE(s);
-    return UNZ_OK;
-}
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    *pglobal_info=s->gi;
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGetGlobalInfo (unzFile file, unz_global_info* pglobal_info32)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    /* to do : check if number_entry is not truncated */
-    pglobal_info32->number_entry = (uLong)s->gi.number_entry;
-    pglobal_info32->size_comment = s->gi.size_comment;
-    return UNZ_OK;
-}
-/*
-   Translate date/time from Dos format to tm_unz (readable more easilty)
-*/
-local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
-{
-    ZPOS64_T uDate;
-    uDate = (ZPOS64_T)(ulDosDate>>16);
-    ptm->tm_mday = (uInt)(uDate&0x1f) ;
-    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
-    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
-
-    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
-    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
-    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
-}
-
-/*
-  Get Info about the current file in the zipfile, with internal only info
-*/
-local int unz64local_GetCurrentFileInfoInternal OF((unzFile file,
-                                                  unz_file_info64 *pfile_info,
-                                                  unz_file_info64_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize));
-
-local int unz64local_GetCurrentFileInfoInternal (unzFile file,
-                                                  unz_file_info64 *pfile_info,
-                                                  unz_file_info64_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize)
-{
-    unz64_s* s;
-    unz_file_info64 file_info;
-    unz_file_info64_internal file_info_internal;
-    int err=UNZ_OK;
-    uLong uMagic;
-    long lSeek=0;
-    uLong uL;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (ZSEEK64(s->z_filefunc, s->filestream,
-              s->pos_in_central_dir+s->byte_before_the_zipfile,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-
-    /* we check the magic */
-    if (err==UNZ_OK)
-    {
-        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x02014b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info.compressed_size = uL;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info.uncompressed_size = uL;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-                // relative offset of local header
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info_internal.offset_curfile = uL;
-
-    lSeek+=file_info.size_filename;
-    if ((err==UNZ_OK) && (szFileName!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_filename<fileNameBufferSize)
-        {
-            *(szFileName+file_info.size_filename)='\0';
-            uSizeRead = file_info.size_filename;
-        }
-        else
-            uSizeRead = fileNameBufferSize;
-
-        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek -= uSizeRead;
-    }
-
-    // Read extrafield
-    if ((err==UNZ_OK) && (extraField!=NULL))
-    {
-        ZPOS64_T uSizeRead ;
-        if (file_info.size_file_extra<extraFieldBufferSize)
-            uSizeRead = file_info.size_file_extra;
-        else
-            uSizeRead = extraFieldBufferSize;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-
-        lSeek += file_info.size_file_extra - (uLong)uSizeRead;
-    }
-    else
-        lSeek += file_info.size_file_extra;
-
-
-    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))
-    {
-                                uLong acc = 0;
-
-        // since lSeek now points to after the extra field we need to move back
-        lSeek -= file_info.size_file_extra;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        while(acc < file_info.size_file_extra)
-        {
-            uLong headerId;
-                                                uLong dataSize;
-
-            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)
-                err=UNZ_ERRNO;
-
-            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)
-                err=UNZ_ERRNO;
-
-            /* ZIP64 extra fields */
-            if (headerId == 0x0001)
-            {
-                                                        uLong uL;
-
-                                                                if(file_info.uncompressed_size == MAXU32)
-                                                                {
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
-                                                                                        err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info.compressed_size == MAXU32)
-                                                                {
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
-                                                                                  err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info_internal.offset_curfile == MAXU32)
-                                                                {
-                                                                        /* Relative Header offset */
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
-                                                                                err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info.disk_num_start == MAXU32)
-                                                                {
-                                                                        /* Disk Start Number */
-                                                                        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-                                                                                err=UNZ_ERRNO;
-                                                                }
-
-            }
-            else
-            {
-                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)
-                    err=UNZ_ERRNO;
-            }
-
-            acc += 2 + 2 + dataSize;
-        }
-    }
-
-    if ((err==UNZ_OK) && (szComment!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_comment<commentBufferSize)
-        {
-            *(szComment+file_info.size_file_comment)='\0';
-            uSizeRead = file_info.size_file_comment;
-        }
-        else
-            uSizeRead = commentBufferSize;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek+=file_info.size_file_comment - uSizeRead;
-    }
-    else
-        lSeek+=file_info.size_file_comment;
-
-
-    if ((err==UNZ_OK) && (pfile_info!=NULL))
-        *pfile_info=file_info;
-
-    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
-        *pfile_info_internal=file_info_internal;
-
-    return err;
-}
-
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem.
-*/
-extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,
-                                          unz_file_info64 * pfile_info,
-                                          char * szFileName, uLong fileNameBufferSize,
-                                          void *extraField, uLong extraFieldBufferSize,
-                                          char* szComment,  uLong commentBufferSize)
-{
-    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-}
-
-extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,
-                                          unz_file_info * pfile_info,
-                                          char * szFileName, uLong fileNameBufferSize,
-                                          void *extraField, uLong extraFieldBufferSize,
-                                          char* szComment,  uLong commentBufferSize)
-{
-    int err;
-    unz_file_info64 file_info64;
-    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-    if ((err==UNZ_OK) && (pfile_info != NULL))
-    {
-        pfile_info->version = file_info64.version;
-        pfile_info->version_needed = file_info64.version_needed;
-        pfile_info->flag = file_info64.flag;
-        pfile_info->compression_method = file_info64.compression_method;
-        pfile_info->dosDate = file_info64.dosDate;
-        pfile_info->crc = file_info64.crc;
-
-        pfile_info->size_filename = file_info64.size_filename;
-        pfile_info->size_file_extra = file_info64.size_file_extra;
-        pfile_info->size_file_comment = file_info64.size_file_comment;
-
-        pfile_info->disk_num_start = file_info64.disk_num_start;
-        pfile_info->internal_fa = file_info64.internal_fa;
-        pfile_info->external_fa = file_info64.external_fa;
-
-        pfile_info->tmu_date = file_info64.tmu_date,
-
-
-        pfile_info->compressed_size = (uLong)file_info64.compressed_size;
-        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;
-
-    }
-    return err;
-}
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-extern int ZEXPORT unzGoToFirstFile (unzFile file)
-{
-    int err=UNZ_OK;
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    s->pos_in_central_dir=s->offset_central_dir;
-    s->num_file=0;
-    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                             &s->cur_file_info_internal,
-                                             NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-extern int ZEXPORT unzGoToNextFile (unzFile  file)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
-      if (s->num_file+1==s->gi.number_entry)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
-            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
-    s->num_file++;
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)
-{
-    unz64_s* s;
-    int err;
-
-    /* We remember the 'current' position in the file so that we can jump
-     * back there if we fail.
-     */
-    unz_file_info64 cur_file_infoSaved;
-    unz_file_info64_internal cur_file_info_internalSaved;
-    ZPOS64_T num_fileSaved;
-    ZPOS64_T pos_in_central_dirSaved;
-
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-
-    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
-        return UNZ_PARAMERROR;
-
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    /* Save the current state */
-    num_fileSaved = s->num_file;
-    pos_in_central_dirSaved = s->pos_in_central_dir;
-    cur_file_infoSaved = s->cur_file_info;
-    cur_file_info_internalSaved = s->cur_file_info_internal;
-
-    err = unzGoToFirstFile(file);
-
-    while (err == UNZ_OK)
-    {
-        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
-        err = unzGetCurrentFileInfo64(file,NULL,
-                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
-                                    NULL,0,NULL,0);
-        if (err == UNZ_OK)
-        {
-            if (unzStringFileNameCompare(szCurrentFileName,
-                                            szFileName,iCaseSensitivity)==0)
-                return UNZ_OK;
-            err = unzGoToNextFile(file);
-        }
-    }
-
-    /* We failed, so restore the state of the 'current file' to where we
-     * were.
-     */
-    s->num_file = num_fileSaved ;
-    s->pos_in_central_dir = pos_in_central_dirSaved ;
-    s->cur_file_info = cur_file_infoSaved;
-    s->cur_file_info_internal = cur_file_info_internalSaved;
-    return err;
-}
-
-
-/*
-///////////////////////////////////////////
-// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
-// I need random access
-//
-// Further optimization could be realized by adding an ability
-// to cache the directory in memory. The goal being a single
-// comprehensive file read to put the file I need in a memory.
-*/
-
-/*
-typedef struct unz_file_pos_s
-{
-    ZPOS64_T pos_in_zip_directory;   // offset in file
-    ZPOS64_T num_of_file;            // # of file
-} unz_file_pos;
-*/
-
-extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)
-{
-    unz64_s* s;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
-    file_pos->num_of_file           = s->num_file;
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos)
-{
-    unz64_file_pos file_pos64;
-    int err = unzGetFilePos64(file,&file_pos64);
-    if (err==UNZ_OK)
-    {
-        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
-        file_pos->num_of_file = (uLong)file_pos64.num_of_file;
-    }
-    return err;
-}
-
-extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    /* jump to the right spot */
-    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
-    s->num_file           = file_pos->num_of_file;
-
-    /* set the current file */
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    /* return results */
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos)
-{
-    unz64_file_pos file_pos64;
-    if (file_pos == NULL)
-        return UNZ_PARAMERROR;
-
-    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
-    file_pos64.num_of_file = file_pos->num_of_file;
-    return unzGoToFilePos64(file,&file_pos64);
-}
-
-/*
-// Unzip Helper Functions - should be here?
-///////////////////////////////////////////
-*/
-
-/*
-  Read the local header of the current zipfile
-  Check the coherency of the local header and info in the end of central
-        directory about this file
-  store in *piSizeVar the size of extra info in local header
-        (filename and size of extra field data)
-*/
-local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,
-                                                    ZPOS64_T * poffset_local_extrafield,
-                                                    uInt  * psize_local_extrafield)
-{
-    uLong uMagic,uData,uFlags;
-    uLong size_filename;
-    uLong size_extra_field;
-    int err=UNZ_OK;
-
-    *piSizeVar = 0;
-    *poffset_local_extrafield = 0;
-    *psize_local_extrafield = 0;
-
-    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
-                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-
-    if (err==UNZ_OK)
-    {
-        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x04034b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-/*
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
-        err=UNZ_BADZIPFILE;
-*/
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
-        err=UNZ_BADZIPFILE;
-
-    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
-/* #ifdef HAVE_BZIP2 */
-                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
-/* #endif */
-                         (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
-        err=UNZ_ERRNO;
-    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
-        err=UNZ_ERRNO;
-    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
-        err=UNZ_BADZIPFILE;
-
-    *piSizeVar += (uInt)size_filename;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
-        err=UNZ_ERRNO;
-    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
-                                    SIZEZIPLOCALHEADER + size_filename;
-    *psize_local_extrafield = (uInt)size_extra_field;
-
-    *piSizeVar += (uInt)size_extra_field;
-
-    return err;
-}
-
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error and the file is opened, the return value is UNZ_OK.
-*/
-extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,
-                                            int* level, int raw, const char* password)
-{
-    int err=UNZ_OK;
-    uInt iSizeVar;
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */
-    uInt  size_local_extrafield;    /* size of the local extra field */
-#    ifndef NOUNCRYPT
-    char source[12];
-#    else
-    if (password != NULL)
-        return UNZ_PARAMERROR;
-#    endif
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_PARAMERROR;
-
-    if (s->pfile_in_zip_read != NULL)
-        unzCloseCurrentFile(file);
-
-    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
-        return UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_INTERNALERROR;
-
-    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
-    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
-    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
-    pfile_in_zip_read_info->pos_local_extrafield=0;
-    pfile_in_zip_read_info->raw=raw;
-
-    if (pfile_in_zip_read_info->read_buffer==NULL)
-    {
-        TRYFREE(pfile_in_zip_read_info);
-        return UNZ_INTERNALERROR;
-    }
-
-    pfile_in_zip_read_info->stream_initialised=0;
-
-    if (method!=NULL)
-        *method = (int)s->cur_file_info.compression_method;
-
-    if (level!=NULL)
-    {
-        *level = 6;
-        switch (s->cur_file_info.flag & 0x06)
-        {
-          case 6 : *level = 1; break;
-          case 4 : *level = 2; break;
-          case 2 : *level = 9; break;
-        }
-    }
-
-    if ((s->cur_file_info.compression_method!=0) &&
-/* #ifdef HAVE_BZIP2 */
-        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
-/* #endif */
-        (s->cur_file_info.compression_method!=Z_DEFLATED))
-
-        err=UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
-    pfile_in_zip_read_info->crc32=0;
-    pfile_in_zip_read_info->total_out_64=0;
-    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
-    pfile_in_zip_read_info->filestream=s->filestream;
-    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
-    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
-
-    pfile_in_zip_read_info->stream.total_out = 0;
-
-    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))
-    {
-#ifdef HAVE_BZIP2
-      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
-      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
-      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->bstream.state = (voidpf)0;
-
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-#else
-      pfile_in_zip_read_info->raw=1;
-#endif
-    }
-    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))
-    {
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = 0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END.
-         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
-         * size of both compressed and uncompressed data
-         */
-    }
-    pfile_in_zip_read_info->rest_read_compressed =
-            s->cur_file_info.compressed_size ;
-    pfile_in_zip_read_info->rest_read_uncompressed =
-            s->cur_file_info.uncompressed_size ;
-
-
-    pfile_in_zip_read_info->pos_in_zipfile =
-            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
-              iSizeVar;
-
-    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
-
-    s->pfile_in_zip_read = pfile_in_zip_read_info;
-                s->encrypted = 0;
-
-#    ifndef NOUNCRYPT
-    if (password != NULL)
-    {
-        int i;
-        s->pcrc_32_tab = get_crc_table();
-        init_keys(password,s->keys,s->pcrc_32_tab);
-        if (ZSEEK64(s->z_filefunc, s->filestream,
-                  s->pfile_in_zip_read->pos_in_zipfile +
-                     s->pfile_in_zip_read->byte_before_the_zipfile,
-                  SEEK_SET)!=0)
-            return UNZ_INTERNALERROR;
-        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)
-            return UNZ_INTERNALERROR;
-
-        for (i = 0; i<12; i++)
-            zdecode(s->keys,s->pcrc_32_tab,source[i]);
-
-        s->pfile_in_zip_read->pos_in_zipfile+=12;
-        s->encrypted=1;
-    }
-#    endif
-
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzOpenCurrentFile (unzFile file)
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
-}
-
-extern int ZEXPORT unzOpenCurrentFilePassword (unzFile file, const char*  password)
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
-}
-
-extern int ZEXPORT unzOpenCurrentFile2 (unzFile file, int* method, int* level, int raw)
-{
-    return unzOpenCurrentFile3(file, method, level, raw, NULL);
-}
-
-/** Addition for GDAL : START */
-
-extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    s=(unz64_s*)file;
-    if (file==NULL)
-        return 0; //UNZ_PARAMERROR;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-    if (pfile_in_zip_read_info==NULL)
-        return 0; //UNZ_PARAMERROR;
-    return pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile;
-}
-
-/** Addition for GDAL : END */
-
-/*
-  Read bytes from the current file.
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)
-{
-    int err=UNZ_OK;
-    uInt iRead = 0;
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if (pfile_in_zip_read_info->read_buffer == NULL)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (len==0)
-        return 0;
-
-    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
-
-    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
-
-    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
-        (!(pfile_in_zip_read_info->raw)))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
-
-    if ((len>pfile_in_zip_read_info->rest_read_compressed+
-           pfile_in_zip_read_info->stream.avail_in) &&
-         (pfile_in_zip_read_info->raw))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_compressed+
-            pfile_in_zip_read_info->stream.avail_in;
-
-    while (pfile_in_zip_read_info->stream.avail_out>0)
-    {
-        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
-            (pfile_in_zip_read_info->rest_read_compressed>0))
-        {
-            uInt uReadThis = UNZ_BUFSIZE;
-            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
-                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
-            if (uReadThis == 0)
-                return UNZ_EOF;
-            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile,
-                         ZLIB_FILEFUNC_SEEK_SET)!=0)
-                return UNZ_ERRNO;
-            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->read_buffer,
-                      uReadThis)!=uReadThis)
-                return UNZ_ERRNO;
-
-
-#            ifndef NOUNCRYPT
-            if(s->encrypted)
-            {
-                uInt i;
-                for(i=0;i<uReadThis;i++)
-                  pfile_in_zip_read_info->read_buffer[i] =
-                      zdecode(s->keys,s->pcrc_32_tab,
-                              pfile_in_zip_read_info->read_buffer[i]);
-            }
-#            endif
-
-
-            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
-
-            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
-
-            pfile_in_zip_read_info->stream.next_in =
-                (Bytef*)pfile_in_zip_read_info->read_buffer;
-            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
-        }
-
-        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
-        {
-            uInt uDoCopy,i ;
-
-            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                return (iRead==0) ? UNZ_EOF : iRead;
-
-            if (pfile_in_zip_read_info->stream.avail_out <
-                            pfile_in_zip_read_info->stream.avail_in)
-                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
-            else
-                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
-
-            for (i=0;i<uDoCopy;i++)
-                *(pfile_in_zip_read_info->stream.next_out+i) =
-                        *(pfile_in_zip_read_info->stream.next_in+i);
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
-                                pfile_in_zip_read_info->stream.next_out,
-                                uDoCopy);
-            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
-            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
-            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
-            pfile_in_zip_read_info->stream.next_out += uDoCopy;
-            pfile_in_zip_read_info->stream.next_in += uDoCopy;
-            pfile_in_zip_read_info->stream.total_out += uDoCopy;
-            iRead += uDoCopy;
-        }
-        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)
-        {
-#ifdef HAVE_BZIP2
-            uLong uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            uLong uOutThis;
-
-            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;
-            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;
-            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;
-            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;
-            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;
-            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;
-            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;
-            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;
-
-            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;
-            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;
-
-            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);
-
-            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));
-            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;
-            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;
-            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;
-            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;
-            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;
-            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;
-
-            if (err==BZ_STREAM_END)
-              return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=BZ_OK)
-              break;
-#endif
-        } // end Z_BZIP2ED
-        else
-        {
-            ZPOS64_T uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            ZPOS64_T uOutThis;
-            int flush=Z_SYNC_FLUSH;
-
-            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
-            bufBefore = pfile_in_zip_read_info->stream.next_out;
-
-            /*
-            if ((pfile_in_zip_read_info->rest_read_uncompressed ==
-                     pfile_in_zip_read_info->stream.avail_out) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                flush = Z_FINISH;
-            */
-            err=inflate(&pfile_in_zip_read_info->stream,flush);
-
-            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
-              err = Z_DATA_ERROR;
-
-            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
-
-            pfile_in_zip_read_info->crc32 =
-                crc32(pfile_in_zip_read_info->crc32,bufBefore,
-                        (uInt)(uOutThis));
-
-            pfile_in_zip_read_info->rest_read_uncompressed -=
-                uOutThis;
-
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            if (err==Z_STREAM_END)
-                return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=Z_OK)
-                break;
-        }
-    }
-
-    if (err==Z_OK)
-        return iRead;
-    return err;
-}
-
-
-/*
-  Give the current position in uncompressed data
-*/
-extern z_off_t ZEXPORT unztell (unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
-}
-
-extern ZPOS64_T ZEXPORT unztell64 (unzFile file)
-{
-
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return (ZPOS64_T)-1;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return (ZPOS64_T)-1;
-
-    return pfile_in_zip_read_info->total_out_64;
-}
-
-
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-extern int ZEXPORT unzeof (unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
-        return 1;
-    else
-        return 0;
-}
-
-
-
-/*
-Read extra field from the current file (opened by unzOpenCurrentFile)
-This is the local-header version of the extra field (sometimes, there is
-more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field that can be read
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    uInt read_now;
-    ZPOS64_T size_to_read;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
-                pfile_in_zip_read_info->pos_local_extrafield);
-
-    if (buf==NULL)
-        return (int)size_to_read;
-
-    if (len>size_to_read)
-        read_now = (uInt)size_to_read;
-    else
-        read_now = (uInt)len ;
-
-    if (read_now==0)
-        return 0;
-
-    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              pfile_in_zip_read_info->offset_local_extrafield +
-              pfile_in_zip_read_info->pos_local_extrafield,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              buf,read_now)!=read_now)
-        return UNZ_ERRNO;
-
-    return (int)read_now;
-}
-
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-extern int ZEXPORT unzCloseCurrentFile (unzFile file)
-{
-    int err=UNZ_OK;
-
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
-        (!pfile_in_zip_read_info->raw))
-    {
-        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
-            err=UNZ_CRCERROR;
-    }
-
-
-    TRYFREE(pfile_in_zip_read_info->read_buffer);
-    pfile_in_zip_read_info->read_buffer = NULL;
-    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
-        inflateEnd(&pfile_in_zip_read_info->stream);
-#ifdef HAVE_BZIP2
-    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
-        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
-#endif
-
-
-    pfile_in_zip_read_info->stream_initialised = 0;
-    TRYFREE(pfile_in_zip_read_info);
-
-    s->pfile_in_zip_read=NULL;
-
-    return err;
-}
-
-
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)
-{
-    unz64_s* s;
-    uLong uReadThis ;
-    if (file==NULL)
-        return (int)UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    uReadThis = uSizeBuf;
-    if (uReadThis>s->gi.size_comment)
-        uReadThis = s->gi.size_comment;
-
-    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (uReadThis>0)
-    {
-      *szComment='\0';
-      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
-        return UNZ_ERRNO;
-    }
-
-    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
-        *(szComment+s->gi.size_comment)='\0';
-    return (int)uReadThis;
-}
-
-/* Additions by RX '2004 */
-extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
-{
-    unz64_s* s;
-
-    if (file==NULL)
-          return 0; //UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-      return 0;
-    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
-      if (s->num_file==s->gi.number_entry)
-         return 0;
-    return s->pos_in_central_dir;
-}
-
-extern uLong ZEXPORT unzGetOffset (unzFile file)
-{
-    ZPOS64_T offset64;
-
-    if (file==NULL)
-          return 0; //UNZ_PARAMERROR;
-    offset64 = unzGetOffset64(file);
-    return (uLong)offset64;
-}
-
-extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    s->pos_in_central_dir = pos;
-    s->num_file = s->gi.number_entry;      /* hack */
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                              &s->cur_file_info_internal,
-                                              NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos)
-{
-    return unzSetOffset64(file,pos);
-}
diff --git a/contrib/zlib/contrib/minizip/unzip.h b/contrib/zlib/contrib/minizip/unzip.h
deleted file mode 100644
index 2104e3915..000000000
--- a/contrib/zlib/contrib/minizip/unzip.h
+++ /dev/null
@@ -1,437 +0,0 @@
-/* unzip.h -- IO for uncompress .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------------
-
-        Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  ---------------------------------------------------------------------------------
-
-        Changes
-
-        See header of unzip64.c
-
-*/
-
-#ifndef _unz64_H
-#define _unz64_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef  _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unzFile__;
-typedef unzFile__ *unzFile;
-#else
-typedef voidp unzFile;
-#endif
-
-
-#define UNZ_OK                          (0)
-#define UNZ_END_OF_LIST_OF_FILE         (-100)
-#define UNZ_ERRNO                       (Z_ERRNO)
-#define UNZ_EOF                         (0)
-#define UNZ_PARAMERROR                  (-102)
-#define UNZ_BADZIPFILE                  (-103)
-#define UNZ_INTERNALERROR               (-104)
-#define UNZ_CRCERROR                    (-105)
-
-/* tm_unz contain date/time info */
-typedef struct tm_unz_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_unz;
-
-/* unz_global_info structure contain global data about the ZIPfile
-   These data comes from the end of central dir */
-typedef struct unz_global_info64_s
-{
-    ZPOS64_T number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info64;
-
-typedef struct unz_global_info_s
-{
-    uLong number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info;
-
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_info64_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */
-    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info64;
-
-typedef struct unz_file_info_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    uLong compressed_size;      /* compressed size                 4 bytes */
-    uLong uncompressed_size;    /* uncompressed size               4 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info;
-
-extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
-                                                 const char* fileName2,
-                                                 int iCaseSensitivity));
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-    (like 1 on Unix, 2 on Windows)
-*/
-
-
-extern unzFile ZEXPORT unzOpen OF((const char *path));
-extern unzFile ZEXPORT unzOpen64 OF((const void *path));
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
-     "zlib/zlib113.zip".
-     If the zipfile cannot be opened (file don't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-     the "64" function take a const void* pointer, because the path is just the
-       value passed to the open64_file_func callback.
-     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path
-       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*
-       does not describe the reality
-*/
-
-
-extern unzFile ZEXPORT unzOpen2 OF((const char *path,
-                                    zlib_filefunc_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unzOpen, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern unzFile ZEXPORT unzOpen2_64 OF((const void *path,
-                                    zlib_filefunc64_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unz64Open, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern int ZEXPORT unzClose OF((unzFile file));
-/*
-  Close a ZipFile opened with unzOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzCloseCurrentFile before call unzClose.
-  return UNZ_OK if there is no problem. */
-
-extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
-                                        unz_global_info *pglobal_info));
-
-extern int ZEXPORT unzGetGlobalInfo64 OF((unzFile file,
-                                        unz_global_info64 *pglobal_info));
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-
-
-extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
-                                           char *szComment,
-                                           uLong uSizeBuf));
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-
-
-/***************************************************************************/
-/* Unzip package allow you browse the directory of the zipfile */
-
-extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-
-extern int ZEXPORT unzGoToNextFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-
-extern int ZEXPORT unzLocateFile OF((unzFile file,
-                     const char *szFileName,
-                     int iCaseSensitivity));
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-
-
-/* ****************************************** */
-/* Ryan supplied functions */
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   /* offset in zip file directory */
-    uLong num_of_file;            /* # of file */
-} unz_file_pos;
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-typedef struct unz64_file_pos_s
-{
-    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */
-    ZPOS64_T num_of_file;            /* # of file */
-} unz64_file_pos;
-
-extern int ZEXPORT unzGetFilePos64(
-    unzFile file,
-    unz64_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos64(
-    unzFile file,
-    const unz64_file_pos* file_pos);
-
-/* ****************************************** */
-
-extern int ZEXPORT unzGetCurrentFileInfo64 OF((unzFile file,
-                         unz_file_info64 *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-
-extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
-                         unz_file_info *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-/*
-  Get Info about the current file
-  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
-        the current file
-  if szFileName!=NULL, the filemane string will be copied in szFileName
-            (fileNameBufferSize is the size of the buffer)
-  if extraField!=NULL, the extra field information will be copied in extraField
-            (extraFieldBufferSize is the size of the buffer).
-            This is the Central-header version of the extra field
-  if szComment!=NULL, the comment string of the file will be copied in szComment
-            (commentBufferSize is the size of the buffer)
-*/
-
-
-/** Addition for GDAL : START */
-
-extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64 OF((unzFile file));
-
-/** Addition for GDAL : END */
-
-
-/***************************************************************************/
-/* for reading the content of the current zipfile, you can open it, read data
-   from it, and close it (you can close it before reading all the file)
-   */
-
-extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
-                                                  const char* password));
-/*
-  Open for reading data the current file in the zipfile.
-  password is a crypting password
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw,
-                                           const char* password));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-
-extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-
-extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
-                      voidp buf,
-                      unsigned len));
-/*
-  Read bytes from the current file (opened by unzOpenCurrentFile)
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-
-extern z_off_t ZEXPORT unztell OF((unzFile file));
-
-extern ZPOS64_T ZEXPORT unztell64 OF((unzFile file));
-/*
-  Give the current position in uncompressed data
-*/
-
-extern int ZEXPORT unzeof OF((unzFile file));
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-
-extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
-                                             voidp buf,
-                                             unsigned len));
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-
-/***************************************************************************/
-
-/* Get the current file offset */
-extern ZPOS64_T ZEXPORT unzGetOffset64 (unzFile file);
-extern uLong ZEXPORT unzGetOffset (unzFile file);
-
-/* Set the current file offset */
-extern int ZEXPORT unzSetOffset64 (unzFile file, ZPOS64_T pos);
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _unz64_H */
diff --git a/contrib/zlib/contrib/minizip/zip.c b/contrib/zlib/contrib/minizip/zip.c
deleted file mode 100644
index 44e88a9cb..000000000
--- a/contrib/zlib/contrib/minizip/zip.c
+++ /dev/null
@@ -1,2007 +0,0 @@
-/* zip.c -- IO on .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         Changes
-   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
-   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
-   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
-   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
-                                 It is used when recreting zip archive with RAW when deleting items from a zip.
-                                 ZIP64 data is automatically added to items that needs it, and existing ZIP64 data need to be removed.
-   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
-   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
-
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include "zlib.h"
-#include "zip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-#ifndef VERSIONMADEBY
-# define VERSIONMADEBY   (0x0) /* platform depedent */
-#endif
-
-#ifndef Z_BUFSIZE
-#define Z_BUFSIZE (64*1024) //(16384)
-#endif
-
-#ifndef Z_MAXFILENAMEINZIP
-#define Z_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-/*
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-*/
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-
-// NOT sure that this work on ALL platform
-#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-#ifndef DEF_MEM_LEVEL
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-#endif
-const char zip_copyright[] =" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-
-#define SIZEDATA_INDATABLOCK (4096-(4*4))
-
-#define LOCALHEADERMAGIC    (0x04034b50)
-#define CENTRALHEADERMAGIC  (0x02014b50)
-#define ENDHEADERMAGIC      (0x06054b50)
-#define ZIP64ENDHEADERMAGIC      (0x6064b50)
-#define ZIP64ENDLOCHEADERMAGIC   (0x7064b50)
-
-#define FLAG_LOCALHEADER_OFFSET (0x06)
-#define CRC_LOCALHEADER_OFFSET  (0x0e)
-
-#define SIZECENTRALHEADER (0x2e) /* 46 */
-
-typedef struct linkedlist_datablock_internal_s
-{
-  struct linkedlist_datablock_internal_s* next_datablock;
-  uLong  avail_in_this_block;
-  uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignment */
-  unsigned char data[SIZEDATA_INDATABLOCK];
-} linkedlist_datablock_internal;
-
-typedef struct linkedlist_data_s
-{
-    linkedlist_datablock_internal* first_block;
-    linkedlist_datablock_internal* last_block;
-} linkedlist_data;
-
-
-typedef struct
-{
-    z_stream stream;            /* zLib stream structure for inflate */
-#ifdef HAVE_BZIP2
-    bz_stream bstream;          /* bzLib stream structure for bziped */
-#endif
-
-    int  stream_initialised;    /* 1 is stream is initialised */
-    uInt pos_in_buffered_data;  /* last written byte in buffered_data */
-
-    ZPOS64_T pos_local_header;     /* offset of the local header of the file
-                                     currenty writing */
-    char* central_header;       /* central header data for the current file */
-    uLong size_centralExtra;
-    uLong size_centralheader;   /* size of the central header for cur file */
-    uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */
-    uLong flag;                 /* flag of the file currently writing */
-
-    int  method;                /* compression method of file currenty wr.*/
-    int  raw;                   /* 1 for directly writing raw data */
-    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
-    uLong dosDate;
-    uLong crc32;
-    int  encrypt;
-    int  zip64;               /* Add ZIP64 extened information in the extra field */
-    ZPOS64_T pos_zip64extrainfo;
-    ZPOS64_T totalCompressedData;
-    ZPOS64_T totalUncompressedData;
-#ifndef NOCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const z_crc_t* pcrc_32_tab;
-    int crypt_header_size;
-#endif
-} curfile64_info;
-
-typedef struct
-{
-    zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    linkedlist_data central_dir;/* datablock with central dir in construction*/
-    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
-    curfile64_info ci;            /* info on the file curretly writing */
-
-    ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */
-    ZPOS64_T add_position_when_writing_offset;
-    ZPOS64_T number_entry;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    char *globalcomment;
-#endif
-
-} zip64_internal;
-
-
-#ifndef NOCRYPT
-#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-#include "crypt.h"
-#endif
-
-local linkedlist_datablock_internal* allocate_new_datablock()
-{
-    linkedlist_datablock_internal* ldi;
-    ldi = (linkedlist_datablock_internal*)
-                 ALLOC(sizeof(linkedlist_datablock_internal));
-    if (ldi!=NULL)
-    {
-        ldi->next_datablock = NULL ;
-        ldi->filled_in_this_block = 0 ;
-        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
-    }
-    return ldi;
-}
-
-local void free_datablock(linkedlist_datablock_internal* ldi)
-{
-    while (ldi!=NULL)
-    {
-        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
-        TRYFREE(ldi);
-        ldi = ldinext;
-    }
-}
-
-local void init_linkedlist(linkedlist_data* ll)
-{
-    ll->first_block = ll->last_block = NULL;
-}
-
-local void free_linkedlist(linkedlist_data* ll)
-{
-    free_datablock(ll->first_block);
-    ll->first_block = ll->last_block = NULL;
-}
-
-
-local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)
-{
-    linkedlist_datablock_internal* ldi;
-    const unsigned char* from_copy;
-
-    if (ll==NULL)
-        return ZIP_INTERNALERROR;
-
-    if (ll->last_block == NULL)
-    {
-        ll->first_block = ll->last_block = allocate_new_datablock();
-        if (ll->first_block == NULL)
-            return ZIP_INTERNALERROR;
-    }
-
-    ldi = ll->last_block;
-    from_copy = (unsigned char*)buf;
-
-    while (len>0)
-    {
-        uInt copy_this;
-        uInt i;
-        unsigned char* to_copy;
-
-        if (ldi->avail_in_this_block==0)
-        {
-            ldi->next_datablock = allocate_new_datablock();
-            if (ldi->next_datablock == NULL)
-                return ZIP_INTERNALERROR;
-            ldi = ldi->next_datablock ;
-            ll->last_block = ldi;
-        }
-
-        if (ldi->avail_in_this_block < len)
-            copy_this = (uInt)ldi->avail_in_this_block;
-        else
-            copy_this = (uInt)len;
-
-        to_copy = &(ldi->data[ldi->filled_in_this_block]);
-
-        for (i=0;i<copy_this;i++)
-            *(to_copy+i)=*(from_copy+i);
-
-        ldi->filled_in_this_block += copy_this;
-        ldi->avail_in_this_block -= copy_this;
-        from_copy += copy_this ;
-        len -= copy_this;
-    }
-    return ZIP_OK;
-}
-
-
-
-/****************************************************************************/
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-/* ===========================================================================
-   Inputs a long in LSB order to the given file
-   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
-*/
-
-local int zip64local_putValue OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte));
-local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)
-{
-    unsigned char buf[8];
-    int n;
-    for (n = 0; n < nbByte; n++)
-    {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-    if (x != 0)
-      {     /* data overflow - hack for ZIP64 (X Roche) */
-      for (n = 0; n < nbByte; n++)
-        {
-          buf[n] = 0xff;
-        }
-      }
-
-    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
-        return ZIP_ERRNO;
-    else
-        return ZIP_OK;
-}
-
-local void zip64local_putValue_inmemory OF((void* dest, ZPOS64_T x, int nbByte));
-local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte)
-{
-    unsigned char* buf=(unsigned char*)dest;
-    int n;
-    for (n = 0; n < nbByte; n++) {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-
-    if (x != 0)
-    {     /* data overflow - hack for ZIP64 */
-       for (n = 0; n < nbByte; n++)
-       {
-          buf[n] = 0xff;
-       }
-    }
-}
-
-/****************************************************************************/
-
-
-local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)
-{
-    uLong year = (uLong)ptm->tm_year;
-    if (year>=1980)
-        year-=1980;
-    else if (year>=80)
-        year-=80;
-    return
-      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
-        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
-}
-
-
-/****************************************************************************/
-
-local int zip64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi));
-
-local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,int* pi)
-{
-    unsigned char c;
-    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return ZIP_OK;
-    }
-    else
-    {
-        if (ZERROR64(*pzlib_filefunc_def,filestream))
-            return ZIP_ERRNO;
-        else
-            return ZIP_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int zip64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
-
-local int zip64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int zip64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
-
-local int zip64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int zip64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));
-
-
-local int zip64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
-{
-  ZPOS64_T x;
-  int i = 0;
-  int err;
-
-  err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x = (ZPOS64_T)i;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<8;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<16;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<24;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<32;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<40;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<48;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<56;
-
-  if (err==ZIP_OK)
-    *pX = x;
-  else
-    *pX = 0;
-
-  return err;
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T zip64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-
-local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-  unsigned char* buf;
-  ZPOS64_T uSizeFile;
-  ZPOS64_T uBackRead;
-  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-  ZPOS64_T uPosFound=0;
-
-  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-    return 0;
-
-
-  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-  if (uMaxBack>uSizeFile)
-    uMaxBack = uSizeFile;
-
-  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-  if (buf==NULL)
-    return 0;
-
-  uBackRead = 4;
-  while (uBackRead<uMaxBack)
-  {
-    uLong uReadSize;
-    ZPOS64_T uReadPos ;
-    int i;
-    if (uBackRead+BUFREADCOMMENT>uMaxBack)
-      uBackRead = uMaxBack;
-    else
-      uBackRead+=BUFREADCOMMENT;
-    uReadPos = uSizeFile-uBackRead ;
-
-    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      break;
-
-    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-      break;
-
-    for (i=(int)uReadSize-3; (i--)>0;)
-      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-      {
-        uPosFound = uReadPos+i;
-        break;
-      }
-
-      if (uPosFound!=0)
-        break;
-  }
-  TRYFREE(buf);
-  return uPosFound;
-}
-
-/*
-Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
-the global comment)
-*/
-local ZPOS64_T zip64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-
-local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-  unsigned char* buf;
-  ZPOS64_T uSizeFile;
-  ZPOS64_T uBackRead;
-  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-  ZPOS64_T uPosFound=0;
-  uLong uL;
-  ZPOS64_T relativeOffset;
-
-  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-    return 0;
-
-  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-  if (uMaxBack>uSizeFile)
-    uMaxBack = uSizeFile;
-
-  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-  if (buf==NULL)
-    return 0;
-
-  uBackRead = 4;
-  while (uBackRead<uMaxBack)
-  {
-    uLong uReadSize;
-    ZPOS64_T uReadPos;
-    int i;
-    if (uBackRead+BUFREADCOMMENT>uMaxBack)
-      uBackRead = uMaxBack;
-    else
-      uBackRead+=BUFREADCOMMENT;
-    uReadPos = uSizeFile-uBackRead ;
-
-    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      break;
-
-    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-      break;
-
-    for (i=(int)uReadSize-3; (i--)>0;)
-    {
-      // Signature "0x07064b50" Zip64 end of central directory locater
-      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
-      {
-        uPosFound = uReadPos+i;
-        break;
-      }
-    }
-
-      if (uPosFound!=0)
-        break;
-  }
-
-  TRYFREE(buf);
-  if (uPosFound == 0)
-    return 0;
-
-  /* Zip64 end of central directory locator */
-  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
-    return 0;
-
-  /* the signature, already checked */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-
-  /* number of the disk with the start of the zip64 end of  central directory */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-  if (uL != 0)
-    return 0;
-
-  /* relative offset of the zip64 end of central directory record */
-  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)
-    return 0;
-
-  /* total number of disks */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-  if (uL != 1)
-    return 0;
-
-  /* Goto Zip64 end of central directory record */
-  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
-    return 0;
-
-  /* the signature */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-
-  if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'
-    return 0;
-
-  return relativeOffset;
-}
-
-int LoadCentralDirectoryRecord(zip64_internal* pziinit)
-{
-  int err=ZIP_OK;
-  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-
-  ZPOS64_T size_central_dir;     /* size of the central directory  */
-  ZPOS64_T offset_central_dir;   /* offset of start of central directory */
-  ZPOS64_T central_pos;
-  uLong uL;
-
-  uLong number_disk;          /* number of the current dist, used for
-                              spaning ZIP, unsupported, always 0*/
-  uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                              for spaning ZIP, unsupported, always 0*/
-  ZPOS64_T number_entry;
-  ZPOS64_T number_entry_CD;      /* total number of entries in
-                                the central dir
-                                (same than number_entry on nospan) */
-  uLong VersionMadeBy;
-  uLong VersionNeeded;
-  uLong size_comment;
-
-  int hasZIP64Record = 0;
-
-  // check first if we find a ZIP64 record
-  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);
-  if(central_pos > 0)
-  {
-    hasZIP64Record = 1;
-  }
-  else if(central_pos == 0)
-  {
-    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);
-  }
-
-/* disable to allow appending to empty ZIP archive
-        if (central_pos==0)
-            err=ZIP_ERRNO;
-*/
-
-  if(hasZIP64Record)
-  {
-    ZPOS64_T sizeEndOfCentralDirectory;
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
-      err=ZIP_ERRNO;
-
-    /* the signature, already checked */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* size of zip64 end of central directory record */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* version made by */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* version needed to extract */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of this disk */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central directory on this disk */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central directory */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
-      err=ZIP_BADZIPFILE;
-
-    /* size of the central directory */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* offset of start of central directory with respect to the
-    starting disk number */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    // TODO..
-    // read the comment from the standard central header.
-    size_comment = 0;
-  }
-  else
-  {
-    // Read End of central Directory info
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      err=ZIP_ERRNO;
-
-    /* the signature, already checked */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of this disk */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central dir on this disk */
-    number_entry = 0;
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      number_entry = uL;
-
-    /* total number of entries in the central dir */
-    number_entry_CD = 0;
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      number_entry_CD = uL;
-
-    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
-      err=ZIP_BADZIPFILE;
-
-    /* size of the central directory */
-    size_central_dir = 0;
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      size_central_dir = uL;
-
-    /* offset of start of central directory with respect to the starting disk number */
-    offset_central_dir = 0;
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      offset_central_dir = uL;
-
-
-    /* zipfile global comment length */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)
-      err=ZIP_ERRNO;
-  }
-
-  if ((central_pos<offset_central_dir+size_central_dir) &&
-    (err==ZIP_OK))
-    err=ZIP_BADZIPFILE;
-
-  if (err!=ZIP_OK)
-  {
-    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);
-    return ZIP_ERRNO;
-  }
-
-  if (size_comment>0)
-  {
-    pziinit->globalcomment = (char*)ALLOC(size_comment+1);
-    if (pziinit->globalcomment)
-    {
-      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);
-      pziinit->globalcomment[size_comment]=0;
-    }
-  }
-
-  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
-  pziinit->add_position_when_writing_offset = byte_before_the_zipfile;
-
-  {
-    ZPOS64_T size_central_dir_to_read = size_central_dir;
-    size_t buf_size = SIZEDATA_INDATABLOCK;
-    void* buf_read = (void*)ALLOC(buf_size);
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
-      err=ZIP_ERRNO;
-
-    while ((size_central_dir_to_read>0) && (err==ZIP_OK))
-    {
-      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
-      if (read_this > size_central_dir_to_read)
-        read_this = size_central_dir_to_read;
-
-      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)
-        err=ZIP_ERRNO;
-
-      if (err==ZIP_OK)
-        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);
-
-      size_central_dir_to_read-=read_this;
-    }
-    TRYFREE(buf_read);
-  }
-  pziinit->begin_pos = byte_before_the_zipfile;
-  pziinit->number_entry = number_entry_CD;
-
-  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)
-    err=ZIP_ERRNO;
-
-  return err;
-}
-
-
-#endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-
-/************************************************************/
-extern zipFile ZEXPORT zipOpen3 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
-{
-    zip64_internal ziinit;
-    zip64_internal* zi;
-    int err=ZIP_OK;
-
-    ziinit.z_filefunc.zseek32_file = NULL;
-    ziinit.z_filefunc.ztell32_file = NULL;
-    if (pzlib_filefunc64_32_def==NULL)
-        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);
-    else
-        ziinit.z_filefunc = *pzlib_filefunc64_32_def;
-
-    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
-                  pathname,
-                  (append == APPEND_STATUS_CREATE) ?
-                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
-                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
-
-    if (ziinit.filestream == NULL)
-        return NULL;
-
-    if (append == APPEND_STATUS_CREATEAFTER)
-        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);
-
-    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);
-    ziinit.in_opened_file_inzip = 0;
-    ziinit.ci.stream_initialised = 0;
-    ziinit.number_entry = 0;
-    ziinit.add_position_when_writing_offset = 0;
-    init_linkedlist(&(ziinit.central_dir));
-
-
-
-    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));
-    if (zi==NULL)
-    {
-        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);
-        return NULL;
-    }
-
-    /* now we add file in a zipfile */
-#    ifndef NO_ADDFILEINEXISTINGZIP
-    ziinit.globalcomment = NULL;
-    if (append == APPEND_STATUS_ADDINZIP)
-    {
-      // Read and Cache Central Directory Records
-      err = LoadCentralDirectoryRecord(&ziinit);
-    }
-
-    if (globalcomment)
-    {
-      *globalcomment = ziinit.globalcomment;
-    }
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-    if (err != ZIP_OK)
-    {
-#    ifndef NO_ADDFILEINEXISTINGZIP
-        TRYFREE(ziinit.globalcomment);
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-        TRYFREE(zi);
-        return NULL;
-    }
-    else
-    {
-        *zi = ziinit;
-        return (zipFile)zi;
-    }
-}
-
-extern zipFile ZEXPORT zipOpen2 (const char *pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)
-{
-    if (pzlib_filefunc32_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
-        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
-    }
-    else
-        return zipOpen3(pathname, append, globalcomment, NULL);
-}
-
-extern zipFile ZEXPORT zipOpen2_64 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    if (pzlib_filefunc_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
-        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
-        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
-        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
-    }
-    else
-        return zipOpen3(pathname, append, globalcomment, NULL);
-}
-
-
-
-extern zipFile ZEXPORT zipOpen (const char* pathname, int append)
-{
-    return zipOpen3((const void*)pathname,append,NULL,NULL);
-}
-
-extern zipFile ZEXPORT zipOpen64 (const void* pathname, int append)
-{
-    return zipOpen3(pathname,append,NULL,NULL);
-}
-
-int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local)
-{
-  /* write the local header */
-  int err;
-  uInt size_filename = (uInt)strlen(filename);
-  uInt size_extrafield = size_extrafield_local;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);
-
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
-
-  // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */
-  }
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);
-
-  if(zi->ci.zip64)
-  {
-    size_extrafield += 20;
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);
-
-  if ((err==ZIP_OK) && (size_filename > 0))
-  {
-    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)
-      err = ZIP_ERRNO;
-  }
-
-  if ((err==ZIP_OK) && (size_extrafield_local > 0))
-  {
-    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
-      err = ZIP_ERRNO;
-  }
-
-
-  if ((err==ZIP_OK) && (zi->ci.zip64))
-  {
-      // write the Zip64 extended info
-      short HeaderID = 1;
-      short DataSize = 16;
-      ZPOS64_T CompressedSize = 0;
-      ZPOS64_T UncompressedSize = 0;
-
-      // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
-      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);
-
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);
-
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);
-  }
-
-  return err;
-}
-
-/*
- NOTE.
- When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
- before calling this function it can be done with zipRemoveExtraInfoBlock
-
- It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
- unnecessary allocations.
- */
-extern int ZEXPORT zipOpenNewFileInZip4_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting,
-                                         uLong versionMadeBy, uLong flagBase, int zip64)
-{
-    zip64_internal* zi;
-    uInt size_filename;
-    uInt size_comment;
-    uInt i;
-    int err = ZIP_OK;
-
-#    ifdef NOCRYPT
-    (crcForCrypting);
-    if (password != NULL)
-        return ZIP_PARAMERROR;
-#    endif
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-
-#ifdef HAVE_BZIP2
-    if ((method!=0) && (method!=Z_DEFLATED) && (method!=Z_BZIP2ED))
-      return ZIP_PARAMERROR;
-#else
-    if ((method!=0) && (method!=Z_DEFLATED))
-      return ZIP_PARAMERROR;
-#endif
-
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-        if (err != ZIP_OK)
-            return err;
-    }
-
-    if (filename==NULL)
-        filename="-";
-
-    if (comment==NULL)
-        size_comment = 0;
-    else
-        size_comment = (uInt)strlen(comment);
-
-    size_filename = (uInt)strlen(filename);
-
-    if (zipfi == NULL)
-        zi->ci.dosDate = 0;
-    else
-    {
-        if (zipfi->dosDate != 0)
-            zi->ci.dosDate = zipfi->dosDate;
-        else
-          zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);
-    }
-
-    zi->ci.flag = flagBase;
-    if ((level==8) || (level==9))
-      zi->ci.flag |= 2;
-    if (level==2)
-      zi->ci.flag |= 4;
-    if (level==1)
-      zi->ci.flag |= 6;
-    if (password != NULL)
-      zi->ci.flag |= 1;
-
-    zi->ci.crc32 = 0;
-    zi->ci.method = method;
-    zi->ci.encrypt = 0;
-    zi->ci.stream_initialised = 0;
-    zi->ci.pos_in_buffered_data = 0;
-    zi->ci.raw = raw;
-    zi->ci.pos_local_header = ZTELL64(zi->z_filefunc,zi->filestream);
-
-    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;
-    zi->ci.size_centralExtraFree = 32; // Extra space we have reserved in case we need to add ZIP64 extra info data
-
-    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);
-
-    zi->ci.size_centralExtra = size_extrafield_global;
-    zip64local_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
-    /* version info */
-    zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)versionMadeBy,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
-    zip64local_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
-    zip64local_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
-    zip64local_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
-    zip64local_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/
-
-    if (zipfi==NULL)
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);
-    else
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);
-
-    if (zipfi==NULL)
-        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);
-    else
-        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);
-
-    if(zi->ci.pos_local_header >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writing_offset,4);
-
-    for (i=0;i<size_filename;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
-
-    for (i=0;i<size_extrafield_global;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
-              *(((const char*)extrafield_global)+i);
-
-    for (i=0;i<size_comment;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
-              size_extrafield_global+i) = *(comment+i);
-    if (zi->ci.central_header == NULL)
-        return ZIP_INTERNALERROR;
-
-    zi->ci.zip64 = zip64;
-    zi->ci.totalCompressedData = 0;
-    zi->ci.totalUncompressedData = 0;
-    zi->ci.pos_zip64extrainfo = 0;
-
-    err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);
-
-#ifdef HAVE_BZIP2
-    zi->ci.bstream.avail_in = (uInt)0;
-    zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-    zi->ci.bstream.total_in_hi32 = 0;
-    zi->ci.bstream.total_in_lo32 = 0;
-    zi->ci.bstream.total_out_hi32 = 0;
-    zi->ci.bstream.total_out_lo32 = 0;
-#endif
-
-    zi->ci.stream.avail_in = (uInt)0;
-    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.stream.next_out = zi->ci.buffered_data;
-    zi->ci.stream.total_in = 0;
-    zi->ci.stream.total_out = 0;
-    zi->ci.stream.data_type = Z_BINARY;
-
-#ifdef HAVE_BZIP2
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-#else
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-#endif
-    {
-        if(zi->ci.method == Z_DEFLATED)
-        {
-          zi->ci.stream.zalloc = (alloc_func)0;
-          zi->ci.stream.zfree = (free_func)0;
-          zi->ci.stream.opaque = (voidpf)0;
-
-          if (windowBits>0)
-              windowBits = -windowBits;
-
-          err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);
-
-          if (err==Z_OK)
-              zi->ci.stream_initialised = Z_DEFLATED;
-        }
-        else if(zi->ci.method == Z_BZIP2ED)
-        {
-#ifdef HAVE_BZIP2
-            // Init BZip stuff here
-          zi->ci.bstream.bzalloc = 0;
-          zi->ci.bstream.bzfree = 0;
-          zi->ci.bstream.opaque = (voidpf)0;
-
-          err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0,35);
-          if(err == BZ_OK)
-            zi->ci.stream_initialised = Z_BZIP2ED;
-#endif
-        }
-
-    }
-
-#    ifndef NOCRYPT
-    zi->ci.crypt_header_size = 0;
-    if ((err==Z_OK) && (password != NULL))
-    {
-        unsigned char bufHead[RAND_HEAD_LEN];
-        unsigned int sizeHead;
-        zi->ci.encrypt = 1;
-        zi->ci.pcrc_32_tab = get_crc_table();
-        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
-
-        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);
-        zi->ci.crypt_header_size = sizeHead;
-
-        if (ZWRITE64(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
-                err = ZIP_ERRNO;
-    }
-#    endif
-
-    if (err==Z_OK)
-        zi->in_opened_file_inzip = 1;
-    return err;
-}
-
-extern int ZEXPORT zipOpenNewFileInZip4 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting,
-                                         uLong versionMadeBy, uLong flagBase)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, versionMadeBy, flagBase, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, VERSIONMADEBY, 0, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void* extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int raw)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void* extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int raw, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void*extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void*extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, 0);
-}
-
-local int zip64FlushWriteBuffer(zip64_internal* zi)
-{
-    int err=ZIP_OK;
-
-    if (zi->ci.encrypt != 0)
-    {
-#ifndef NOCRYPT
-        uInt i;
-        int t;
-        for (i=0;i<zi->ci.pos_in_buffered_data;i++)
-            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);
-#endif
-    }
-
-    if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)
-      err = ZIP_ERRNO;
-
-    zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;
-
-#ifdef HAVE_BZIP2
-    if(zi->ci.method == Z_BZIP2ED)
-    {
-      zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
-      zi->ci.bstream.total_in_lo32 = 0;
-      zi->ci.bstream.total_in_hi32 = 0;
-    }
-    else
-#endif
-    {
-      zi->ci.totalUncompressedData += zi->ci.stream.total_in;
-      zi->ci.stream.total_in = 0;
-    }
-
-
-    zi->ci.pos_in_buffered_data = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipWriteInFileInZip (zipFile file,const void* buf,unsigned int len)
-{
-    zip64_internal* zi;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-
-    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);
-
-#ifdef HAVE_BZIP2
-    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
-    {
-      zi->ci.bstream.next_in = (void*)buf;
-      zi->ci.bstream.avail_in = len;
-      err = BZ_RUN_OK;
-
-      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))
-      {
-        if (zi->ci.bstream.avail_out == 0)
-        {
-          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-            err = ZIP_ERRNO;
-          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-        }
-
-
-        if(err != BZ_RUN_OK)
-          break;
-
-        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-        {
-          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
-//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
-          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);
-
-          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
-        }
-      }
-
-      if(err == BZ_RUN_OK)
-        err = ZIP_OK;
-    }
-    else
-#endif
-    {
-      zi->ci.stream.next_in = (Bytef*)buf;
-      zi->ci.stream.avail_in = len;
-
-      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
-      {
-          if (zi->ci.stream.avail_out == 0)
-          {
-              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-                  err = ZIP_ERRNO;
-              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-              zi->ci.stream.next_out = zi->ci.buffered_data;
-          }
-
-
-          if(err != ZIP_OK)
-              break;
-
-          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-          {
-              uLong uTotalOutBefore = zi->ci.stream.total_out;
-              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
-              if(uTotalOutBefore > zi->ci.stream.total_out)
-              {
-                int bBreak = 0;
-                bBreak++;
-              }
-
-              zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-          }
-          else
-          {
-              uInt copy_this,i;
-              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
-                  copy_this = zi->ci.stream.avail_in;
-              else
-                  copy_this = zi->ci.stream.avail_out;
-
-              for (i = 0; i < copy_this; i++)
-                  *(((char*)zi->ci.stream.next_out)+i) =
-                      *(((const char*)zi->ci.stream.next_in)+i);
-              {
-                  zi->ci.stream.avail_in -= copy_this;
-                  zi->ci.stream.avail_out-= copy_this;
-                  zi->ci.stream.next_in+= copy_this;
-                  zi->ci.stream.next_out+= copy_this;
-                  zi->ci.stream.total_in+= copy_this;
-                  zi->ci.stream.total_out+= copy_this;
-                  zi->ci.pos_in_buffered_data += copy_this;
-              }
-          }
-      }// while(...)
-    }
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw (zipFile file, uLong uncompressed_size, uLong crc32)
-{
-    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
-{
-    zip64_internal* zi;
-    ZPOS64_T compressed_size;
-    uLong invalidValue = 0xffffffff;
-    short datasize = 0;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-    zi->ci.stream.avail_in = 0;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-                {
-                        while (err==ZIP_OK)
-                        {
-                                uLong uTotalOutBefore;
-                                if (zi->ci.stream.avail_out == 0)
-                                {
-                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-                                                err = ZIP_ERRNO;
-                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-                                        zi->ci.stream.next_out = zi->ci.buffered_data;
-                                }
-                                uTotalOutBefore = zi->ci.stream.total_out;
-                                err=deflate(&zi->ci.stream,  Z_FINISH);
-                                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-                        }
-                }
-    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-    {
-#ifdef HAVE_BZIP2
-      err = BZ_FINISH_OK;
-      while (err==BZ_FINISH_OK)
-      {
-        uLong uTotalOutBefore;
-        if (zi->ci.bstream.avail_out == 0)
-        {
-          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-            err = ZIP_ERRNO;
-          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-        }
-        uTotalOutBefore = zi->ci.bstream.total_out_lo32;
-        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);
-        if(err == BZ_STREAM_END)
-          err = Z_STREAM_END;
-
-        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
-      }
-
-      if(err == BZ_FINISH_OK)
-        err = ZIP_OK;
-#endif
-    }
-
-    if (err==Z_STREAM_END)
-        err=ZIP_OK; /* this is normal */
-
-    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
-                {
-        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)
-            err = ZIP_ERRNO;
-                }
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        int tmp_err = deflateEnd(&zi->ci.stream);
-        if (err == ZIP_OK)
-            err = tmp_err;
-        zi->ci.stream_initialised = 0;
-    }
-#ifdef HAVE_BZIP2
-    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-    {
-      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
-                        if (err==ZIP_OK)
-                                err = tmperr;
-                        zi->ci.stream_initialised = 0;
-    }
-#endif
-
-    if (!zi->ci.raw)
-    {
-        crc32 = (uLong)zi->ci.crc32;
-        uncompressed_size = zi->ci.totalUncompressedData;
-    }
-    compressed_size = zi->ci.totalCompressedData;
-
-#    ifndef NOCRYPT
-    compressed_size += zi->ci.crypt_header_size;
-#    endif
-
-    // update Current Item crc and sizes,
-    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)
-    {
-      /*version Made by*/
-      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);
-      /*version needed*/
-      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);
-
-    }
-
-    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/
-
-
-    if(compressed_size >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/
-
-    /// set internal file attributes field
-    if (zi->ci.stream.data_type == Z_ASCII)
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);
-
-    if(uncompressed_size >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/
-
-    // Add ZIP64 extra info field for uncompressed size
-    if(uncompressed_size >= 0xffffffff)
-      datasize += 8;
-
-    // Add ZIP64 extra info field for compressed size
-    if(compressed_size >= 0xffffffff)
-      datasize += 8;
-
-    // Add ZIP64 extra info field for relative offset to local file header of current file
-    if(zi->ci.pos_local_header >= 0xffffffff)
-      datasize += 8;
-
-    if(datasize > 0)
-    {
-      char* p = NULL;
-
-      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)
-      {
-        // we can not write more data to the buffer that we have room for.
-        return ZIP_BADZIPFILE;
-      }
-
-      p = zi->ci.central_header + zi->ci.size_centralheader;
-
-      // Add Extra Information Header for 'ZIP64 information'
-      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID
-      p += 2;
-      zip64local_putValue_inmemory(p, datasize, 2); // DataSize
-      p += 2;
-
-      if(uncompressed_size >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, uncompressed_size, 8);
-        p += 8;
-      }
-
-      if(compressed_size >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, compressed_size, 8);
-        p += 8;
-      }
-
-      if(zi->ci.pos_local_header >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);
-        p += 8;
-      }
-
-      // Update how much extra free space we got in the memory buffer
-      // and increase the centralheader size so the new ZIP64 fields are included
-      // ( 4 below is the size of HeaderID and DataSize field )
-      zi->ci.size_centralExtraFree -= datasize + 4;
-      zi->ci.size_centralheader += datasize + 4;
-
-      // Update the extra info size field
-      zi->ci.size_centralExtra += datasize + 4;
-      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);
-    }
-
-    if (err==ZIP_OK)
-        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);
-
-    free(zi->ci.central_header);
-
-    if (err==ZIP_OK)
-    {
-        // Update the LocalFileHeader with the new values.
-
-        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
-
-        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-
-        if (err==ZIP_OK)
-            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
-
-        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )
-        {
-          if(zi->ci.pos_zip64extrainfo > 0)
-          {
-            // Update the size in the ZIP64 extended field.
-            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)
-              err = ZIP_ERRNO;
-
-            if (err==ZIP_OK) /* compressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);
-
-            if (err==ZIP_OK) /* uncompressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);
-          }
-          else
-              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal
-        }
-        else
-        {
-          if (err==ZIP_OK) /* compressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
-
-          if (err==ZIP_OK) /* uncompressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
-        }
-
-        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-    }
-
-    zi->number_entry ++;
-    zi->in_opened_file_inzip = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZip (zipFile file)
-{
-    return zipCloseFileInZipRaw (file,0,0);
-}
-
-int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
-{
-  int err = ZIP_OK;
-  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);
-
-  /*num disks*/
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  /*relative offset*/
-    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);
-
-  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);
-
-    return err;
-}
-
-int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
-{
-  int err = ZIP_OK;
-
-  uLong Zip64DataSize = 44;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);
-
-  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?
-
-  if (err==ZIP_OK) /* version made by */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);
-
-  if (err==ZIP_OK) /* version needed */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);
-
-  if (err==ZIP_OK) /* number of this disk */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir */
-    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
-
-  if (err==ZIP_OK) /* size of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);
-
-  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
-  {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);
-  }
-  return err;
-}
-int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
-{
-  int err = ZIP_OK;
-
-  /*signature*/
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
-
-  if (err==ZIP_OK) /* number of this disk */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-  {
-    {
-      if(zi->number_entry >= 0xFFFF)
-        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record
-      else
-        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-    }
-  }
-
-  if (err==ZIP_OK) /* total number of entries in the central dir */
-  {
-    if(zi->number_entry >= 0xFFFF)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-  }
-
-  if (err==ZIP_OK) /* size of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);
-
-  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
-  {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
-    if(pos >= 0xffffffff)
-    {
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);
-    }
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset),4);
-  }
-
-   return err;
-}
-
-int Write_GlobalComment(zip64_internal* zi, const char* global_comment)
-{
-  int err = ZIP_OK;
-  uInt size_global_comment = 0;
-
-  if(global_comment != NULL)
-    size_global_comment = (uInt)strlen(global_comment);
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);
-
-  if (err == ZIP_OK && size_global_comment > 0)
-  {
-    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)
-      err = ZIP_ERRNO;
-  }
-  return err;
-}
-
-extern int ZEXPORT zipClose (zipFile file, const char* global_comment)
-{
-    zip64_internal* zi;
-    int err = 0;
-    uLong size_centraldir = 0;
-    ZPOS64_T centraldir_pos_inzip;
-    ZPOS64_T pos;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-    }
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    if (global_comment==NULL)
-        global_comment = zi->globalcomment;
-#endif
-
-    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
-
-    if (err==ZIP_OK)
-    {
-        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;
-        while (ldi!=NULL)
-        {
-            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
-            {
-                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)
-                    err = ZIP_ERRNO;
-            }
-
-            size_centraldir += ldi->filled_in_this_block;
-            ldi = ldi->next_datablock;
-        }
-    }
-    free_linkedlist(&(zi->central_dir));
-
-    pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;
-    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)
-    {
-      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);
-      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
-
-      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
-    }
-
-    if (err==ZIP_OK)
-      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
-
-    if(err == ZIP_OK)
-      err = Write_GlobalComment(zi, global_comment);
-
-    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)
-        if (err == ZIP_OK)
-            err = ZIP_ERRNO;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    TRYFREE(zi->globalcomment);
-#endif
-    TRYFREE(zi);
-
-    return err;
-}
-
-extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)
-{
-  char* p = pData;
-  int size = 0;
-  char* pNewHeader;
-  char* pTmp;
-  short header;
-  short dataSize;
-
-  int retVal = ZIP_OK;
-
-  if(pData == NULL || *dataLen < 4)
-    return ZIP_PARAMERROR;
-
-  pNewHeader = (char*)ALLOC(*dataLen);
-  pTmp = pNewHeader;
-
-  while(p < (pData + *dataLen))
-  {
-    header = *(short*)p;
-    dataSize = *(((short*)p)+1);
-
-    if( header == sHeader ) // Header found.
-    {
-      p += dataSize + 4; // skip it. do not copy to temp buffer
-    }
-    else
-    {
-      // Extra Info block should not be removed, So copy it to the temp buffer.
-      memcpy(pTmp, p, dataSize + 4);
-      p += dataSize + 4;
-      size += dataSize + 4;
-    }
-
-  }
-
-  if(size < *dataLen)
-  {
-    // clean old extra info block.
-    memset(pData,0, *dataLen);
-
-    // copy the new extra info block over the old
-    if(size > 0)
-      memcpy(pData, pNewHeader, size);
-
-    // set the new extra info size
-    *dataLen = size;
-
-    retVal = ZIP_OK;
-  }
-  else
-    retVal = ZIP_ERRNO;
-
-  TRYFREE(pNewHeader);
-
-  return retVal;
-}
diff --git a/contrib/zlib/contrib/minizip/zip.h b/contrib/zlib/contrib/minizip/zip.h
deleted file mode 100644
index 8aaebb623..000000000
--- a/contrib/zlib/contrib/minizip/zip.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/* zip.h -- IO on .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-        ---------------------------------------------------------------------------
-
-        Changes
-
-        See header of zip.h
-
-*/
-
-#ifndef _zip12_H
-#define _zip12_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//#define HAVE_BZIP2
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__;
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                          (0)
-#define ZIP_EOF                         (0)
-#define ZIP_ERRNO                       (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_BADZIPFILE                  (-103)
-#define ZIP_INTERNALERROR               (-104)
-
-#ifndef DEF_MEM_LEVEL
-#  if MAX_MEM_LEVEL >= 8
-#    define DEF_MEM_LEVEL 8
-#  else
-#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#  endif
-#endif
-/* default memLevel */
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-    tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-typedef const char* zipcharpc;
-
-
-#define APPEND_STATUS_CREATE        (0)
-#define APPEND_STATUS_CREATEAFTER   (1)
-#define APPEND_STATUS_ADDINZIP      (2)
-
-extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
-extern zipFile ZEXPORT zipOpen64 OF((const void *pathname, int append));
-/*
-  Create a zipfile.
-     pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
-       an Unix computer "zlib/zlib113.zip".
-     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
-       will be created at the end of the file.
-         (useful if the file contain a self extractor code)
-     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
-       add files in existing zip (be sure you don't add file that doesn't exist)
-     If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-       of this zip package.
-*/
-
-/* Note : there is no delete function into a zipfile.
-   If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
-*/
-
-extern zipFile ZEXPORT zipOpen2 OF((const char *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc_def* pzlib_filefunc_def));
-
-extern zipFile ZEXPORT zipOpen2_64 OF((const void *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc64_def* pzlib_filefunc_def));
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level));
-
-extern int ZEXPORT zipOpenNewFileInZip64 OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level,
-                       int zip64));
-
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-  zip64 is set to 1 if a zip64 extended information block should be added to the local file header.
-                    this MUST be '1' if the uncompressed size is >= 0xffffffff.
-
-*/
-
-
-extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw));
-
-
-extern int ZEXPORT zipOpenNewFileInZip2_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int zip64));
-/*
-  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
- */
-
-extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting));
-
-extern int ZEXPORT zipOpenNewFileInZip3_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            int zip64
-                                            ));
-
-/*
-  Same than zipOpenNewFileInZip2, except
-    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
-    password : crypting password (NULL for no crypting)
-    crcForCrypting : crc of file to compress (needed for crypting)
- */
-
-extern int ZEXPORT zipOpenNewFileInZip4 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase
-                                            ));
-
-
-extern int ZEXPORT zipOpenNewFileInZip4_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase,
-                                            int zip64
-                                            ));
-/*
-  Same than zipOpenNewFileInZip4, except
-    versionMadeBy : value for Version made by field
-    flag : value for flag field (compression level info will be added)
- */
-
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-                       const void* buf,
-                       unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
-                                            uLong uncompressed_size,
-                                            uLong crc32));
-
-extern int ZEXPORT zipCloseFileInZipRaw64 OF((zipFile file,
-                                            ZPOS64_T uncompressed_size,
-                                            uLong crc32));
-
-/*
-  Close the current file in the zipfile, for file opened with
-    parameter raw=1 in zipOpenNewFileInZip2
-  uncompressed_size and crc32 are value for the uncompressed size
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-                const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-
-extern int ZEXPORT zipRemoveExtraInfoBlock OF((char* pData, int* dataLen, short sHeader));
-/*
-  zipRemoveExtraInfoBlock -  Added by Mathias Svensson
-
-  Remove extra information block from a extra information data for the local file header or central directory header
-
-  It is needed to remove ZIP64 extra information blocks when before data is written if using RAW mode.
-
-  0x0001 is the signature header for the ZIP64 extra information blocks
-
-  usage.
-                        Remove ZIP64 Extra information from a central director extra field data
-              zipRemoveExtraInfoBlock(pCenDirExtraFieldData, &nCenDirExtraFieldDataLen, 0x0001);
-
-                        Remove ZIP64 Extra information from a Local File Header extra field data
-        zipRemoveExtraInfoBlock(pLocalHeaderExtraFieldData, &nLocalHeaderExtraFieldDataLen, 0x0001);
-*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip64_H */
diff --git a/contrib/zlib/contrib/pascal/example.pas b/contrib/zlib/contrib/pascal/example.pas
deleted file mode 100644
index 5518b36a7..000000000
--- a/contrib/zlib/contrib/pascal/example.pas
+++ /dev/null
@@ -1,599 +0,0 @@
-(* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2003 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Pascal translation
- * Copyright (C) 1998 by Jacques Nomssi Nzali.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *
- * Adaptation to the zlibpas interface
- * Copyright (C) 2003 by Cosmin Truta.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-program example;
-
-{$DEFINE TEST_COMPRESS}
-{DO NOT $DEFINE TEST_GZIO}
-{$DEFINE TEST_DEFLATE}
-{$DEFINE TEST_INFLATE}
-{$DEFINE TEST_FLUSH}
-{$DEFINE TEST_SYNC}
-{$DEFINE TEST_DICT}
-
-uses SysUtils, zlibpas;
-
-const TESTFILE = 'foo.gz';
-
-(* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- *)
-const hello: PChar = 'hello, hello!';
-
-const dictionary: PChar = 'hello';
-
-var dictId: LongInt; (* Adler32 value of the dictionary *)
-
-procedure CHECK_ERR(err: Integer; msg: String);
-begin
-  if err <> Z_OK then
-  begin
-    WriteLn(msg, ' error: ', err);
-    Halt(1);
-  end;
-end;
-
-procedure EXIT_ERR(const msg: String);
-begin
-  WriteLn('Error: ', msg);
-  Halt(1);
-end;
-
-(* ===========================================================================
- * Test compress and uncompress
- *)
-{$IFDEF TEST_COMPRESS}
-procedure test_compress(compr: Pointer; comprLen: LongInt;
-                        uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  err := compress(compr, comprLen, hello, len);
-  CHECK_ERR(err, 'compress');
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  err := uncompress(uncompr, uncomprLen, compr, comprLen);
-  CHECK_ERR(err, 'uncompress');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad uncompress')
-  else
-    WriteLn('uncompress(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test read/write of .gz files
- *)
-{$IFDEF TEST_GZIO}
-procedure test_gzio(const fname: PChar; (* compressed file name *)
-                    uncompr: Pointer;
-                    uncomprLen: LongInt);
-var err: Integer;
-    len: Integer;
-    zfile: gzFile;
-    pos: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  zfile := gzopen(fname, 'wb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-  gzputc(zfile, 'h');
-  if gzputs(zfile, 'ello') <> 4 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$IFDEF GZ_FORMAT_STRING}
-  if gzprintf(zfile, ', %s!', 'hello') <> 8 then
-  begin
-    WriteLn('gzprintf err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ELSE}
-  if gzputs(zfile, ', hello!') <> 8 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ENDIF}
-  gzseek(zfile, 1, SEEK_CUR); (* add one zero byte *)
-  gzclose(zfile);
-
-  zfile := gzopen(fname, 'rb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  if gzread(zfile, uncompr, uncomprLen) <> len then
-  begin
-    WriteLn('gzread err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello) <> 0 then
-  begin
-    WriteLn('bad gzread: ', PChar(uncompr));
-    Halt(1);
-  end
-  else
-    WriteLn('gzread(): ', PChar(uncompr));
-
-  pos := gzseek(zfile, -8, SEEK_CUR);
-  if (pos <> 6) or (gztell(zfile) <> pos) then
-  begin
-    WriteLn('gzseek error, pos=', pos, ', gztell=', gztell(zfile));
-    Halt(1);
-  end;
-
-  if gzgetc(zfile) <> ' ' then
-  begin
-    WriteLn('gzgetc error');
-    Halt(1);
-  end;
-
-  if gzungetc(' ', zfile) <> ' ' then
-  begin
-    WriteLn('gzungetc error');
-    Halt(1);
-  end;
-
-  gzgets(zfile, PChar(uncompr), uncomprLen);
-  uncomprLen := StrLen(PChar(uncompr));
-  if uncomprLen <> 7 then (* " hello!" *)
-  begin
-    WriteLn('gzgets err after gzseek: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello + 6) <> 0 then
-  begin
-    WriteLn('bad gzgets after gzseek');
-    Halt(1);
-  end
-  else
-    WriteLn('gzgets() after gzseek: ', PChar(uncompr));
-
-  gzclose(zfile);
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with small buffers
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-
-  while (c_stream.total_in <> len) and
-        (c_stream.total_out < comprLen) do
-  begin
-    c_stream.avail_out := 1; { force small buffers }
-    c_stream.avail_in := 1;
-    err := deflate(c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  (* Finish the stream, still forcing small buffers: *)
-  while TRUE do
-  begin
-    c_stream.avail_out := 1;
-    err := deflate(c_stream, Z_FINISH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with small buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_inflate(compr: Pointer; comprLen : LongInt;
-                       uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 0;
-  d_stream.next_out := uncompr;
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while (d_stream.total_out < uncomprLen) and
-        (d_stream.total_in < comprLen) do
-  begin
-    d_stream.avail_out := 1; (* force small buffers *)
-    d_stream.avail_in := 1;
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate')
-  else
-    WriteLn('inflate(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with large buffers and dynamic change of compression level
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_large_deflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_SPEED);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  (* At this point, uncompr is still mostly zeroes, so it should compress
-   * very well:
-   *)
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-  if c_stream.avail_in <> 0 then
-    EXIT_ERR('deflate not greedy');
-
-  (* Feed in already compressed data and switch to no compression: *)
-  deflateParams(c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-  c_stream.next_in := compr;
-  c_stream.avail_in := Integer(comprLen div 2);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  (* Switch back to compressing mode: *)
-  deflateParams(c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with large buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_large_inflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while TRUE do
-  begin
-    d_stream.next_out := uncompr;            (* discard the output *)
-    d_stream.avail_out := Integer(uncomprLen);
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'large inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if d_stream.total_out <> 2 * uncomprLen + comprLen div 2 then
-  begin
-    WriteLn('bad large inflate: ', d_stream.total_out);
-    Halt(1);
-  end
-  else
-    WriteLn('large_inflate(): OK');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with full flush
- *)
-{$IFDEF TEST_FLUSH}
-procedure test_flush(compr: Pointer; var comprLen : LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: Integer;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-  c_stream.avail_in := 3;
-  c_stream.avail_out := Integer(comprLen);
-  err := deflate(c_stream, Z_FULL_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  Inc(PByteArray(compr)^[3]); (* force an error in first compressed block *)
-  c_stream.avail_in := len - 3;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    CHECK_ERR(err, 'deflate');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-
-  comprLen := c_stream.total_out;
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflateSync()
- *)
-{$IFDEF TEST_SYNC}
-procedure test_sync(compr: Pointer; comprLen: LongInt;
-                    uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 2; (* just read the zlib header *)
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  inflate(d_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'inflate');
-
-  d_stream.avail_in := Integer(comprLen-2);   (* read all compressed data *)
-  err := inflateSync(d_stream);               (* but skip the damaged part *)
-  CHECK_ERR(err, 'inflateSync');
-
-  err := inflate(d_stream, Z_FINISH);
-  if err <> Z_DATA_ERROR then
-    EXIT_ERR('inflate should report DATA_ERROR');
-    (* Because of incorrect adler32 *)
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  WriteLn('after inflateSync(): hel', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  err := deflateSetDictionary(c_stream, dictionary, StrLen(dictionary));
-  CHECK_ERR(err, 'deflateSetDictionary');
-
-  dictId := c_stream.adler;
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  c_stream.next_in := hello;
-  c_stream.avail_in := StrLen(hello)+1;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with a preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_inflate(compr: Pointer; comprLen: LongInt;
-                            uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  while TRUE do
-  begin
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    if err = Z_NEED_DICT then
-    begin
-      if d_stream.adler <> dictId then
-        EXIT_ERR('unexpected dictionary');
-      err := inflateSetDictionary(d_stream, dictionary, StrLen(dictionary));
-    end;
-    CHECK_ERR(err, 'inflate with dict');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate with dict')
-  else
-    WriteLn('inflate with dictionary: ', PChar(uncompr));
-end;
-{$ENDIF}
-
-var compr, uncompr: Pointer;
-    comprLen, uncomprLen: LongInt;
-
-begin
-  if zlibVersion^ <> ZLIB_VERSION[1] then
-    EXIT_ERR('Incompatible zlib version');
-
-  WriteLn('zlib version: ', zlibVersion);
-  WriteLn('zlib compile flags: ', Format('0x%x', [zlibCompileFlags]));
-
-  comprLen := 10000 * SizeOf(Integer); (* don't overflow on MSDOS *)
-  uncomprLen := comprLen;
-  GetMem(compr, comprLen);
-  GetMem(uncompr, uncomprLen);
-  if (compr = NIL) or (uncompr = NIL) then
-    EXIT_ERR('Out of memory');
-  (* compr and uncompr are cleared to avoid reading uninitialized
-   * data and to ensure that uncompr compresses well.
-   *)
-  FillChar(compr^, comprLen, 0);
-  FillChar(uncompr^, uncomprLen, 0);
-
-  {$IFDEF TEST_COMPRESS}
-  WriteLn('** Testing compress');
-  test_compress(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_GZIO}
-  WriteLn('** Testing gzio');
-  if ParamCount >= 1 then
-    test_gzio(ParamStr(1), uncompr, uncomprLen)
-  else
-    test_gzio(TESTFILE, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with small buffers');
-  test_deflate(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with small buffers');
-  test_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with large buffers');
-  test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with large buffers');
-  test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_FLUSH}
-  WriteLn('** Testing deflate with full flush');
-  test_flush(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_SYNC}
-  WriteLn('** Testing inflateSync');
-  test_sync(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  comprLen := uncomprLen;
-
-  {$IFDEF TEST_DICT}
-  WriteLn('** Testing deflate and inflate with preset dictionary');
-  test_dict_deflate(compr, comprLen);
-  test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  FreeMem(compr, comprLen);
-  FreeMem(uncompr, uncomprLen);
-end.
diff --git a/contrib/zlib/contrib/pascal/readme.txt b/contrib/zlib/contrib/pascal/readme.txt
deleted file mode 100644
index 60e87c8a3..000000000
--- a/contrib/zlib/contrib/pascal/readme.txt
+++ /dev/null
@@ -1,76 +0,0 @@
-
-This directory contains a Pascal (Delphi, Kylix) interface to the
-zlib data compression library.
-
-
-Directory listing
-=================
-
-zlibd32.mak     makefile for Borland C++
-example.pas     usage example of zlib
-zlibpas.pas     the Pascal interface to zlib
-readme.txt      this file
-
-
-Compatibility notes
-===================
-
-- Although the name "zlib" would have been more normal for the
-  zlibpas unit, this name is already taken by Borland's ZLib unit.
-  This is somehow unfortunate, because that unit is not a genuine
-  interface to the full-fledged zlib functionality, but a suite of
-  class wrappers around zlib streams.  Other essential features,
-  such as checksums, are missing.
-  It would have been more appropriate for that unit to have a name
-  like "ZStreams", or something similar.
-
-- The C and zlib-supplied types int, uInt, long, uLong, etc. are
-  translated directly into Pascal types of similar sizes (Integer,
-  LongInt, etc.), to avoid namespace pollution.  In particular,
-  there is no conversion of unsigned int into a Pascal unsigned
-  integer.  The Word type is non-portable and has the same size
-  (16 bits) both in a 16-bit and in a 32-bit environment, unlike
-  Integer.  Even if there is a 32-bit Cardinal type, there is no
-  real need for unsigned int in zlib under a 32-bit environment.
-
-- Except for the callbacks, the zlib function interfaces are
-  assuming the calling convention normally used in Pascal
-  (__pascal for DOS and Windows16, __fastcall for Windows32).
-  Since the cdecl keyword is used, the old Turbo Pascal does
-  not work with this interface.
-
-- The gz* function interfaces are not translated, to avoid
-  interfacing problems with the C runtime library.  Besides,
-    gzprintf(gzFile file, const char *format, ...)
-  cannot be translated into Pascal.
-
-
-Legal issues
-============
-
-The zlibpas interface is:
-  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler.
-  Copyright (C) 1998 by Bob Dellaca.
-  Copyright (C) 2003 by Cosmin Truta.
-
-The example program is:
-  Copyright (C) 1995-2003 by Jean-loup Gailly.
-  Copyright (C) 1998,1999,2000 by Jacques Nomssi Nzali.
-  Copyright (C) 2003 by Cosmin Truta.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
diff --git a/contrib/zlib/contrib/pascal/zlibd32.mak b/contrib/zlib/contrib/pascal/zlibd32.mak
deleted file mode 100644
index 9bb00b7cc..000000000
--- a/contrib/zlib/contrib/pascal/zlibd32.mak
+++ /dev/null
@@ -1,99 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff --git a/contrib/zlib/contrib/pascal/zlibpas.pas b/contrib/zlib/contrib/pascal/zlibpas.pas
deleted file mode 100644
index a0dff11b5..000000000
--- a/contrib/zlib/contrib/pascal/zlibpas.pas
+++ /dev/null
@@ -1,276 +0,0 @@
-(* zlibpas -- Pascal interface to the zlib data compression library
- *
- * Copyright (C) 2003 Cosmin Truta.
- * Derived from original sources by Bob Dellaca.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-unit zlibpas;
-
-interface
-
-const
-  ZLIB_VERSION = '1.2.11';
-  ZLIB_VERNUM  = $12a0;
-
-type
-  alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;
-                 cdecl;
-  free_func  = procedure(opaque, address: Pointer);
-                 cdecl;
-
-  in_func    = function(opaque: Pointer; var buf: PByte): Integer;
-                 cdecl;
-  out_func   = function(opaque: Pointer; buf: PByte; size: Integer): Integer;
-                 cdecl;
-
-  z_streamp = ^z_stream;
-  z_stream = packed record
-    next_in: PChar;       (* next input byte *)
-    avail_in: Integer;    (* number of bytes available at next_in *)
-    total_in: LongInt;    (* total nb of input bytes read so far *)
-
-    next_out: PChar;      (* next output byte should be put there *)
-    avail_out: Integer;   (* remaining free space at next_out *)
-    total_out: LongInt;   (* total nb of bytes output so far *)
-
-    msg: PChar;           (* last error message, NULL if no error *)
-    state: Pointer;       (* not visible by applications *)
-
-    zalloc: alloc_func;   (* used to allocate the internal state *)
-    zfree: free_func;     (* used to free the internal state *)
-    opaque: Pointer;      (* private data object passed to zalloc and zfree *)
-
-    data_type: Integer;   (* best guess about the data type: ascii or binary *)
-    adler: LongInt;       (* adler32 value of the uncompressed data *)
-    reserved: LongInt;    (* reserved for future use *)
-  end;
-
-  gz_headerp = ^gz_header;
-  gz_header = packed record
-    text: Integer;        (* true if compressed data believed to be text *)
-    time: LongInt;        (* modification time *)
-    xflags: Integer;      (* extra flags (not used when writing a gzip file) *)
-    os: Integer;          (* operating system *)
-    extra: PChar;         (* pointer to extra field or Z_NULL if none *)
-    extra_len: Integer;   (* extra field length (valid if extra != Z_NULL) *)
-    extra_max: Integer;   (* space at extra (only when reading header) *)
-    name: PChar;          (* pointer to zero-terminated file name or Z_NULL *)
-    name_max: Integer;    (* space at name (only when reading header) *)
-    comment: PChar;       (* pointer to zero-terminated comment or Z_NULL *)
-    comm_max: Integer;    (* space at comment (only when reading header) *)
-    hcrc: Integer;        (* true if there was or will be a header crc *)
-    done: Integer;        (* true when done reading gzip header *)
-  end;
-
-(* constants *)
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-  Z_BLOCK         = 5;
-  Z_TREES         = 6;
-
-  Z_OK            =  0;
-  Z_STREAM_END    =  1;
-  Z_NEED_DICT     =  2;
-  Z_ERRNO         = -1;
-  Z_STREAM_ERROR  = -2;
-  Z_DATA_ERROR    = -3;
-  Z_MEM_ERROR     = -4;
-  Z_BUF_ERROR     = -5;
-  Z_VERSION_ERROR = -6;
-
-  Z_NO_COMPRESSION       =  0;
-  Z_BEST_SPEED           =  1;
-  Z_BEST_COMPRESSION     =  9;
-  Z_DEFAULT_COMPRESSION  = -1;
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_FIXED               = 4;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_TEXT     = 1;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-(* basic functions *)
-function zlibVersion: PChar;
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-function deflate(var strm: z_stream; flush: Integer): Integer;
-function deflateEnd(var strm: z_stream): Integer;
-function inflateInit(var strm: z_stream): Integer;
-function inflate(var strm: z_stream; flush: Integer): Integer;
-function inflateEnd(var strm: z_stream): Integer;
-
-(* advanced functions *)
-function deflateInit2(var strm: z_stream; level, method, windowBits,
-                      memLevel, strategy: Integer): Integer;
-function deflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function deflateCopy(var dest, source: z_stream): Integer;
-function deflateReset(var strm: z_stream): Integer;
-function deflateParams(var strm: z_stream; level, strategy: Integer): Integer;
-function deflateTune(var strm: z_stream; good_length, max_lazy, nice_length, max_chain: Integer): Integer;
-function deflateBound(var strm: z_stream; sourceLen: LongInt): LongInt;
-function deflatePending(var strm: z_stream; var pending: Integer; var bits: Integer): Integer;
-function deflatePrime(var strm: z_stream; bits, value: Integer): Integer;
-function deflateSetHeader(var strm: z_stream; head: gz_header): Integer;
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-function inflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function inflateSync(var strm: z_stream): Integer;
-function inflateCopy(var dest, source: z_stream): Integer;
-function inflateReset(var strm: z_stream): Integer;
-function inflateReset2(var strm: z_stream; windowBits: Integer): Integer;
-function inflatePrime(var strm: z_stream; bits, value: Integer): Integer;
-function inflateMark(var strm: z_stream): LongInt;
-function inflateGetHeader(var strm: z_stream; var head: gz_header): Integer;
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-function inflateBack(var strm: z_stream; in_fn: in_func; in_desc: Pointer;
-                     out_fn: out_func; out_desc: Pointer): Integer;
-function inflateBackEnd(var strm: z_stream): Integer;
-function zlibCompileFlags: LongInt;
-
-(* utility functions *)
-function compress(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt): Integer;
-function compress2(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt;
-                  level: Integer): Integer;
-function compressBound(sourceLen: LongInt): LongInt;
-function uncompress(dest: PChar; var destLen: LongInt;
-                    const source: PChar; sourceLen: LongInt): Integer;
-
-(* checksum functions *)
-function adler32(adler: LongInt; const buf: PChar; len: Integer): LongInt;
-function adler32_combine(adler1, adler2, len2: LongInt): LongInt;
-function crc32(crc: LongInt; const buf: PChar; len: Integer): LongInt;
-function crc32_combine(crc1, crc2, len2: LongInt): LongInt;
-
-(* various hacks, don't look :) *)
-function deflateInit_(var strm: z_stream; level: Integer;
-                      const version: PChar; stream_size: Integer): Integer;
-function inflateInit_(var strm: z_stream; const version: PChar;
-                      stream_size: Integer): Integer;
-function deflateInit2_(var strm: z_stream;
-                       level, method, windowBits, memLevel, strategy: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateInit2_(var strm: z_stream; windowBits: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateBackInit_(var strm: z_stream;
-                          windowBits: Integer; window: PChar;
-                          const version: PChar; stream_size: Integer): Integer;
-
-
-implementation
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-function adler32; external;
-function adler32_combine; external;
-function compress; external;
-function compress2; external;
-function compressBound; external;
-function crc32; external;
-function crc32_combine; external;
-function deflate; external;
-function deflateBound; external;
-function deflateCopy; external;
-function deflateEnd; external;
-function deflateInit_; external;
-function deflateInit2_; external;
-function deflateParams; external;
-function deflatePending; external;
-function deflatePrime; external;
-function deflateReset; external;
-function deflateSetDictionary; external;
-function deflateSetHeader; external;
-function deflateTune; external;
-function inflate; external;
-function inflateBack; external;
-function inflateBackEnd; external;
-function inflateBackInit_; external;
-function inflateCopy; external;
-function inflateEnd; external;
-function inflateGetHeader; external;
-function inflateInit_; external;
-function inflateInit2_; external;
-function inflateMark; external;
-function inflatePrime; external;
-function inflateReset; external;
-function inflateReset2; external;
-function inflateSetDictionary; external;
-function inflateSync; external;
-function uncompress; external;
-function zlibCompileFlags; external;
-function zlibVersion; external;
-
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-begin
-  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function deflateInit2(var strm: z_stream; level, method, windowBits, memLevel,
-                      strategy: Integer): Integer;
-begin
-  Result := deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                          ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit(var strm: z_stream): Integer;
-begin
-  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-begin
-  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-begin
-  Result := inflateBackInit_(strm, windowBits, window,
-                             ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  GetMem(Result, Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-end.
diff --git a/contrib/zlib/contrib/puff/README b/contrib/zlib/contrib/puff/README
deleted file mode 100644
index bbc4cb595..000000000
--- a/contrib/zlib/contrib/puff/README
+++ /dev/null
@@ -1,63 +0,0 @@
-Puff -- A Simple Inflate
-3 Mar 2003
-Mark Adler
-madler@alumni.caltech.edu
-
-What this is --
-
-puff.c provides the routine puff() to decompress the deflate data format.  It
-does so more slowly than zlib, but the code is about one-fifth the size of the
-inflate code in zlib, and written to be very easy to read.
-
-Why I wrote this --
-
-puff.c was written to document the deflate format unambiguously, by virtue of
-being working C code.  It is meant to supplement RFC 1951, which formally
-describes the deflate format.  I have received many questions on details of the
-deflate format, and I hope that reading this code will answer those questions.
-puff.c is heavily commented with details of the deflate format, especially
-those little nooks and cranies of the format that might not be obvious from a
-specification.
-
-puff.c may also be useful in applications where code size or memory usage is a
-very limited resource, and speed is not as important.
-
-How to use it --
-
-Well, most likely you should just be reading puff.c and using zlib for actual
-applications, but if you must ...
-
-Include puff.h in your code, which provides this prototype:
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         unsigned char *source,         /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
-
-Then you can call puff() to decompress a deflate stream that is in memory in
-its entirety at source, to a sufficiently sized block of memory for the
-decompressed data at dest.  puff() is the only external symbol in puff.c  The
-only C library functions that puff.c needs are setjmp() and longjmp(), which
-are used to simplify error checking in the code to improve readabilty.  puff.c
-does no memory allocation, and uses less than 2K bytes off of the stack.
-
-If destlen is not enough space for the uncompressed data, then inflate will
-return an error without writing more than destlen bytes.  Note that this means
-that in order to decompress the deflate data successfully, you need to know
-the size of the uncompressed data ahead of time.
-
-If needed, puff() can determine the size of the uncompressed data with no
-output space.  This is done by passing dest equal to (unsigned char *)0.  Then
-the initial value of *destlen is ignored and *destlen is set to the length of
-the uncompressed data.  So if the size of the uncompressed data is not known,
-then two passes of puff() can be used--first to determine the size, and second
-to do the actual inflation after allocating the appropriate memory.  Not
-pretty, but it works.  (This is one of the reasons you should be using zlib.)
-
-The deflate format is self-terminating.  If the deflate stream does not end
-in *sourcelen bytes, puff() will return an error without reading at or past
-endsource.
-
-On return, *sourcelen is updated to the amount of input data consumed, and
-*destlen is updated to the size of the uncompressed data.  See the comments
-in puff.c for the possible return codes for puff().
diff --git a/contrib/zlib/contrib/puff/puff.c b/contrib/zlib/contrib/puff/puff.c
deleted file mode 100644
index c6c90d714..000000000
--- a/contrib/zlib/contrib/puff/puff.c
+++ /dev/null
@@ -1,840 +0,0 @@
-/*
- * puff.c
- * Copyright (C) 2002-2013 Mark Adler
- * For conditions of distribution and use, see copyright notice in puff.h
- * version 2.3, 21 Jan 2013
- *
- * puff.c is a simple inflate written to be an unambiguous way to specify the
- * deflate format.  It is not written for speed but rather simplicity.  As a
- * side benefit, this code might actually be useful when small code is more
- * important than speed, such as bootstrap applications.  For typical deflate
- * data, zlib's inflate() is about four times as fast as puff().  zlib's
- * inflate compiles to around 20K on my machine, whereas puff.c compiles to
- * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()
- * function here is used, then puff() is only twice as slow as zlib's
- * inflate().
- *
- * All dynamically allocated memory comes from the stack.  The stack required
- * is less than 2K bytes.  This code is compatible with 16-bit int's and
- * assumes that long's are at least 32 bits.  puff.c uses the short data type,
- * assumed to be 16 bits, for arrays in order to conserve memory.  The code
- * works whether integers are stored big endian or little endian.
- *
- * In the comments below are "Format notes" that describe the inflate process
- * and document some of the less obvious aspects of the format.  This source
- * code is meant to supplement RFC 1951, which formally describes the deflate
- * format:
- *
- *    http://www.zlib.org/rfc-deflate.html
- */
-
-/*
- * Change history:
- *
- * 1.0  10 Feb 2002     - First version
- * 1.1  17 Feb 2002     - Clarifications of some comments and notes
- *                      - Update puff() dest and source pointers on negative
- *                        errors to facilitate debugging deflators
- *                      - Remove longest from struct huffman -- not needed
- *                      - Simplify offs[] index in construct()
- *                      - Add input size and checking, using longjmp() to
- *                        maintain easy readability
- *                      - Use short data type for large arrays
- *                      - Use pointers instead of long to specify source and
- *                        destination sizes to avoid arbitrary 4 GB limits
- * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),
- *                        but leave simple version for readabilty
- *                      - Make sure invalid distances detected if pointers
- *                        are 16 bits
- *                      - Fix fixed codes table error
- *                      - Provide a scanning mode for determining size of
- *                        uncompressed data
- * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Gailly]
- *                      - Add a puff.h file for the interface
- *                      - Add braces in puff() for else do [Gailly]
- *                      - Use indexes instead of pointers for readability
- * 1.4  31 Mar 2002     - Simplify construct() code set check
- *                      - Fix some comments
- *                      - Add FIXLCODES #define
- * 1.5   6 Apr 2002     - Minor comment fixes
- * 1.6   7 Aug 2002     - Minor format changes
- * 1.7   3 Mar 2003     - Added test code for distribution
- *                      - Added zlib-like license
- * 1.8   9 Jan 2004     - Added some comments on no distance codes case
- * 1.9  21 Feb 2008     - Fix bug on 16-bit integer architectures [Pohland]
- *                      - Catch missing end-of-block symbol error
- * 2.0  25 Jul 2008     - Add #define to permit distance too far back
- *                      - Add option in TEST code for puff to write the data
- *                      - Add option in TEST code to skip input bytes
- *                      - Allow TEST code to read from piped stdin
- * 2.1   4 Apr 2010     - Avoid variable initialization for happier compilers
- *                      - Avoid unsigned comparisons for even happier compilers
- * 2.2  25 Apr 2010     - Fix bug in variable initializations [Oberhumer]
- *                      - Add const where appropriate [Oberhumer]
- *                      - Split if's and ?'s for coverage testing
- *                      - Break out test code to separate file
- *                      - Move NIL to puff.h
- *                      - Allow incomplete code only if single code length is 1
- *                      - Add full code coverage test to Makefile
- * 2.3  21 Jan 2013     - Check for invalid code length codes in dynamic blocks
- */
-
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "puff.h"               /* prototype for puff() */
-
-#define local static            /* for local function definitions */
-
-/*
- * Maximums for allocations and loops.  It is not useful to change these --
- * they are fixed by the deflate format.
- */
-#define MAXBITS 15              /* maximum bits in a code */
-#define MAXLCODES 286           /* maximum number of literal/length codes */
-#define MAXDCODES 30            /* maximum number of distance codes */
-#define MAXCODES (MAXLCODES+MAXDCODES)  /* maximum codes lengths to read */
-#define FIXLCODES 288           /* number of fixed literal/length codes */
-
-/* input and output state */
-struct state {
-    /* output state */
-    unsigned char *out;         /* output buffer */
-    unsigned long outlen;       /* available space at out */
-    unsigned long outcnt;       /* bytes written to out so far */
-
-    /* input state */
-    const unsigned char *in;    /* input buffer */
-    unsigned long inlen;        /* available input at in */
-    unsigned long incnt;        /* bytes read so far */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    long val;           /* bit accumulator (can use up to 20 bits) */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->incnt == s->inlen)
-            longjmp(s->env, 1);         /* out of input */
-        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = (int)(val >> need);
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return (int)(val & ((1L << need) - 1));
-}
-
-/*
- * Process a stored block.
- *
- * Format notes:
- *
- * - After the two-bit stored block type (00), the stored block length and
- *   stored bytes are byte-aligned for fast copying.  Therefore any leftover
- *   bits in the byte that has the last bit of the type, as many as seven, are
- *   discarded.  The value of the discarded bits are not defined and should not
- *   be checked against any expectation.
- *
- * - The second inverted copy of the stored block length does not have to be
- *   checked, but it's probably a good idea to do so anyway.
- *
- * - A stored block can have zero length.  This is sometimes used to byte-align
- *   subsets of the compressed data for random access or partial recovery.
- */
-local int stored(struct state *s)
-{
-    unsigned len;       /* length of stored block */
-
-    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */
-    s->bitbuf = 0;
-    s->bitcnt = 0;
-
-    /* get length and check against its one's complement */
-    if (s->incnt + 4 > s->inlen)
-        return 2;                               /* not enough input */
-    len = s->in[s->incnt++];
-    len |= s->in[s->incnt++] << 8;
-    if (s->in[s->incnt++] != (~len & 0xff) ||
-        s->in[s->incnt++] != ((~len >> 8) & 0xff))
-        return -2;                              /* didn't match complement! */
-
-    /* copy len bytes from in to out */
-    if (s->incnt + len > s->inlen)
-        return 2;                               /* not enough input */
-    if (s->out != NIL) {
-        if (s->outcnt + len > s->outlen)
-            return 1;                           /* not enough output space */
-        while (len--)
-            s->out[s->outcnt++] = s->in[s->incnt++];
-    }
-    else {                                      /* just scanning */
-        s->outcnt += len;
-        s->incnt += len;
-    }
-
-    /* done with a valid stored block */
-    return 0;
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -10 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.  A table-based decoding
- *   scheme (as used in zlib) does not need to do this reversal.
- *
- * - The first code for the shortest length is all zeros.  Subsequent codes of
- *   the same length are simply integer increments of the previous code.  When
- *   moving up a length, a zero bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all ones.
- *
- * - Incomplete codes are handled by this decoder, since they are permitted
- *   in the deflate format.  See the format notes for fixed() and dynamic().
- */
-#ifdef SLOW
-local int decode(struct state *s, const struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-
-    code = first = index = 0;
-    for (len = 1; len <= MAXBITS; len++) {
-        code |= bits(s, 1);             /* get next bit */
-        count = h->count[len];
-        if (code - count < first)       /* if length len, return symbol */
-            return h->symbol[index + (code - first)];
-        index += count;                 /* else update for next length */
-        first += count;
-        first <<= 1;
-        code <<= 1;
-    }
-    return -10;                         /* ran out of codes */
-}
-
-/*
- * A faster version of decode() for real applications of this code.   It's not
- * as readable, but it makes puff() twice as fast.  And it only makes the code
- * a few percent larger.
- */
-#else /* !SLOW */
-local int decode(struct state *s, const struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= bitbuf & 1;
-            bitbuf >>= 1;
-            count = *next++;
-            if (code - count < first) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0)
-            break;
-        if (s->incnt == s->inlen)
-            longjmp(s->env, 1);         /* out of input */
-        bitbuf = s->in[s->incnt++];
-        if (left > 8)
-            left = 8;
-    }
-    return -10;                         /* ran out of codes */
-}
-#endif /* SLOW */
-
-/*
- * Given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- *
- * Not used by decode(), but used for error checking, h->count[0] is the number
- * of the n symbols not in the code.  So n - h->count[0] is the number of
- * codes.  This is useful for checking for incomplete codes that have more than
- * one symbol, which is an error in a dynamic block.
- *
- * Assumption: for all i in 0..n-1, 0 <= length[i] <= MAXBITS
- * This is assured by the construction of the length arrays in dynamic() and
- * fixed() and is not verified by construct().
- *
- * Format notes:
- *
- * - Permitted and expected examples of incomplete codes are one of the fixed
- *   codes and any code with a single symbol which in deflate is coded as one
- *   bit instead of zero bits.  See the format notes for fixed() and dynamic().
- *
- * - Within a given code length, the symbols are kept in ascending order for
- *   the code bits definition.
- */
-local int construct(struct huffman *h, const short *length, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0)
-            return left;                /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode literal/length and distance codes until an end-of-block code.
- *
- * Format notes:
- *
- * - Compressed data that is after the block type if fixed or after the code
- *   description if dynamic is a combination of literals and length/distance
- *   pairs terminated by and end-of-block code.  Literals are simply Huffman
- *   coded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - Literals, lengths, and the end-of-block code are combined into a single
- *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length
- *   symbols (257..285), and the end-of-block symbol (256).
- *
- * - There are 256 possible lengths (3..258), and so 29 symbols are not enough
- *   to represent all of those.  Lengths 3..10 and 258 are in fact represented
- *   by just a length symbol.  Lengths 11..257 are represented as a symbol and
- *   some number of extra bits that are added as an integer to the base length
- *   of the length symbol.  The number of extra bits is determined by the base
- *   length symbol.  These are in the static arrays below, lens[] for the base
- *   lengths and lext[] for the corresponding number of extra bits.
- *
- * - The reason that 258 gets its own symbol is that the longest length is used
- *   often in highly redundant files.  Note that 258 can also be coded as the
- *   base value 227 plus the maximum extra value of 31.  While a good deflate
- *   should never do this, it is not an error, and should be decoded properly.
- *
- * - If a length is decoded, including its extra bits if any, then it is
- *   followed a distance code.  There are up to 30 distance symbols.  Again
- *   there are many more possible distances (1..32768), so extra bits are added
- *   to a base value represented by the symbol.  The distances 1..4 get their
- *   own symbol, but the rest require extra bits.  The base distances and
- *   corresponding number of extra bits are below in the static arrays dist[]
- *   and dext[].
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 258
- *   simply copies the last byte 258 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.  You should not use memcpy() since its behavior is not
- *   defined for overlapped arrays.  You should not use memmove() or bcopy()
- *   since though their behavior -is- defined for overlapping arrays, it is
- *   defined to do the wrong thing in this case.
- */
-local int codes(struct state *s,
-                const struct huffman *lencode,
-                const struct huffman *distcode)
-{
-    int symbol;         /* decoded symbol */
-    int len;            /* length for copy */
-    unsigned dist;      /* distance for copy */
-    static const short lens[29] = { /* Size base for length codes 257..285 */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
-    static const short lext[29] = { /* Extra bits for length codes 257..285 */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
-    static const short dists[30] = { /* Offset base for distance codes 0..29 */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
-    static const short dext[30] = { /* Extra bits for distance codes 0..29 */
-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
-
-    /* decode literals and length/distance pairs */
-    do {
-        symbol = decode(s, lencode);
-        if (symbol < 0)
-            return symbol;              /* invalid symbol */
-        if (symbol < 256) {             /* literal: symbol is the byte */
-            /* write out the literal */
-            if (s->out != NIL) {
-                if (s->outcnt == s->outlen)
-                    return 1;
-                s->out[s->outcnt] = symbol;
-            }
-            s->outcnt++;
-        }
-        else if (symbol > 256) {        /* length */
-            /* get and compute length */
-            symbol -= 257;
-            if (symbol >= 29)
-                return -10;             /* invalid fixed code */
-            len = lens[symbol] + bits(s, lext[symbol]);
-
-            /* get and check distance */
-            symbol = decode(s, distcode);
-            if (symbol < 0)
-                return symbol;          /* invalid symbol */
-            dist = dists[symbol] + bits(s, dext[symbol]);
-#ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-            if (dist > s->outcnt)
-                return -11;     /* distance too far back */
-#endif
-
-            /* copy length bytes from distance bytes back */
-            if (s->out != NIL) {
-                if (s->outcnt + len > s->outlen)
-                    return 1;
-                while (len--) {
-                    s->out[s->outcnt] =
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        dist > s->outcnt ?
-                            0 :
-#endif
-                            s->out[s->outcnt - dist];
-                    s->outcnt++;
-                }
-            }
-            else
-                s->outcnt += len;
-        }
-    } while (symbol != 256);            /* end of block symbol */
-
-    /* done with a valid fixed or dynamic block */
-    return 0;
-}
-
-/*
- * Process a fixed codes block.
- *
- * Format notes:
- *
- * - This block type can be useful for compressing small amounts of data for
- *   which the size of the code descriptions in a dynamic block exceeds the
- *   benefit of custom codes for that block.  For fixed codes, no bits are
- *   spent on code descriptions.  Instead the code lengths for literal/length
- *   codes and distance codes are fixed.  The specific lengths for each symbol
- *   can be seen in the "for" loops below.
- *
- * - The literal/length code is complete, but has two symbols that are invalid
- *   and should result in an error if received.  This cannot be implemented
- *   simply as an incomplete code since those two symbols are in the "middle"
- *   of the code.  They are eight bits long and the longest literal/length\
- *   code is nine bits.  Therefore the code must be constructed with those
- *   symbols, and the invalid symbols must be detected after decoding.
- *
- * - The fixed distance codes also have two invalid symbols that should result
- *   in an error if received.  Since all of the distance codes are the same
- *   length, this can be implemented as an incomplete code.  Then the invalid
- *   codes are detected while decoding.
- */
-local int fixed(struct state *s)
-{
-    static int virgin = 1;
-    static short lencnt[MAXBITS+1], lensym[FIXLCODES];
-    static short distcnt[MAXBITS+1], distsym[MAXDCODES];
-    static struct huffman lencode, distcode;
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        int symbol;
-        short lengths[FIXLCODES];
-
-        /* construct lencode and distcode */
-        lencode.count = lencnt;
-        lencode.symbol = lensym;
-        distcode.count = distcnt;
-        distcode.symbol = distsym;
-
-        /* literal/length table */
-        for (symbol = 0; symbol < 144; symbol++)
-            lengths[symbol] = 8;
-        for (; symbol < 256; symbol++)
-            lengths[symbol] = 9;
-        for (; symbol < 280; symbol++)
-            lengths[symbol] = 7;
-        for (; symbol < FIXLCODES; symbol++)
-            lengths[symbol] = 8;
-        construct(&lencode, lengths, FIXLCODES);
-
-        /* distance table */
-        for (symbol = 0; symbol < MAXDCODES; symbol++)
-            lengths[symbol] = 5;
-        construct(&distcode, lengths, MAXDCODES);
-
-        /* do this just once */
-        virgin = 0;
-    }
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Process a dynamic codes block.
- *
- * Format notes:
- *
- * - A dynamic block starts with a description of the literal/length and
- *   distance codes for that block.  New dynamic blocks allow the compressor to
- *   rapidly adapt to changing data with new codes optimized for that data.
- *
- * - The codes used by the deflate format are "canonical", which means that
- *   the actual bits of the codes are generated in an unambiguous way simply
- *   from the number of bits in each code.  Therefore the code descriptions
- *   are simply a list of code lengths for each symbol.
- *
- * - The code lengths are stored in order for the symbols, so lengths are
- *   provided for each of the literal/length symbols, and for each of the
- *   distance symbols.
- *
- * - If a symbol is not used in the block, this is represented by a zero as
- *   as the code length.  This does not mean a zero-length code, but rather
- *   that no code should be created for this symbol.  There is no way in the
- *   deflate format to represent a zero-length code.
- *
- * - The maximum number of bits in a code is 15, so the possible lengths for
- *   any code are 1..15.
- *
- * - The fact that a length of zero is not permitted for a code has an
- *   interesting consequence.  Normally if only one symbol is used for a given
- *   code, then in fact that code could be represented with zero bits.  However
- *   in deflate, that code has to be at least one bit.  So for example, if
- *   only a single distance base symbol appears in a block, then it will be
- *   represented by a single code of length one, in particular one 0 bit.  This
- *   is an incomplete code, since if a 1 bit is received, it has no meaning,
- *   and should result in an error.  So incomplete distance codes of one symbol
- *   should be permitted, and the receipt of invalid codes should be handled.
- *
- * - It is also possible to have a single literal/length code, but that code
- *   must be the end-of-block code, since every dynamic block has one.  This
- *   is not the most efficient way to create an empty block (an empty fixed
- *   block is fewer bits), but it is allowed by the format.  So incomplete
- *   literal/length codes of one symbol should also be permitted.
- *
- * - If there are only literal codes and no lengths, then there are no distance
- *   codes.  This is represented by one distance code with zero bits.
- *
- * - The list of up to 286 length/literal lengths and up to 30 distance lengths
- *   are themselves compressed using Huffman codes and run-length encoding.  In
- *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means
- *   that length, and the symbols 16, 17, and 18 are run-length instructions.
- *   Each of 16, 17, and 18 are follwed by extra bits to define the length of
- *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10
- *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols
- *   are common, hence the special coding for zero lengths.
- *
- * - The symbols for 0..18 are Huffman coded, and so that code must be
- *   described first.  This is simply a sequence of up to 19 three-bit values
- *   representing no code (0) or the code length for that symbol (1..7).
- *
- * - A dynamic block starts with three fixed-size counts from which is computed
- *   the number of literal/length code lengths, the number of distance code
- *   lengths, and the number of code length code lengths (ok, you come up with
- *   a better name!) in the code descriptions.  For the literal/length and
- *   distance codes, lengths after those provided are considered zero, i.e. no
- *   code.  The code length code lengths are received in a permuted order (see
- *   the order[] array below) to make a short code length code length list more
- *   likely.  As it turns out, very short and very long codes are less likely
- *   to be seen in a dynamic code description, hence what may appear initially
- *   to be a peculiar ordering.
- *
- * - Given the number of literal/length code lengths (nlen) and distance code
- *   lengths (ndist), then they are treated as one long list of nlen + ndist
- *   code lengths.  Therefore run-length coding can and often does cross the
- *   boundary between the two sets of lengths.
- *
- * - So to summarize, the code description at the start of a dynamic block is
- *   three counts for the number of code lengths for the literal/length codes,
- *   the distance codes, and the code length codes.  This is followed by the
- *   code length code lengths, three bits each.  This is used to construct the
- *   code length code which is used to read the remainder of the lengths.  Then
- *   the literal/length code lengths and distance lengths are read as a single
- *   set of lengths using the code length codes.  Codes are constructed from
- *   the resulting two sets of lengths, and then finally you can start
- *   decoding actual compressed data in the block.
- *
- * - For reference, a "typical" size for the code description in a dynamic
- *   block is around 80 bytes.
- */
-local int dynamic(struct state *s)
-{
-    int nlen, ndist, ncode;             /* number of lengths in descriptor */
-    int index;                          /* index of lengths[] */
-    int err;                            /* construct() return value */
-    short lengths[MAXCODES];            /* descriptor code lengths */
-    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */
-    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */
-    struct huffman lencode, distcode;   /* length and distance codes */
-    static const short order[19] =      /* permutation of code length codes */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* construct lencode and distcode */
-    lencode.count = lencnt;
-    lencode.symbol = lensym;
-    distcode.count = distcnt;
-    distcode.symbol = distsym;
-
-    /* get number of lengths in each table, check lengths */
-    nlen = bits(s, 5) + 257;
-    ndist = bits(s, 5) + 1;
-    ncode = bits(s, 4) + 4;
-    if (nlen > MAXLCODES || ndist > MAXDCODES)
-        return -3;                      /* bad counts */
-
-    /* read code length code lengths (really), missing lengths are zero */
-    for (index = 0; index < ncode; index++)
-        lengths[order[index]] = bits(s, 3);
-    for (; index < 19; index++)
-        lengths[order[index]] = 0;
-
-    /* build huffman table for code lengths codes (use lencode temporarily) */
-    err = construct(&lencode, lengths, 19);
-    if (err != 0)               /* require complete code set here */
-        return -4;
-
-    /* read length/literal and distance code length tables */
-    index = 0;
-    while (index < nlen + ndist) {
-        int symbol;             /* decoded value */
-        int len;                /* last length to repeat */
-
-        symbol = decode(s, &lencode);
-        if (symbol < 0)
-            return symbol;          /* invalid symbol */
-        if (symbol < 16)                /* length in 0..15 */
-            lengths[index++] = symbol;
-        else {                          /* repeat instruction */
-            len = 0;                    /* assume repeating zeros */
-            if (symbol == 16) {         /* repeat last length 3..6 times */
-                if (index == 0)
-                    return -5;          /* no last length! */
-                len = lengths[index - 1];       /* last length */
-                symbol = 3 + bits(s, 2);
-            }
-            else if (symbol == 17)      /* repeat zero 3..10 times */
-                symbol = 3 + bits(s, 3);
-            else                        /* == 18, repeat zero 11..138 times */
-                symbol = 11 + bits(s, 7);
-            if (index + symbol > nlen + ndist)
-                return -6;              /* too many lengths! */
-            while (symbol--)            /* repeat last or zero symbol times */
-                lengths[index++] = len;
-        }
-    }
-
-    /* check for end-of-block code -- there better be one! */
-    if (lengths[256] == 0)
-        return -9;
-
-    /* build huffman table for literal/length codes */
-    err = construct(&lencode, lengths, nlen);
-    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))
-        return -7;      /* incomplete code ok only for single length 1 code */
-
-    /* build huffman table for distance codes */
-    err = construct(&distcode, lengths + nlen, ndist);
-    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))
-        return -8;      /* incomplete code ok only for single length 1 code */
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Inflate source to dest.  On return, destlen and sourcelen are updated to the
- * size of the uncompressed data and the size of the deflate data respectively.
- * On success, the return value of puff() is zero.  If there is an error in the
- * source data, i.e. it is not in the deflate format, then a negative value is
- * returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.  In that case, destlen and
- * sourcelen are not updated to facilitate retrying from the beginning with the
- * provision of more input data or more output space.  In the case of invalid
- * inflate data (a negative error), the dest and source pointers are updated to
- * facilitate the debugging of deflators.
- *
- * puff() also has a mode to determine the size of the uncompressed output with
- * no output written.  For this dest must be (unsigned char *)0.  In this case,
- * the input value of *destlen is ignored, and on return *destlen is set to the
- * size of the uncompressed output.
- *
- * The return codes are:
- *
- *   2:  available inflate data did not terminate
- *   1:  output space exhausted before completing inflate
- *   0:  successful inflate
- *  -1:  invalid block type (type == 3)
- *  -2:  stored block length did not match one's complement
- *  -3:  dynamic block code description: too many length or distance codes
- *  -4:  dynamic block code description: code lengths codes incomplete
- *  -5:  dynamic block code description: repeat lengths with no first length
- *  -6:  dynamic block code description: repeat more than specified lengths
- *  -7:  dynamic block code description: invalid literal/length code lengths
- *  -8:  dynamic block code description: invalid distance code lengths
- *  -9:  dynamic block code description: missing end-of-block code
- * -10:  invalid literal/length or distance code in fixed or dynamic block
- * -11:  distance is too far back in fixed or dynamic block
- *
- * Format notes:
- *
- * - Three bits are read for each block to determine the kind of block and
- *   whether or not it is the last block.  Then the block is decoded and the
- *   process repeated if it was not the last block.
- *
- * - The leftover bits in the last byte of the deflate data after the last
- *   block (if it was a fixed or dynamic block) are undefined and have no
- *   expected values to check.
- */
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen)      /* amount of input available */
-{
-    struct state s;             /* input/output state */
-    int last, type;             /* block information */
-    int err;                    /* return value */
-
-    /* initialize output state */
-    s.out = dest;
-    s.outlen = *destlen;                /* ignored if dest is NIL */
-    s.outcnt = 0;
-
-    /* initialize input state */
-    s.in = source;
-    s.inlen = *sourcelen;
-    s.incnt = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */
-        err = 2;                        /* then skip do-loop, return error */
-    else {
-        /* process blocks until last block or error */
-        do {
-            last = bits(&s, 1);         /* one if last block */
-            type = bits(&s, 2);         /* block type 0..3 */
-            err = type == 0 ?
-                    stored(&s) :
-                    (type == 1 ?
-                        fixed(&s) :
-                        (type == 2 ?
-                            dynamic(&s) :
-                            -1));       /* type == 3, invalid */
-            if (err != 0)
-                break;                  /* return with error */
-        } while (!last);
-    }
-
-    /* update the lengths and return */
-    if (err <= 0) {
-        *destlen = s.outcnt;
-        *sourcelen = s.incnt;
-    }
-    return err;
-}
diff --git a/contrib/zlib/contrib/puff/puff.h b/contrib/zlib/contrib/puff/puff.h
deleted file mode 100644
index e23a24543..000000000
--- a/contrib/zlib/contrib/puff/puff.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* puff.h
-  Copyright (C) 2002-2013 Mark Adler, all rights reserved
-  version 2.3, 21 Jan 2013
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * See puff.c for purpose and usage.
- */
-#ifndef NIL
-#  define NIL ((unsigned char *)0)      /* for no output option */
-#endif
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
diff --git a/contrib/zlib/contrib/puff/pufftest.c b/contrib/zlib/contrib/puff/pufftest.c
deleted file mode 100644
index 776481488..000000000
--- a/contrib/zlib/contrib/puff/pufftest.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * pufftest.c
- * Copyright (C) 2002-2013 Mark Adler
- * For conditions of distribution and use, see copyright notice in puff.h
- * version 2.3, 21 Jan 2013
- */
-
-/* Example of how to use puff().
-
-   Usage: puff [-w] [-f] [-nnn] file
-          ... | puff [-w] [-f] [-nnn]
-
-   where file is the input file with deflate data, nnn is the number of bytes
-   of input to skip before inflating (e.g. to skip a zlib or gzip header), and
-   -w is used to write the decompressed data to stdout.  -f is for coverage
-   testing, and causes pufftest to fail with not enough output space (-f does
-   a write like -w, so -w is not required). */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "puff.h"
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#define local static
-
-/* Return size times approximately the cube root of 2, keeping the result as 1,
-   3, or 5 times a power of 2 -- the result is always > size, until the result
-   is the maximum value of an unsigned long, where it remains.  This is useful
-   to keep reallocations less than ~33% over the actual data. */
-local size_t bythirds(size_t size)
-{
-    int n;
-    size_t m;
-
-    m = size;
-    for (n = 0; m; n++)
-        m >>= 1;
-    if (n < 3)
-        return size + 1;
-    n -= 3;
-    m = size >> n;
-    m += m == 6 ? 2 : 1;
-    m <<= n;
-    return m > size ? m : (size_t)(-1);
-}
-
-/* Read the input file *name, or stdin if name is NULL, into allocated memory.
-   Reallocate to larger buffers until the entire file is read in.  Return a
-   pointer to the allocated data, or NULL if there was a memory allocation
-   failure.  *len is the number of bytes of data read from the input file (even
-   if load() returns NULL).  If the input file was empty or could not be opened
-   or read, *len is zero. */
-local void *load(const char *name, size_t *len)
-{
-    size_t size;
-    void *buf, *swap;
-    FILE *in;
-
-    *len = 0;
-    buf = malloc(size = 4096);
-    if (buf == NULL)
-        return NULL;
-    in = name == NULL ? stdin : fopen(name, "rb");
-    if (in != NULL) {
-        for (;;) {
-            *len += fread((char *)buf + *len, 1, size - *len, in);
-            if (*len < size) break;
-            size = bythirds(size);
-            if (size == *len || (swap = realloc(buf, size)) == NULL) {
-                free(buf);
-                buf = NULL;
-                break;
-            }
-            buf = swap;
-        }
-        fclose(in);
-    }
-    return buf;
-}
-
-int main(int argc, char **argv)
-{
-    int ret, put = 0, fail = 0;
-    unsigned skip = 0;
-    char *arg, *name = NULL;
-    unsigned char *source = NULL, *dest;
-    size_t len = 0;
-    unsigned long sourcelen, destlen;
-
-    /* process arguments */
-    while (arg = *++argv, --argc)
-        if (arg[0] == '-') {
-            if (arg[1] == 'w' && arg[2] == 0)
-                put = 1;
-            else if (arg[1] == 'f' && arg[2] == 0)
-                fail = 1, put = 1;
-            else if (arg[1] >= '0' && arg[1] <= '9')
-                skip = (unsigned)atoi(arg + 1);
-            else {
-                fprintf(stderr, "invalid option %s\n", arg);
-                return 3;
-            }
-        }
-        else if (name != NULL) {
-            fprintf(stderr, "only one file name allowed\n");
-            return 3;
-        }
-        else
-            name = arg;
-    source = load(name, &len);
-    if (source == NULL) {
-        fprintf(stderr, "memory allocation failure\n");
-        return 4;
-    }
-    if (len == 0) {
-        fprintf(stderr, "could not read %s, or it was empty\n",
-                name == NULL ? "<stdin>" : name);
-        free(source);
-        return 3;
-    }
-    if (skip >= len) {
-        fprintf(stderr, "skip request of %d leaves no input\n", skip);
-        free(source);
-        return 3;
-    }
-
-    /* test inflate data with offset skip */
-    len -= skip;
-    sourcelen = (unsigned long)len;
-    ret = puff(NIL, &destlen, source + skip, &sourcelen);
-    if (ret)
-        fprintf(stderr, "puff() failed with return code %d\n", ret);
-    else {
-        fprintf(stderr, "puff() succeeded uncompressing %lu bytes\n", destlen);
-        if (sourcelen < len) fprintf(stderr, "%lu compressed bytes unused\n",
-                                     len - sourcelen);
-    }
-
-    /* if requested, inflate again and write decompressd data to stdout */
-    if (put && ret == 0) {
-        if (fail)
-            destlen >>= 1;
-        dest = malloc(destlen);
-        if (dest == NULL) {
-            fprintf(stderr, "memory allocation failure\n");
-            free(source);
-            return 4;
-        }
-        puff(dest, &destlen, source + skip, &sourcelen);
-        SET_BINARY_MODE(stdout);
-        fwrite(dest, 1, destlen, stdout);
-        free(dest);
-    }
-
-    /* clean up */
-    free(source);
-    return ret;
-}
diff --git a/contrib/zlib/contrib/puff/zeros.raw b/contrib/zlib/contrib/puff/zeros.raw
deleted file mode 100644
index 0a90e76b300205a44a0ecbf613e64aaaef2e51e7..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2517
zcmYdFkYHV$AkxzmXu#!mP=i#?5{3o^3jqcYc(h*%Opg+yAut*OqaiT#LSPd+y9&tF
zP5<`ixi4UXdB8xJfs^6ee;AkH?VUytyFsD;HLIJ(gg5bUnNh}Q2#kinXb22!2pr%5
E0JRq+;s5{u

diff --git a/contrib/zlib/contrib/testzlib/testzlib.c b/contrib/zlib/contrib/testzlib/testzlib.c
deleted file mode 100644
index 8626c92ad..000000000
--- a/contrib/zlib/contrib/testzlib/testzlib.c
+++ /dev/null
@@ -1,275 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <windows.h>
-
-#include "zlib.h"
-
-
-void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)
-{
-    R->HighPart = A.HighPart - B.HighPart;
-    if (A.LowPart >= B.LowPart)
-        R->LowPart = A.LowPart - B.LowPart;
-    else
-    {
-        R->LowPart = A.LowPart - B.LowPart;
-        R->HighPart --;
-    }
-}
-
-#ifdef _M_X64
-// see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc
-unsigned __int64 __rdtsc(void);
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
- //   printf("rdtsc = %I64x\n",__rdtsc());
-   pbeginTime64->QuadPart=__rdtsc();
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres;
-    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));
-    LIres.QuadPart=res;
-   // printf("rdtsc = %I64x\n",__rdtsc());
-    return LIres;
-}
-#else
-#ifdef _M_IX86
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-    DWORD dwEdx,dwEax;
-    _asm
-    {
-        rdtsc
-        mov dwEax,eax
-        mov dwEdx,edx
-    }
-    pbeginTime64->LowPart=dwEax;
-    pbeginTime64->HighPart=dwEdx;
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-    myGetRDTSC32(pbeginTime64);
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres,endTime64;
-    myGetRDTSC32(&endTime64);
-
-    LIres.LowPart=LIres.HighPart=0;
-    MyDoMinus64(&LIres,endTime64,beginTime64);
-    return LIres;
-}
-#else
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER lr;
-    lr.QuadPart=0;
-    return lr;
-}
-#endif
-#endif
-
-void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)
-{
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))
-    {
-        pbeginTime64->LowPart = GetTickCount();
-        pbeginTime64->HighPart = 0;
-    }
-}
-
-DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER endTime64,ticksPerSecond,ticks;
-    DWORDLONG ticksShifted,tickSecShifted;
-    DWORD dwLog=16+0;
-    DWORD dwRet;
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))
-        dwRet = (GetTickCount() - beginTime64.LowPart)*1;
-    else
-    {
-        MyDoMinus64(&ticks,endTime64,beginTime64);
-        QueryPerformanceFrequency(&ticksPerSecond);
-
-
-        {
-            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);
-            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);
-
-        }
-
-        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));
-        dwRet *=1;
-    }
-    return dwRet;
-}
-
-int ReadFileMemory(const char* filename,long* plFileSize,unsigned char** pFilePtr)
-{
-    FILE* stream;
-    unsigned char* ptr;
-    int retVal=1;
-    stream=fopen(filename, "rb");
-    if (stream==NULL)
-        return 0;
-
-    fseek(stream,0,SEEK_END);
-
-    *plFileSize=ftell(stream);
-    fseek(stream,0,SEEK_SET);
-    ptr=malloc((*plFileSize)+1);
-    if (ptr==NULL)
-        retVal=0;
-    else
-    {
-        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))
-            retVal=0;
-    }
-    fclose(stream);
-    *pFilePtr=ptr;
-    return retVal;
-}
-
-int main(int argc, char *argv[])
-{
-    int BlockSizeCompress=0x8000;
-    int BlockSizeUncompress=0x8000;
-    int cprLevel=Z_DEFAULT_COMPRESSION ;
-    long lFileSize;
-    unsigned char* FilePtr;
-    long lBufferSizeCpr;
-    long lBufferSizeUncpr;
-    long lCompressedSize=0;
-    unsigned char* CprPtr;
-    unsigned char* UncprPtr;
-    long lSizeCpr,lSizeUncpr;
-    DWORD dwGetTick,dwMsecQP;
-    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;
-
-    if (argc<=1)
-    {
-        printf("run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\n");
-        return 0;
-    }
-
-    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)
-    {
-        printf("error reading %s\n",argv[1]);
-        return 1;
-    }
-    else printf("file %s read, %u bytes\n",argv[1],lFileSize);
-
-    if (argc>=3)
-        BlockSizeCompress=atol(argv[2]);
-
-    if (argc>=4)
-        BlockSizeUncompress=atol(argv[3]);
-
-    if (argc>=5)
-        cprLevel=(int)atol(argv[4]);
-
-    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;
-    lBufferSizeUncpr = lBufferSizeCpr;
-
-    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lFileSize;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        deflateInit(&zcpr,cprLevel);
-
-        zcpr.next_in = FilePtr;
-        zcpr.next_out = CprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);
-            zcpr.avail_out = BlockSizeCompress;
-            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeCpr=zcpr.total_out;
-        deflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total compress size = %u, in %u step\n",lSizeCpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("defcpr time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("defcpr result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);
-    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lSizeCpr;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        inflateInit(&zcpr);
-
-        zcpr.next_in = CprPtr;
-        zcpr.next_out = UncprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);
-            zcpr.avail_out = BlockSizeUncompress;
-            ret=inflate(&zcpr,Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeUncpr=zcpr.total_out;
-        inflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total uncompress size = %u, in %u step\n",lSizeUncpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("uncpr  time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("uncpr  result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    if (lSizeUncpr==lFileSize)
-    {
-        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)
-            printf("compare ok\n");
-
-    }
-
-    return 0;
-}
diff --git a/contrib/zlib/contrib/testzlib/testzlib.txt b/contrib/zlib/contrib/testzlib/testzlib.txt
deleted file mode 100644
index ba1bb3db6..000000000
--- a/contrib/zlib/contrib/testzlib/testzlib.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-To build testzLib with Visual Studio 2005:
-
-copy to a directory file from :
-- root of zLib tree
-- contrib/testzlib
-- contrib/masmx86
-- contrib/masmx64
-- contrib/vstudio/vc7
-
-and open testzlib8.sln
diff --git a/contrib/zlib/contrib/untgz/Makefile.msc b/contrib/zlib/contrib/untgz/Makefile.msc
deleted file mode 100644
index 77b860221..000000000
--- a/contrib/zlib/contrib/untgz/Makefile.msc
+++ /dev/null
@@ -1,17 +0,0 @@
-CC=cl
-CFLAGS=-MD
-
-untgz.exe: untgz.obj ..\..\zlib.lib
-	$(CC) $(CFLAGS) untgz.obj ..\..\zlib.lib
-
-untgz.obj: untgz.c ..\..\zlib.h
-	$(CC) $(CFLAGS) -c -I..\.. untgz.c
-
-..\..\zlib.lib:
-	cd ..\..
-	$(MAKE) -f win32\makefile.msc
-	cd contrib\untgz
-
-clean:
-	-del untgz.obj
-	-del untgz.exe
diff --git a/contrib/zlib/contrib/untgz/untgz.c b/contrib/zlib/contrib/untgz/untgz.c
deleted file mode 100644
index 2c391e598..000000000
--- a/contrib/zlib/contrib/untgz/untgz.c
+++ /dev/null
@@ -1,674 +0,0 @@
-/*
- * untgz.c -- Display contents and extract files from a gzip'd TAR file
- *
- * written by Pedro A. Aranda Gutierrez <paag@tid.es>
- * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>
- * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-
-#include "zlib.h"
-
-#ifdef unix
-#  include <unistd.h>
-#else
-#  include <direct.h>
-#  include <io.h>
-#endif
-
-#ifdef WIN32
-#include <windows.h>
-#  ifndef F_OK
-#    define F_OK  0
-#  endif
-#  define mkdir(dirname,mode)   _mkdir(dirname)
-#  ifdef _MSC_VER
-#    define access(path,mode)   _access(path,mode)
-#    define chmod(path,mode)    _chmod(path,mode)
-#    define strdup(str)         _strdup(str)
-#  endif
-#else
-#  include <utime.h>
-#endif
-
-
-/* values used in typeflag field */
-
-#define REGTYPE  '0'            /* regular file */
-#define AREGTYPE '\0'           /* regular file */
-#define LNKTYPE  '1'            /* link */
-#define SYMTYPE  '2'            /* reserved */
-#define CHRTYPE  '3'            /* character special */
-#define BLKTYPE  '4'            /* block special */
-#define DIRTYPE  '5'            /* directory */
-#define FIFOTYPE '6'            /* FIFO special */
-#define CONTTYPE '7'            /* reserved */
-
-/* GNU tar extensions */
-
-#define GNUTYPE_DUMPDIR  'D'    /* file names from dumped directory */
-#define GNUTYPE_LONGLINK 'K'    /* long link name */
-#define GNUTYPE_LONGNAME 'L'    /* long file name */
-#define GNUTYPE_MULTIVOL 'M'    /* continuation of file from another volume */
-#define GNUTYPE_NAMES    'N'    /* file name that does not fit into main hdr */
-#define GNUTYPE_SPARSE   'S'    /* sparse file */
-#define GNUTYPE_VOLHDR   'V'    /* tape/volume header */
-
-
-/* tar header */
-
-#define BLOCKSIZE     512
-#define SHORTNAMESIZE 100
-
-struct tar_header
-{                               /* byte offset */
-  char name[100];               /*   0 */
-  char mode[8];                 /* 100 */
-  char uid[8];                  /* 108 */
-  char gid[8];                  /* 116 */
-  char size[12];                /* 124 */
-  char mtime[12];               /* 136 */
-  char chksum[8];               /* 148 */
-  char typeflag;                /* 156 */
-  char linkname[100];           /* 157 */
-  char magic[6];                /* 257 */
-  char version[2];              /* 263 */
-  char uname[32];               /* 265 */
-  char gname[32];               /* 297 */
-  char devmajor[8];             /* 329 */
-  char devminor[8];             /* 337 */
-  char prefix[155];             /* 345 */
-                                /* 500 */
-};
-
-union tar_buffer
-{
-  char               buffer[BLOCKSIZE];
-  struct tar_header  header;
-};
-
-struct attr_item
-{
-  struct attr_item  *next;
-  char              *fname;
-  int                mode;
-  time_t             time;
-};
-
-enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID };
-
-char *TGZfname          OF((const char *));
-void TGZnotfound        OF((const char *));
-
-int getoct              OF((char *, int));
-char *strtime           OF((time_t *));
-int setfiletime         OF((char *, time_t));
-void push_attr          OF((struct attr_item **, char *, int, time_t));
-void restore_attr       OF((struct attr_item **));
-
-int ExprMatch           OF((char *, char *));
-
-int makedir             OF((char *));
-int matchname           OF((int, int, char **, char *));
-
-void error              OF((const char *));
-int tar                 OF((gzFile, int, int, int, char **));
-
-void help               OF((int));
-int main                OF((int, char **));
-
-char *prog;
-
-const char *TGZsuffix[] = { "\0", ".tar", ".tar.gz", ".taz", ".tgz", NULL };
-
-/* return the file name of the TGZ archive */
-/* or NULL if it does not exist */
-
-char *TGZfname (const char *arcname)
-{
-  static char buffer[1024];
-  int origlen,i;
-
-  strcpy(buffer,arcname);
-  origlen = strlen(buffer);
-
-  for (i=0; TGZsuffix[i]; i++)
-    {
-       strcpy(buffer+origlen,TGZsuffix[i]);
-       if (access(buffer,F_OK) == 0)
-         return buffer;
-    }
-  return NULL;
-}
-
-
-/* error message for the filename */
-
-void TGZnotfound (const char *arcname)
-{
-  int i;
-
-  fprintf(stderr,"%s: Couldn't find ",prog);
-  for (i=0;TGZsuffix[i];i++)
-    fprintf(stderr,(TGZsuffix[i+1]) ? "%s%s, " : "or %s%s\n",
-            arcname,
-            TGZsuffix[i]);
-  exit(1);
-}
-
-
-/* convert octal digits to int */
-/* on error return -1 */
-
-int getoct (char *p,int width)
-{
-  int result = 0;
-  char c;
-
-  while (width--)
-    {
-      c = *p++;
-      if (c == 0)
-        break;
-      if (c == ' ')
-        continue;
-      if (c < '0' || c > '7')
-        return -1;
-      result = result * 8 + (c - '0');
-    }
-  return result;
-}
-
-
-/* convert time_t to string */
-/* use the "YYYY/MM/DD hh:mm:ss" format */
-
-char *strtime (time_t *t)
-{
-  struct tm   *local;
-  static char result[32];
-
-  local = localtime(t);
-  sprintf(result,"%4d/%02d/%02d %02d:%02d:%02d",
-          local->tm_year+1900, local->tm_mon+1, local->tm_mday,
-          local->tm_hour, local->tm_min, local->tm_sec);
-  return result;
-}
-
-
-/* set file time */
-
-int setfiletime (char *fname,time_t ftime)
-{
-#ifdef WIN32
-  static int isWinNT = -1;
-  SYSTEMTIME st;
-  FILETIME locft, modft;
-  struct tm *loctm;
-  HANDLE hFile;
-  int result;
-
-  loctm = localtime(&ftime);
-  if (loctm == NULL)
-    return -1;
-
-  st.wYear         = (WORD)loctm->tm_year + 1900;
-  st.wMonth        = (WORD)loctm->tm_mon + 1;
-  st.wDayOfWeek    = (WORD)loctm->tm_wday;
-  st.wDay          = (WORD)loctm->tm_mday;
-  st.wHour         = (WORD)loctm->tm_hour;
-  st.wMinute       = (WORD)loctm->tm_min;
-  st.wSecond       = (WORD)loctm->tm_sec;
-  st.wMilliseconds = 0;
-  if (!SystemTimeToFileTime(&st, &locft) ||
-      !LocalFileTimeToFileTime(&locft, &modft))
-    return -1;
-
-  if (isWinNT < 0)
-    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;
-  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
-                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),
-                     NULL);
-  if (hFile == INVALID_HANDLE_VALUE)
-    return -1;
-  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;
-  CloseHandle(hFile);
-  return result;
-#else
-  struct utimbuf settime;
-
-  settime.actime = settime.modtime = ftime;
-  return utime(fname,&settime);
-#endif
-}
-
-
-/* push file attributes */
-
-void push_attr(struct attr_item **list,char *fname,int mode,time_t time)
-{
-  struct attr_item *item;
-
-  item = (struct attr_item *)malloc(sizeof(struct attr_item));
-  if (item == NULL)
-    error("Out of memory");
-  item->fname = strdup(fname);
-  item->mode  = mode;
-  item->time  = time;
-  item->next  = *list;
-  *list       = item;
-}
-
-
-/* restore file attributes */
-
-void restore_attr(struct attr_item **list)
-{
-  struct attr_item *item, *prev;
-
-  for (item = *list; item != NULL; )
-    {
-      setfiletime(item->fname,item->time);
-      chmod(item->fname,item->mode);
-      prev = item;
-      item = item->next;
-      free(prev);
-    }
-  *list = NULL;
-}
-
-
-/* match regular expression */
-
-#define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))
-
-int ExprMatch (char *string,char *expr)
-{
-  while (1)
-    {
-      if (ISSPECIAL(*expr))
-        {
-          if (*expr == '/')
-            {
-              if (*string != '\\' && *string != '/')
-                return 0;
-              string ++; expr++;
-            }
-          else if (*expr == '*')
-            {
-              if (*expr ++ == 0)
-                return 1;
-              while (*++string != *expr)
-                if (*string == 0)
-                  return 0;
-            }
-        }
-      else
-        {
-          if (*string != *expr)
-            return 0;
-          if (*expr++ == 0)
-            return 1;
-          string++;
-        }
-    }
-}
-
-
-/* recursive mkdir */
-/* abort on ENOENT; ignore other errors like "directory already exists" */
-/* return 1 if OK */
-/*        0 on error */
-
-int makedir (char *newdir)
-{
-  char *buffer = strdup(newdir);
-  char *p;
-  int  len = strlen(buffer);
-
-  if (len <= 0) {
-    free(buffer);
-    return 0;
-  }
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mkdir(buffer, 0755) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))
-        {
-          fprintf(stderr,"%s: Couldn't create directory %s\n",prog,buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-
-int matchname (int arg,int argc,char **argv,char *fname)
-{
-  if (arg == argc)      /* no arguments given (untgz tgzarchive) */
-    return 1;
-
-  while (arg < argc)
-    if (ExprMatch(fname,argv[arg++]))
-      return 1;
-
-  return 0; /* ignore this for the moment being */
-}
-
-
-/* tar file list or extract */
-
-int tar (gzFile in,int action,int arg,int argc,char **argv)
-{
-  union  tar_buffer buffer;
-  int    len;
-  int    err;
-  int    getheader = 1;
-  int    remaining = 0;
-  FILE   *outfile = NULL;
-  char   fname[BLOCKSIZE];
-  int    tarmode;
-  time_t tartime;
-  struct attr_item *attributes = NULL;
-
-  if (action == TGZ_LIST)
-    printf("    date      time     size                       file\n"
-           " ---------- -------- --------- -------------------------------------\n");
-  while (1)
-    {
-      len = gzread(in, &buffer, BLOCKSIZE);
-      if (len < 0)
-        error(gzerror(in, &err));
-      /*
-       * Always expect complete blocks to process
-       * the tar information.
-       */
-      if (len != BLOCKSIZE)
-        {
-          action = TGZ_INVALID; /* force error exit */
-          remaining = 0;        /* force I/O cleanup */
-        }
-
-      /*
-       * If we have to get a tar header
-       */
-      if (getheader >= 1)
-        {
-          /*
-           * if we met the end of the tar
-           * or the end-of-tar block,
-           * we are done
-           */
-          if (len == 0 || buffer.header.name[0] == 0)
-            break;
-
-          tarmode = getoct(buffer.header.mode,8);
-          tartime = (time_t)getoct(buffer.header.mtime,12);
-          if (tarmode == -1 || tartime == (time_t)-1)
-            {
-              buffer.header.name[0] = 0;
-              action = TGZ_INVALID;
-            }
-
-          if (getheader == 1)
-            {
-              strncpy(fname,buffer.header.name,SHORTNAMESIZE);
-              if (fname[SHORTNAMESIZE-1] != 0)
-                  fname[SHORTNAMESIZE] = 0;
-            }
-          else
-            {
-              /*
-               * The file name is longer than SHORTNAMESIZE
-               */
-              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)
-                  error("bad long name");
-              getheader = 1;
-            }
-
-          /*
-           * Act according to the type flag
-           */
-          switch (buffer.header.typeflag)
-            {
-            case DIRTYPE:
-              if (action == TGZ_LIST)
-                printf(" %s     <dir> %s\n",strtime(&tartime),fname);
-              if (action == TGZ_EXTRACT)
-                {
-                  makedir(fname);
-                  push_attr(&attributes,fname,tarmode,tartime);
-                }
-              break;
-            case REGTYPE:
-            case AREGTYPE:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining == -1)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              if (action == TGZ_LIST)
-                printf(" %s %9d %s\n",strtime(&tartime),remaining,fname);
-              else if (action == TGZ_EXTRACT)
-                {
-                  if (matchname(arg,argc,argv,fname))
-                    {
-                      outfile = fopen(fname,"wb");
-                      if (outfile == NULL) {
-                        /* try creating directory */
-                        char *p = strrchr(fname, '/');
-                        if (p != NULL) {
-                          *p = '\0';
-                          makedir(fname);
-                          *p = '/';
-                          outfile = fopen(fname,"wb");
-                        }
-                      }
-                      if (outfile != NULL)
-                        printf("Extracting %s\n",fname);
-                      else
-                        fprintf(stderr, "%s: Couldn't create %s",prog,fname);
-                    }
-                  else
-                    outfile = NULL;
-                }
-              getheader = 0;
-              break;
-            case GNUTYPE_LONGLINK:
-            case GNUTYPE_LONGNAME:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining < 0 || remaining >= BLOCKSIZE)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              len = gzread(in, fname, BLOCKSIZE);
-              if (len < 0)
-                error(gzerror(in, &err));
-              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              getheader = 2;
-              break;
-            default:
-              if (action == TGZ_LIST)
-                printf(" %s     <---> %s\n",strtime(&tartime),fname);
-              break;
-            }
-        }
-      else
-        {
-          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;
-
-          if (outfile != NULL)
-            {
-              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)
-                {
-                  fprintf(stderr,
-                    "%s: Error writing %s -- skipping\n",prog,fname);
-                  fclose(outfile);
-                  outfile = NULL;
-                  remove(fname);
-                }
-            }
-          remaining -= bytes;
-        }
-
-      if (remaining == 0)
-        {
-          getheader = 1;
-          if (outfile != NULL)
-            {
-              fclose(outfile);
-              outfile = NULL;
-              if (action != TGZ_INVALID)
-                push_attr(&attributes,fname,tarmode,tartime);
-            }
-        }
-
-      /*
-       * Abandon if errors are found
-       */
-      if (action == TGZ_INVALID)
-        {
-          error("broken archive");
-          break;
-        }
-    }
-
-  /*
-   * Restore file modes and time stamps
-   */
-  restore_attr(&attributes);
-
-  if (gzclose(in) != Z_OK)
-    error("failed gzclose");
-
-  return 0;
-}
-
-
-/* ============================================================ */
-
-void help(int exitval)
-{
-  printf("untgz version 0.2.1\n"
-         "  using zlib version %s\n\n",
-         zlibVersion());
-  printf("Usage: untgz file.tgz            extract all files\n"
-         "       untgz file.tgz fname ...  extract selected files\n"
-         "       untgz -l file.tgz         list archive contents\n"
-         "       untgz -h                  display this help\n");
-  exit(exitval);
-}
-
-void error(const char *msg)
-{
-  fprintf(stderr, "%s: %s\n", prog, msg);
-  exit(1);
-}
-
-
-/* ============================================================ */
-
-#if defined(WIN32) && defined(__GNUC__)
-int _CRT_glob = 0;      /* disable argument globbing in MinGW */
-#endif
-
-int main(int argc,char **argv)
-{
-    int         action = TGZ_EXTRACT;
-    int         arg = 1;
-    char        *TGZfile;
-    gzFile      *f;
-
-    prog = strrchr(argv[0],'\\');
-    if (prog == NULL)
-      {
-        prog = strrchr(argv[0],'/');
-        if (prog == NULL)
-          {
-            prog = strrchr(argv[0],':');
-            if (prog == NULL)
-              prog = argv[0];
-            else
-              prog++;
-          }
-        else
-          prog++;
-      }
-    else
-      prog++;
-
-    if (argc == 1)
-      help(0);
-
-    if (strcmp(argv[arg],"-l") == 0)
-      {
-        action = TGZ_LIST;
-        if (argc == ++arg)
-          help(0);
-      }
-    else if (strcmp(argv[arg],"-h") == 0)
-      {
-        help(0);
-      }
-
-    if ((TGZfile = TGZfname(argv[arg])) == NULL)
-      TGZnotfound(argv[arg]);
-
-    ++arg;
-    if ((action == TGZ_LIST) && (arg != argc))
-      help(1);
-
-/*
- *  Process the TGZ file
- */
-    switch(action)
-      {
-      case TGZ_LIST:
-      case TGZ_EXTRACT:
-        f = gzopen(TGZfile,"rb");
-        if (f == NULL)
-          {
-            fprintf(stderr,"%s: Couldn't gzopen %s\n",prog,TGZfile);
-            return 1;
-          }
-        exit(tar(f, action, arg, argc, argv));
-      break;
-
-      default:
-        error("Unknown option");
-        exit(1);
-      }
-
-    return 0;
-}
diff --git a/contrib/zlib/contrib/vstudio/readme.txt b/contrib/zlib/contrib/vstudio/readme.txt
deleted file mode 100644
index 48cccc0d2..000000000
--- a/contrib/zlib/contrib/vstudio/readme.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-Building instructions for the DLL versions of Zlib 1.2.11
-========================================================
-
-This directory contains projects that build zlib and minizip using
-Microsoft Visual C++ 9.0/10.0.
-
-You don't need to build these projects yourself. You can download the
-binaries from:
-  http://www.winimage.com/zLibDll
-
-More information can be found at this site.
-
-
-
-
-
-Build instructions for Visual Studio 2008 (32 bits or 64 bits)
---------------------------------------------------------------
-- Decompress current zlib, including all contrib/* files
-- Compile assembly code (with Visual Studio Command Prompt) by running:
-   bld_ml64.bat (in contrib\masmx64)
-   bld_ml32.bat (in contrib\masmx86)
-- Open contrib\vstudio\vc9\zlibvc.sln with Microsoft Visual C++ 2008
-- Or run: vcbuild /rebuild contrib\vstudio\vc9\zlibvc.sln "Release|Win32"
-
-Build instructions for Visual Studio 2010 (32 bits or 64 bits)
---------------------------------------------------------------
-- Decompress current zlib, including all contrib/* files
-- Open contrib\vstudio\vc10\zlibvc.sln with Microsoft Visual C++ 2010
-
-Build instructions for Visual Studio 2012 (32 bits or 64 bits)
---------------------------------------------------------------
-- Decompress current zlib, including all contrib/* files
-- Open contrib\vstudio\vc11\zlibvc.sln with Microsoft Visual C++ 2012
-
-Build instructions for Visual Studio 2013 (32 bits or 64 bits)
---------------------------------------------------------------
-- Decompress current zlib, including all contrib/* files
-- Open contrib\vstudio\vc12\zlibvc.sln with Microsoft Visual C++ 2013
-
-Build instructions for Visual Studio 2015 (32 bits or 64 bits)
---------------------------------------------------------------
-- Decompress current zlib, including all contrib/* files
-- Open contrib\vstudio\vc14\zlibvc.sln with Microsoft Visual C++ 2015
-
-
-Important
----------
-- To use zlibwapi.dll in your application, you must define the
-  macro ZLIB_WINAPI when compiling your application's source files.
-
-
-Additional notes
-----------------
-- This DLL, named zlibwapi.dll, is compatible to the old zlib.dll built
-  by Gilles Vollant from the zlib 1.1.x sources, and distributed at
-    http://www.winimage.com/zLibDll
-  It uses the WINAPI calling convention for the exported functions, and
-  includes the minizip functionality. If your application needs that
-  particular build of zlib.dll, you can rename zlibwapi.dll to zlib.dll.
-
-- The new DLL was renamed because there exist several incompatible
-  versions of zlib.dll on the Internet.
-
-- There is also an official DLL build of zlib, named zlib1.dll. This one
-  is exporting the functions using the CDECL convention. See the file
-  win32\DLL_FAQ.txt found in this zlib distribution.
-
-- There used to be a ZLIB_DLL macro in zlib 1.1.x, but now this symbol
-  has a slightly different effect. To avoid compatibility problems, do
-  not define it here.
-
-
-Gilles Vollant
-info@winimage.com
-
-Visual Studio 2013 and 2015 Projects from Sean Hunt
-seandhunt_7@yahoo.com
diff --git a/contrib/zlib/contrib/vstudio/vc10/zlib.rc b/contrib/zlib/contrib/vstudio/vc10/zlib.rc
deleted file mode 100644
index c4e4b016e..000000000
--- a/contrib/zlib/contrib/vstudio/vc10/zlib.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1, 2, 11, 0
-  PRODUCTVERSION 1, 2, 11, 0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.11\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlibwapi.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/contrib/vstudio/vc10/zlibvc.def b/contrib/zlib/contrib/vstudio/vc10/zlibvc.def
deleted file mode 100644
index f876c3bca..000000000
--- a/contrib/zlib/contrib/vstudio/vc10/zlibvc.def
+++ /dev/null
@@ -1,153 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
-
-; zlib1 v1.2.8 added:
-        inflateGetDictionary                    @166
-        gzvprintf                               @167
-
-; zlib1 v1.2.9 added:
-        inflateCodesUsed                        @168
-        inflateValidate                         @169
-        uncompress2                             @170
-        gzfread                                 @171
-        gzfwrite                                @172
-        deflateGetDictionary                    @173
-        adler32_z                               @174
-        crc32_z                                 @175
diff --git a/contrib/zlib/contrib/vstudio/vc11/zlib.rc b/contrib/zlib/contrib/vstudio/vc11/zlib.rc
deleted file mode 100644
index c4e4b016e..000000000
--- a/contrib/zlib/contrib/vstudio/vc11/zlib.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1, 2, 11, 0
-  PRODUCTVERSION 1, 2, 11, 0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.11\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlibwapi.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/contrib/vstudio/vc11/zlibvc.def b/contrib/zlib/contrib/vstudio/vc11/zlibvc.def
deleted file mode 100644
index f876c3bca..000000000
--- a/contrib/zlib/contrib/vstudio/vc11/zlibvc.def
+++ /dev/null
@@ -1,153 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
-
-; zlib1 v1.2.8 added:
-        inflateGetDictionary                    @166
-        gzvprintf                               @167
-
-; zlib1 v1.2.9 added:
-        inflateCodesUsed                        @168
-        inflateValidate                         @169
-        uncompress2                             @170
-        gzfread                                 @171
-        gzfwrite                                @172
-        deflateGetDictionary                    @173
-        adler32_z                               @174
-        crc32_z                                 @175
diff --git a/contrib/zlib/contrib/vstudio/vc12/zlib.rc b/contrib/zlib/contrib/vstudio/vc12/zlib.rc
deleted file mode 100644
index c4e4b016e..000000000
--- a/contrib/zlib/contrib/vstudio/vc12/zlib.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1, 2, 11, 0
-  PRODUCTVERSION 1, 2, 11, 0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.11\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlibwapi.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/contrib/vstudio/vc12/zlibvc.def b/contrib/zlib/contrib/vstudio/vc12/zlibvc.def
deleted file mode 100644
index f876c3bca..000000000
--- a/contrib/zlib/contrib/vstudio/vc12/zlibvc.def
+++ /dev/null
@@ -1,153 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
-
-; zlib1 v1.2.8 added:
-        inflateGetDictionary                    @166
-        gzvprintf                               @167
-
-; zlib1 v1.2.9 added:
-        inflateCodesUsed                        @168
-        inflateValidate                         @169
-        uncompress2                             @170
-        gzfread                                 @171
-        gzfwrite                                @172
-        deflateGetDictionary                    @173
-        adler32_z                               @174
-        crc32_z                                 @175
diff --git a/contrib/zlib/contrib/vstudio/vc14/zlib.rc b/contrib/zlib/contrib/vstudio/vc14/zlib.rc
deleted file mode 100644
index c4e4b016e..000000000
--- a/contrib/zlib/contrib/vstudio/vc14/zlib.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1, 2, 11, 0
-  PRODUCTVERSION 1, 2, 11, 0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.11\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlibwapi.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/contrib/vstudio/vc14/zlibvc.def b/contrib/zlib/contrib/vstudio/vc14/zlibvc.def
deleted file mode 100644
index f876c3bca..000000000
--- a/contrib/zlib/contrib/vstudio/vc14/zlibvc.def
+++ /dev/null
@@ -1,153 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
-
-; zlib1 v1.2.8 added:
-        inflateGetDictionary                    @166
-        gzvprintf                               @167
-
-; zlib1 v1.2.9 added:
-        inflateCodesUsed                        @168
-        inflateValidate                         @169
-        uncompress2                             @170
-        gzfread                                 @171
-        gzfwrite                                @172
-        deflateGetDictionary                    @173
-        adler32_z                               @174
-        crc32_z                                 @175
diff --git a/contrib/zlib/contrib/vstudio/vc9/zlib.rc b/contrib/zlib/contrib/vstudio/vc9/zlib.rc
deleted file mode 100644
index c4e4b016e..000000000
--- a/contrib/zlib/contrib/vstudio/vc9/zlib.rc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1, 2, 11, 0
-  PRODUCTVERSION 1, 2, 11, 0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.11\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlibwapi.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/contrib/vstudio/vc9/zlibvc.def b/contrib/zlib/contrib/vstudio/vc9/zlibvc.def
deleted file mode 100644
index f876c3bca..000000000
--- a/contrib/zlib/contrib/vstudio/vc9/zlibvc.def
+++ /dev/null
@@ -1,153 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
-
-; zlib1 v1.2.8 added:
-        inflateGetDictionary                    @166
-        gzvprintf                               @167
-
-; zlib1 v1.2.9 added:
-        inflateCodesUsed                        @168
-        inflateValidate                         @169
-        uncompress2                             @170
-        gzfread                                 @171
-        gzfwrite                                @172
-        deflateGetDictionary                    @173
-        adler32_z                               @174
-        crc32_z                                 @175
diff --git a/contrib/zlib/crc32.c b/contrib/zlib/crc32.c
deleted file mode 100644
index e72636a50..000000000
--- a/contrib/zlib/crc32.c
+++ /dev/null
@@ -1,442 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
- * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
- * tables for updating the shift register in one step with three exclusive-ors
- * instead of four steps with four exclusive-ors.  This results in about a
- * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
- */
-
-/* @(#) $Id$ */
-
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
-
-  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
- */
-
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-
-#include "zutil.h"      /* for STDC and FAR definitions */
-
-/* Definitions for doing the crc four data bytes at a time. */
-#if !defined(NOBYFOUR) && defined(Z_U4)
-#  define BYFOUR
-#endif
-#ifdef BYFOUR
-   local unsigned long crc32_little OF((unsigned long,
-                        const unsigned char FAR *, z_size_t));
-   local unsigned long crc32_big OF((unsigned long,
-                        const unsigned char FAR *, z_size_t));
-#  define TBLS 8
-#else
-#  define TBLS 1
-#endif /* BYFOUR */
-
-/* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times OF((unsigned long *mat,
-                                         unsigned long vec));
-local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
-local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));
-
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local volatile int crc_table_empty = 1;
-local z_crc_t FAR crc_table[TBLS][256];
-local void make_crc_table OF((void));
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const z_crc_t FAR *));
-#endif /* MAKECRCH */
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The first table is simply the CRC of all possible eight bit values.  This is
-  all the information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.  The remaining tables
-  allow for word-at-a-time CRC calculation for both big-endian and little-
-  endian machines, where a word is four bytes.
-*/
-local void make_crc_table()
-{
-    z_crc_t c;
-    int n, k;
-    z_crc_t poly;                       /* polynomial exclusive-or pattern */
-    /* terms of polynomial defining this crc (except x^32): */
-    static volatile int first = 1;      /* flag to limit concurrent making */
-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-    /* See if another task is already doing this (not thread-safe, but better
-       than nothing -- significantly reduces duration of vulnerability in
-       case the advice about DYNAMIC_CRC_TABLE is ignored) */
-    if (first) {
-        first = 0;
-
-        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0;
-        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
-            poly |= (z_crc_t)1 << (31 - p[n]);
-
-        /* generate a crc for every 8-bit value */
-        for (n = 0; n < 256; n++) {
-            c = (z_crc_t)n;
-            for (k = 0; k < 8; k++)
-                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-            crc_table[0][n] = c;
-        }
-
-#ifdef BYFOUR
-        /* generate crc for each value followed by one, two, and three zeros,
-           and then the byte reversal of those as well as the first table */
-        for (n = 0; n < 256; n++) {
-            c = crc_table[0][n];
-            crc_table[4][n] = ZSWAP32(c);
-            for (k = 1; k < 4; k++) {
-                c = crc_table[0][c & 0xff] ^ (c >> 8);
-                crc_table[k][n] = c;
-                crc_table[k + 4][n] = ZSWAP32(c);
-            }
-        }
-#endif /* BYFOUR */
-
-        crc_table_empty = 0;
-    }
-    else {      /* not first */
-        /* wait for the other guy to finish (not efficient, but rare) */
-        while (crc_table_empty)
-            ;
-    }
-
-#ifdef MAKECRCH
-    /* write out CRC tables to crc32.h */
-    {
-        FILE *out;
-
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
-        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const z_crc_t FAR ");
-        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
-        write_table(out, crc_table[0]);
-#  ifdef BYFOUR
-        fprintf(out, "#ifdef BYFOUR\n");
-        for (k = 1; k < 8; k++) {
-            fprintf(out, "  },\n  {\n");
-            write_table(out, crc_table[k]);
-        }
-        fprintf(out, "#endif\n");
-#  endif /* BYFOUR */
-        fprintf(out, "  }\n};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-
-#ifdef MAKECRCH
-local void write_table(out, table)
-    FILE *out;
-    const z_crc_t FAR *table;
-{
-    int n;
-
-    for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
-                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
-}
-#endif /* MAKECRCH */
-
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables of CRC-32s of all single-byte values, made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const z_crc_t FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const z_crc_t FAR *)crc_table;
-}
-
-/* ========================================================================= */
-#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
-#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
-
-/* ========================================================================= */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    if (buf == Z_NULL) return 0UL;
-
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-
-#ifdef BYFOUR
-    if (sizeof(void *) == sizeof(z_size_t)) {
-        z_crc_t endian;
-
-        endian = 1;
-        if (*((unsigned char *)(&endian)))
-            return crc32_little(crc, buf, len);
-        else
-            return crc32_big(crc, buf, len);
-    }
-#endif /* BYFOUR */
-    crc = crc ^ 0xffffffffUL;
-    while (len >= 8) {
-        DO8;
-        len -= 8;
-    }
-    if (len) do {
-        DO1;
-    } while (--len);
-    return crc ^ 0xffffffffUL;
-}
-
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    uInt len;
-{
-    return crc32_z(crc, buf, len);
-}
-
-#ifdef BYFOUR
-
-/*
-   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
-   integer pointer type. This violates the strict aliasing rule, where a
-   compiler can assume, for optimization purposes, that two pointers to
-   fundamentally different types won't ever point to the same memory. This can
-   manifest as a problem only if one of the pointers is written to. This code
-   only reads from those pointers. So long as this code remains isolated in
-   this compilation unit, there won't be a problem. For this reason, this code
-   should not be copied and pasted into a compilation unit in which other code
-   writes to the buffer that is passed to these routines.
- */
-
-/* ========================================================================= */
-#define DOLIT4 c ^= *buf4++; \
-        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
-            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
-#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
-
-/* ========================================================================= */
-local unsigned long crc32_little(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    register z_crc_t c;
-    register const z_crc_t FAR *buf4;
-
-    c = (z_crc_t)crc;
-    c = ~c;
-    while (len && ((z_size_t)buf & 3)) {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-        len--;
-    }
-
-    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
-    while (len >= 32) {
-        DOLIT32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOLIT4;
-        len -= 4;
-    }
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)c;
-}
-
-/* ========================================================================= */
-#define DOBIG4 c ^= *buf4++; \
-        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
-            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
-#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
-
-/* ========================================================================= */
-local unsigned long crc32_big(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    register z_crc_t c;
-    register const z_crc_t FAR *buf4;
-
-    c = ZSWAP32((z_crc_t)crc);
-    c = ~c;
-    while (len && ((z_size_t)buf & 3)) {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-        len--;
-    }
-
-    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
-    while (len >= 32) {
-        DOBIG32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOBIG4;
-        len -= 4;
-    }
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)(ZSWAP32(c));
-}
-
-#endif /* BYFOUR */
-
-#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
-
-/* ========================================================================= */
-local unsigned long gf2_matrix_times(mat, vec)
-    unsigned long *mat;
-    unsigned long vec;
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec & 1)
-            sum ^= *mat;
-        vec >>= 1;
-        mat++;
-    }
-    return sum;
-}
-
-/* ========================================================================= */
-local void gf2_matrix_square(square, mat)
-    unsigned long *square;
-    unsigned long *mat;
-{
-    int n;
-
-    for (n = 0; n < GF2_DIM; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-/* ========================================================================= */
-local uLong crc32_combine_(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    int n;
-    unsigned long row;
-    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
-    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
-
-    /* degenerate case (also disallow negative lengths) */
-    if (len2 <= 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n < GF2_DIM; n++) {
-        odd[n] = row;
-        row <<= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
-
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
-
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
diff --git a/contrib/zlib/crc32.h b/contrib/zlib/crc32.h
deleted file mode 100644
index 9e0c77810..000000000
--- a/contrib/zlib/crc32.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/* crc32.h -- tables for rapid CRC calculation
- * Generated automatically by crc32.c
- */
-
-local const z_crc_t FAR crc_table[TBLS][256] =
-{
-  {
-    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-    0x2d02ef8dUL
-#ifdef BYFOUR
-  },
-  {
-    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
-    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
-    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
-    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
-    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
-    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
-    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
-    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
-    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
-    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
-    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
-    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
-    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
-    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
-    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
-    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
-    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
-    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
-    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
-    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
-    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
-    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
-    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
-    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
-    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
-    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
-    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
-    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
-    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
-    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
-    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
-    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
-    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
-    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
-    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
-    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
-    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
-    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
-    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
-    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
-    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
-    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
-    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
-    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
-    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
-    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
-    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
-    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
-    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
-    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
-    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
-    0x9324fd72UL
-  },
-  {
-    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
-    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
-    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
-    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
-    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
-    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
-    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
-    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
-    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
-    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
-    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
-    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
-    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
-    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
-    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
-    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
-    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
-    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
-    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
-    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
-    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
-    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
-    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
-    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
-    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
-    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
-    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
-    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
-    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
-    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
-    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
-    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
-    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
-    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
-    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
-    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
-    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
-    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
-    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
-    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
-    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
-    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
-    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
-    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
-    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
-    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
-    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
-    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
-    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
-    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
-    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
-    0xbe9834edUL
-  },
-  {
-    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
-    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
-    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
-    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
-    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
-    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
-    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
-    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
-    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
-    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
-    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
-    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
-    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
-    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
-    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
-    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
-    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
-    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
-    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
-    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
-    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
-    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
-    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
-    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
-    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
-    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
-    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
-    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
-    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
-    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
-    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
-    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
-    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
-    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
-    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
-    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
-    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
-    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
-    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
-    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
-    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
-    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
-    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
-    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
-    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
-    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
-    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
-    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
-    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
-    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
-    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
-    0xde0506f1UL
-  },
-  {
-    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
-    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
-    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
-    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
-    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
-    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
-    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
-    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
-    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
-    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
-    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
-    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
-    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
-    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
-    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
-    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
-    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
-    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
-    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
-    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
-    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
-    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
-    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
-    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
-    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
-    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
-    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
-    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
-    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
-    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
-    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
-    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
-    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
-    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
-    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
-    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
-    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
-    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
-    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
-    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
-    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
-    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
-    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
-    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
-    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
-    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
-    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
-    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
-    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
-    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
-    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
-    0x8def022dUL
-  },
-  {
-    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
-    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
-    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
-    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
-    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
-    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
-    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
-    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
-    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
-    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
-    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
-    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
-    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
-    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
-    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
-    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
-    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
-    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
-    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
-    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
-    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
-    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
-    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
-    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
-    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
-    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
-    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
-    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
-    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
-    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
-    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
-    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
-    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
-    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
-    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
-    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
-    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
-    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
-    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
-    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
-    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
-    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
-    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
-    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
-    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
-    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
-    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
-    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
-    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
-    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
-    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
-    0x72fd2493UL
-  },
-  {
-    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
-    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
-    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
-    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
-    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
-    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
-    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
-    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
-    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
-    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
-    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
-    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
-    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
-    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
-    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
-    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
-    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
-    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
-    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
-    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
-    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
-    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
-    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
-    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
-    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
-    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
-    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
-    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
-    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
-    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
-    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
-    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
-    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
-    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
-    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
-    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
-    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
-    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
-    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
-    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
-    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
-    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
-    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
-    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
-    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
-    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
-    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
-    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
-    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
-    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
-    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
-    0xed3498beUL
-  },
-  {
-    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
-    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
-    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
-    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
-    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
-    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
-    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
-    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
-    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
-    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
-    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
-    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
-    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
-    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
-    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
-    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
-    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
-    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
-    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
-    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
-    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
-    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
-    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
-    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
-    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
-    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
-    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
-    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
-    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
-    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
-    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
-    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
-    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
-    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
-    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
-    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
-    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
-    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
-    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
-    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
-    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
-    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
-    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
-    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
-    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
-    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
-    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
-    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
-    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
-    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
-    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
-    0xf10605deUL
-#endif
-  }
-};
diff --git a/contrib/zlib/deflate.c b/contrib/zlib/deflate.c
deleted file mode 100644
index 568eaddbe..000000000
--- a/contrib/zlib/deflate.c
+++ /dev/null
@@ -1,2174 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://tools.ietf.org/html/rfc1951
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-/* @(#) $Id$ */
-
-#include "deflate.h"
-
-const char deflate_copyright[] =
-   " deflate 1.2.11.1 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local int deflateStateCheck      OF((z_streamp strm));
-local void slide_hash     OF((deflate_state *s));
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-local block_state deflate_rle    OF((deflate_state *s, int flush));
-local block_state deflate_huff   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifdef ASMV
-#  pragma message("Assembler code may have bugs -- use at your own risk")
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#endif
-
-#ifdef ZLIB_DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
-#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
- *    characters, so that a running hash key can be computed from the previous
- *    key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to INSERT_STRING are made with consecutive input
- *    characters and the first MIN_MATCH bytes of str are valid (except for
- *    the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    do { \
-        s->head[s->hash_size-1] = NIL; \
-        zmemzero((Bytef *)s->head, \
-                 (unsigned)(s->hash_size-1)*sizeof(*s->head)); \
-    } while (0)
-
-/* ===========================================================================
- * Slide the hash table when sliding the window down (could be avoided with 32
- * bit values at the expense of memory usage). We slide even when level == 0 to
- * keep the hash table consistent if we switch back to level > 0 later.
- */
-local void slide_hash(s)
-    deflate_state *s;
-{
-    unsigned n, m;
-    Posf *p;
-    uInt wsize = s->w_size;
-
-    n = s->hash_size;
-    p = &s->head[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-    } while (--n);
-    n = wsize;
-#ifndef FASTEST
-    p = &s->prev[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-        /* If n is not on any hash chain, prev[n] is garbage but
-         * its value will never be used.
-         */
-    } while (--n);
-#endif
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
-
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = (uInt)windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = (uInt)memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-
-    s->high_water = 0;      /* nothing written to s->window yet */
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return deflateReset(strm);
-}
-
-/* =========================================================================
- * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
- */
-local int deflateStateCheck (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    s = strm->state;
-    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
-#ifdef GZIP
-                                           s->status != GZIP_STATE &&
-#endif
-                                           s->status != EXTRA_STATE &&
-                                           s->status != NAME_STATE &&
-                                           s->status != COMMENT_STATE &&
-                                           s->status != HCRC_STATE &&
-                                           s->status != BUSY_STATE &&
-                                           s->status != FINISH_STATE))
-        return 1;
-    return 0;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt str, n;
-    int wrap;
-    unsigned avail;
-    z_const unsigned char *next;
-
-    if (deflateStateCheck(strm) || dictionary == Z_NULL)
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    wrap = s->wrap;
-    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
-        return Z_STREAM_ERROR;
-
-    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
-    if (wrap == 1)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
-
-    /* if dictionary would fill window, just replace the history */
-    if (dictLength >= s->w_size) {
-        if (wrap == 0) {            /* already empty otherwise */
-            CLEAR_HASH(s);
-            s->strstart = 0;
-            s->block_start = 0L;
-            s->insert = 0;
-        }
-        dictionary += dictLength - s->w_size;  /* use the tail */
-        dictLength = s->w_size;
-    }
-
-    /* insert dictionary into window and hash */
-    avail = strm->avail_in;
-    next = strm->next_in;
-    strm->avail_in = dictLength;
-    strm->next_in = (z_const Bytef *)dictionary;
-    fill_window(s);
-    while (s->lookahead >= MIN_MATCH) {
-        str = s->strstart;
-        n = s->lookahead - (MIN_MATCH-1);
-        do {
-            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-            s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-            s->head[s->ins_h] = (Pos)str;
-            str++;
-        } while (--n);
-        s->strstart = str;
-        s->lookahead = MIN_MATCH-1;
-        fill_window(s);
-    }
-    s->strstart += s->lookahead;
-    s->block_start = (long)s->strstart;
-    s->insert = s->lookahead;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    strm->next_in = next;
-    strm->avail_in = avail;
-    s->wrap = wrap;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateGetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    Bytef *dictionary;
-    uInt  *dictLength;
-{
-    deflate_state *s;
-    uInt len;
-
-    if (deflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    len = s->strstart + s->lookahead;
-    if (len > s->w_size)
-        len = s->w_size;
-    if (dictionary != Z_NULL && len)
-        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
-    if (dictLength != Z_NULL)
-        *dictLength = len;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateResetKeep (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-
-    if (deflateStateCheck(strm)) {
-        return Z_STREAM_ERROR;
-    }
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status =
-#ifdef GZIP
-        s->wrap == 2 ? GZIP_STATE :
-#endif
-        s->wrap ? INIT_STATE : BUSY_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = -2;
-
-    _tr_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
-{
-    int ret;
-
-    ret = deflateResetKeep(strm);
-    if (ret == Z_OK)
-        lm_init(strm->state);
-    return ret;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader (strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (deflateStateCheck(strm) || strm->state->wrap != 2)
-        return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePending (strm, pending, bits)
-    unsigned *pending;
-    int *bits;
-    z_streamp strm;
-{
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    if (pending != Z_NULL)
-        *pending = strm->state->pending;
-    if (bits != Z_NULL)
-        *bits = strm->state->bi_valid;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePrime (strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    deflate_state *s;
-    int put;
-
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
-        return Z_BUF_ERROR;
-    do {
-        put = Buf_size - s->bi_valid;
-        if (put > bits)
-            put = bits;
-        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
-        s->bi_valid += put;
-        _tr_flush_bits(s);
-        value >>= put;
-        bits -= put;
-    } while (bits);
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if ((strategy != s->strategy || func != configuration_table[level].func) &&
-        s->last_flush != -2) {
-        /* Flush the last buffer: */
-        int err = deflate(strm, Z_BLOCK);
-        if (err == Z_STREAM_ERROR)
-            return err;
-        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
-            return Z_BUF_ERROR;
-    }
-    if (s->level != level) {
-        if (s->level == 0 && s->matches != 0) {
-            if (s->matches == 1)
-                slide_hash(s);
-            else
-                CLEAR_HASH(s);
-            s->matches = 0;
-        }
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = (uInt)good_length;
-    s->max_lazy_match = (uInt)max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = (uInt)max_chain;
-    return Z_OK;
-}
-
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns
- * a close to exact, as well as small, upper bound on the compressed size.
- * They are coded as constants here for a reason--if the #define's are
- * changed, then this function needs to be changed as well.  The return
- * value for 15 and 8 only works for those exact settings.
- *
- * For any setting other than those defaults for windowBits and memLevel,
- * the value returned is a conservative worst case for the maximum expansion
- * resulting from using fixed blocks instead of stored blocks, which deflate
- * can emit on compressed data for some combinations of the parameters.
- *
- * This function could be more sophisticated to provide closer upper bounds for
- * every combination of windowBits and memLevel.  But even the conservative
- * upper bound of about 14% expansion does not seem onerous for output buffer
- * allocation.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong complen, wraplen;
-
-    /* conservative upper bound for compressed data */
-    complen = sourceLen +
-              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
-
-    /* if can't get parameters, return conservative bound plus zlib wrapper */
-    if (deflateStateCheck(strm))
-        return complen + 6;
-
-    /* compute wrapper length */
-    s = strm->state;
-    switch (s->wrap) {
-    case 0:                                 /* raw deflate */
-        wraplen = 0;
-        break;
-    case 1:                                 /* zlib wrapper */
-        wraplen = 6 + (s->strstart ? 4 : 0);
-        break;
-#ifdef GZIP
-    case 2:                                 /* gzip wrapper */
-        wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            Bytef *str;
-            if (s->gzhead->extra != Z_NULL)
-                wraplen += 2 + s->gzhead->extra_len;
-            str = s->gzhead->name;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            str = s->gzhead->comment;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            if (s->gzhead->hcrc)
-                wraplen += 2;
-        }
-        break;
-#endif
-    default:                                /* for compiler happiness */
-        wraplen = 6;
-    }
-
-    /* if not default parameters, return conservative bound */
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return complen + wraplen;
-
-    /* default settings: return tight bound for that case */
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13 - 6 + wraplen;
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output, except for
- * some deflate_stored() output, goes through this function so some
- * applications may wish to modify it to avoid allocating a large
- * strm->next_out buffer and copying into it. (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len;
-    deflate_state *s = strm->state;
-
-    _tr_flush_bits(s);
-    len = s->pending;
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    zmemcpy(strm->next_out, s->pending_out, len);
-    strm->next_out  += len;
-    s->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out -= len;
-    s->pending      -= len;
-    if (s->pending == 0) {
-        s->pending_out = s->pending_buf;
-    }
-}
-
-/* ===========================================================================
- * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
- */
-#define HCRC_UPDATE(beg) \
-    do { \
-        if (s->gzhead->hcrc && s->pending > (beg)) \
-            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
-                                s->pending - (beg)); \
-    } while (0)
-
-/* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-
-    if (strm->next_out == Z_NULL ||
-        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* Write the header */
-    if (s->status == INIT_STATE) {
-        /* zlib header */
-        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-        uInt level_flags;
-
-        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-            level_flags = 0;
-        else if (s->level < 6)
-            level_flags = 1;
-        else if (s->level == 6)
-            level_flags = 2;
-        else
-            level_flags = 3;
-        header |= (level_flags << 6);
-        if (s->strstart != 0) header |= PRESET_DICT;
-        header += 31 - (header % 31);
-
-        putShortMSB(s, header);
-
-        /* Save the adler32 of the preset dictionary: */
-        if (s->strstart != 0) {
-            putShortMSB(s, (uInt)(strm->adler >> 16));
-            putShortMSB(s, (uInt)(strm->adler & 0xffff));
-        }
-        strm->adler = adler32(0L, Z_NULL, 0);
-        s->status = BUSY_STATE;
-
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#ifdef GZIP
-    if (s->status == GZIP_STATE) {
-        /* gzip header */
-        strm->adler = crc32(0L, Z_NULL, 0);
-        put_byte(s, 31);
-        put_byte(s, 139);
-        put_byte(s, 8);
-        if (s->gzhead == Z_NULL) {
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, OS_CODE);
-            s->status = BUSY_STATE;
-
-            /* Compression must start with an empty pending buffer */
-            flush_pending(strm);
-            if (s->pending != 0) {
-                s->last_flush = -1;
-                return Z_OK;
-            }
-        }
-        else {
-            put_byte(s, (s->gzhead->text ? 1 : 0) +
-                     (s->gzhead->hcrc ? 2 : 0) +
-                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                     (s->gzhead->name == Z_NULL ? 0 : 8) +
-                     (s->gzhead->comment == Z_NULL ? 0 : 16)
-                     );
-            put_byte(s, (Byte)(s->gzhead->time & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, s->gzhead->os & 0xff);
-            if (s->gzhead->extra != Z_NULL) {
-                put_byte(s, s->gzhead->extra_len & 0xff);
-                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-            }
-            if (s->gzhead->hcrc)
-                strm->adler = crc32(strm->adler, s->pending_buf,
-                                    s->pending);
-            s->gzindex = 0;
-            s->status = EXTRA_STATE;
-        }
-    }
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
-            while (s->pending + left > s->pending_buf_size) {
-                uInt copy = s->pending_buf_size - s->pending;
-                zmemcpy(s->pending_buf + s->pending,
-                        s->gzhead->extra + s->gzindex, copy);
-                s->pending = s->pending_buf_size;
-                HCRC_UPDATE(beg);
-                s->gzindex += copy;
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-                beg = 0;
-                left -= copy;
-            }
-            zmemcpy(s->pending_buf + s->pending,
-                    s->gzhead->extra + s->gzindex, left);
-            s->pending += left;
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-        }
-        s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size) {
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-            }
-            put_byte(s, (Byte)(strm->adler & 0xff));
-            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-            strm->adler = crc32(0L, Z_NULL, 0);
-        }
-        s->status = BUSY_STATE;
-
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#endif
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-        bstate = s->level == 0 ? deflate_stored(s, flush) :
-                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
-                 s->strategy == Z_RLE ? deflate_rle(s, flush) :
-                 (*(configuration_table[s->level].func))(s, flush);
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                    if (s->lookahead == 0) {
-                        s->strstart = 0;
-                        s->block_start = 0L;
-                        s->insert = 0;
-                    }
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-
-    status = strm->state->status;
-
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-
-
-    if (deflateStateCheck(source) || dest == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = source->state;
-
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
-    ds->strm = dest;
-
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uchf *) overlay;
-
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local unsigned read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    zmemcpy(buf, strm->next_in, len);
-    if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, buf, len);
-    }
-#ifdef GZIP
-    else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, buf, len);
-    }
-#endif
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->insert = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-#ifndef FASTEST
-#ifdef ASMV
-    match_init(); /* initialize the asm code */
-#endif
-#endif
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-#ifndef ASMV
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                      /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = (int)s->prev_length;         /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2.  Note that the checks below
-         * for insufficient lookahead only occur occasionally for performance
-         * reasons.  Therefore uninitialized memory will be accessed, and
-         * conditional jumps will be made that depend on those values.
-         * However the length of the match is limited to the lookahead, so
-         * the output of deflate is not affected by the uninitialized values.
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-#endif /* ASMV */
-
-#else /* FASTEST */
-
-/* ---------------------------------------------------------------------------
- * Optimized version for FASTEST only
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    Assert(cur_match < s->strstart, "no future");
-
-    match = s->window + cur_match;
-
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-
-    /* The check at best_len-1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart+258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-    len = MAX_MATCH - (int)(strend - scan);
-
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-
-    s->match_start = cur_match;
-    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
-}
-
-#endif /* FASTEST */
-
-#ifdef ZLIB_DEBUG
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif /* ZLIB_DEBUG */
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    unsigned n;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-            if (s->insert > s->strstart)
-                s->insert = s->strstart;
-            slide_hash(s);
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) break;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
-            s->ins_h = s->window[str];
-            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-            while (s->insert) {
-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-                s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-                s->head[s->ins_h] = (Pos)str;
-                str++;
-                s->insert--;
-                if (s->lookahead + s->insert < MIN_MATCH)
-                    break;
-            }
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-
-    /* If the WIN_INIT bytes after the end of the current data have never been
-     * written, then zero those bytes in order to avoid memory check reports of
-     * the use of uninitialized (or uninitialised as Julian writes) bytes by
-     * the longest match routines.  Update the high water mark for the next
-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
-     */
-    if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
-
-        if (s->high_water < curr) {
-            /* Previous high water mark below current data -- zero WIN_INIT
-             * bytes or up to end of window, whichever is less.
-             */
-            init = s->window_size - curr;
-            if (init > WIN_INIT)
-                init = WIN_INIT;
-            zmemzero(s->window + curr, (unsigned)init);
-            s->high_water = curr + init;
-        }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
-            /* High water mark at or above current data, but below current data
-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
-             * to end of window, whichever is less.
-             */
-            init = (ulg)curr + WIN_INIT - s->high_water;
-            if (init > s->window_size - s->high_water)
-                init = s->window_size - s->high_water;
-            zmemzero(s->window + s->high_water, (unsigned)init);
-            s->high_water += init;
-        }
-    }
-
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "not enough room for search");
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, last) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (last)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, last) { \
-   FLUSH_BLOCK_ONLY(s, last); \
-   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
-}
-
-/* Maximum stored block length in deflate format (not including header). */
-#define MAX_STORED 65535
-
-/* Minimum of a and b. */
-#define MIN(a, b) ((a) > (b) ? (b) : (a))
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- *
- * In case deflateParams() is used to later switch to a non-zero compression
- * level, s->matches (otherwise unused when storing) keeps track of the number
- * of hash table slides to perform. If s->matches is 1, then one hash table
- * slide will be done when switching. If s->matches is 2, the maximum value
- * allowed here, then the hash table will be cleared, since two or more slides
- * is the same as a clear.
- *
- * deflate_stored() is written to minimize the number of times an input byte is
- * copied. It is most efficient with large input and output buffers, which
- * maximizes the opportunites to have a single copy from next_in to next_out.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Smallest worthy block size when not flushing or finishing. By default
-     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
-     * large input and output buffers, the stored block size will be larger.
-     */
-    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
-
-    /* Copy as many min_block or larger stored blocks directly to next_out as
-     * possible. If flushing, copy the remaining available input to next_out as
-     * stored blocks, if there is enough space.
-     */
-    unsigned len, left, have, last = 0;
-    unsigned used = s->strm->avail_in;
-    do {
-        /* Set len to the maximum size block that we can copy directly with the
-         * available input data and output space. Set left to how much of that
-         * would be copied from what's left in the window.
-         */
-        len = MAX_STORED;       /* maximum deflate stored block length */
-        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        if (s->strm->avail_out < have)          /* need room for header */
-            break;
-            /* maximum stored block length that will fit in avail_out: */
-        have = s->strm->avail_out - have;
-        left = s->strstart - s->block_start;    /* bytes left in window */
-        if (len > (ulg)left + s->strm->avail_in)
-            len = left + s->strm->avail_in;     /* limit len to the input */
-        if (len > have)
-            len = have;                         /* limit len to the output */
-
-        /* If the stored block would be less than min_block in length, or if
-         * unable to copy all of the available input when flushing, then try
-         * copying to the window and the pending buffer instead. Also don't
-         * write an empty block when flushing -- deflate() does that.
-         */
-        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
-                                flush == Z_NO_FLUSH ||
-                                len != left + s->strm->avail_in))
-            break;
-
-        /* Make a dummy stored block in pending to get the header bytes,
-         * including any pending bits. This also updates the debugging counts.
-         */
-        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
-        _tr_stored_block(s, (char *)0, 0L, last);
-
-        /* Replace the lengths in the dummy stored block with len. */
-        s->pending_buf[s->pending - 4] = len;
-        s->pending_buf[s->pending - 3] = len >> 8;
-        s->pending_buf[s->pending - 2] = ~len;
-        s->pending_buf[s->pending - 1] = ~len >> 8;
-
-        /* Write the stored block header bytes. */
-        flush_pending(s->strm);
-
-#ifdef ZLIB_DEBUG
-        /* Update debugging counts for the data about to be copied. */
-        s->compressed_len += len << 3;
-        s->bits_sent += len << 3;
-#endif
-
-        /* Copy uncompressed bytes from the window to next_out. */
-        if (left) {
-            if (left > len)
-                left = len;
-            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
-            s->strm->next_out += left;
-            s->strm->avail_out -= left;
-            s->strm->total_out += left;
-            s->block_start += left;
-            len -= left;
-        }
-
-        /* Copy uncompressed bytes directly from next_in to next_out, updating
-         * the check value.
-         */
-        if (len) {
-            read_buf(s->strm, s->strm->next_out, len);
-            s->strm->next_out += len;
-            s->strm->avail_out -= len;
-            s->strm->total_out += len;
-        }
-    } while (last == 0);
-
-    /* Update the sliding window with the last s->w_size bytes of the copied
-     * data, or append all of the copied data to the existing window if less
-     * than s->w_size bytes were copied. Also update the number of bytes to
-     * insert in the hash tables, in the event that deflateParams() switches to
-     * a non-zero compression level.
-     */
-    used -= s->strm->avail_in;      /* number of input bytes directly copied */
-    if (used) {
-        /* If any input was used, then no unused input remains in the window,
-         * therefore s->block_start == s->strstart.
-         */
-        if (used >= s->w_size) {    /* supplant the previous history */
-            s->matches = 2;         /* clear hash */
-            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
-            s->strstart = s->w_size;
-            s->insert = s->strstart;
-        }
-        else {
-            if (s->window_size - s->strstart <= used) {
-                /* Slide the window down. */
-                s->strstart -= s->w_size;
-                zmemcpy(s->window, s->window + s->w_size, s->strstart);
-                if (s->matches < 2)
-                    s->matches++;   /* add a pending slide_hash() */
-                if (s->insert > s->strstart)
-                    s->insert = s->strstart;
-            }
-            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
-            s->strstart += used;
-            s->insert += MIN(used, s->w_size - s->insert);
-        }
-        s->block_start = s->strstart;
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-
-    /* If the last block was written to next_out, then done. */
-    if (last)
-        return finish_done;
-
-    /* If flushing and all input has been consumed, then done. */
-    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
-        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
-        return block_done;
-
-    /* Fill the window with any remaining input. */
-    have = s->window_size - s->strstart;
-    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
-        /* Slide the window down. */
-        s->block_start -= s->w_size;
-        s->strstart -= s->w_size;
-        zmemcpy(s->window, s->window + s->w_size, s->strstart);
-        if (s->matches < 2)
-            s->matches++;           /* add a pending slide_hash() */
-        have += s->w_size;          /* more space now */
-        if (s->insert > s->strstart)
-            s->insert = s->strstart;
-    }
-    if (have > s->strm->avail_in)
-        have = s->strm->avail_in;
-    if (have) {
-        read_buf(s->strm, s->window + s->strstart, have);
-        s->strstart += have;
-        s->insert += MIN(have, s->w_size - s->insert);
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-
-    /* There was not enough avail_out to write a complete worthy or flushed
-     * stored block to next_out. Write a stored block to pending instead, if we
-     * have enough input for a worthy block, or if flushing and there is enough
-     * room for the remaining input as a stored block in the pending buffer.
-     */
-    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        /* maximum stored block length that will fit in pending: */
-    have = MIN(s->pending_buf_size - have, MAX_STORED);
-    min_block = MIN(have, s->w_size);
-    left = s->strstart - s->block_start;
-    if (left >= min_block ||
-        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
-         s->strm->avail_in == 0 && left <= have)) {
-        len = MIN(left, have);
-        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
-               len == left ? 1 : 0;
-        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
-        s->block_start += len;
-        flush_pending(s->strm);
-    }
-
-    /* We've done all we can with the available input and output. */
-    return last ? finish_started : need_more;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;       /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;          /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-        s->match_available = 0;
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#endif /* FASTEST */
-
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest run, plus one for the unrolled loop.
-         */
-        if (s->lookahead <= MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* See how many times the previous byte repeats */
-        s->match_length = 0;
-        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
-            scan = s->window + s->strstart - 1;
-            prev = *scan;
-            if (prev == *++scan && prev == *++scan && prev == *++scan) {
-                strend = s->window + s->strstart + MAX_MATCH;
-                do {
-                } while (prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         scan < strend);
-                s->match_length = MAX_MATCH - (uInt)(strend - scan);
-                if (s->match_length > s->lookahead)
-                    s->match_length = s->lookahead;
-            }
-            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
-        }
-
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, s->match_length);
-
-            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-            s->strstart += s->match_length;
-            s->match_length = 0;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-
-/* ===========================================================================
- * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
- * (It will be regenerated if this run of deflate switches away from Huffman.)
- */
-local block_state deflate_huff(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we have a literal to write. */
-        if (s->lookahead == 0) {
-            fill_window(s);
-            if (s->lookahead == 0) {
-                if (flush == Z_NO_FLUSH)
-                    return need_more;
-                break;      /* flush the current block */
-            }
-        }
-
-        /* Output a literal byte */
-        s->match_length = 0;
-        Tracevv((stderr,"%c", s->window[s->strstart]));
-        _tr_tally_lit (s, s->window[s->strstart], bflush);
-        s->lookahead--;
-        s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
diff --git a/contrib/zlib/deflate.h b/contrib/zlib/deflate.h
deleted file mode 100644
index 23ecdd312..000000000
--- a/contrib/zlib/deflate.h
+++ /dev/null
@@ -1,349 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2016 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef DEFLATE_H
-#define DEFLATE_H
-
-#include "zutil.h"
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define Buf_size 16
-/* size of bit buffer in bi_buf */
-
-#define INIT_STATE    42    /* zlib header -> BUSY_STATE */
-#ifdef GZIP
-#  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */
-#endif
-#define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */
-#define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */
-#define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */
-#define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */
-#define BUSY_STATE   113    /* deflate -> FINISH_STATE */
-#define FINISH_STATE 666    /* stream complete */
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    const static_tree_desc *stat_desc;  /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    ulg   pending;       /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    ulg   gzindex;       /* where in extra, name, or comment */
-    Byte  method;        /* can only be DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to suppress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    uInt insert;        /* bytes at end of window left to insert */
-
-#ifdef ZLIB_DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-    ulg high_water;
-    /* High water mark offset in window for initialized bytes -- bytes above
-     * this are set to zero in order to avoid memory check warnings when
-     * longest match routines access bytes past the input.  This is then
-     * updated to the new high water mark.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-#define WIN_INIT MAX_MATCH
-/* Number of bytes after end of data in window to initialize in order to avoid
-   memory checker errors from longest match routines */
-
-        /* in trees.c */
-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef ZLIB_DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (uch)(length); \
-    ush dist = (ush)(distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif /* DEFLATE_H */
diff --git a/contrib/zlib/gzclose.c b/contrib/zlib/gzclose.c
deleted file mode 100644
index caeb99a31..000000000
--- a/contrib/zlib/gzclose.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/* gzclose.c -- zlib gzclose() function
- * Copyright (C) 2004, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* gzclose() is in a separate file so that it is linked in only if it is used.
-   That way the other gzclose functions can be used instead to avoid linking in
-   unneeded compression or decompression routines. */
-int ZEXPORT gzclose(file)
-    gzFile file;
-{
-#ifndef NO_GZCOMPRESS
-    gz_statep state;
-
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
-#else
-    return gzclose_r(file);
-#endif
-}
diff --git a/contrib/zlib/gzguts.h b/contrib/zlib/gzguts.h
deleted file mode 100644
index 6378d468a..000000000
--- a/contrib/zlib/gzguts.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* gzguts.h -- zlib internal header definitions for gz* operations
- * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifdef _LARGEFILE64_SOURCE
-#  ifndef _LARGEFILE_SOURCE
-#    define _LARGEFILE_SOURCE 1
-#  endif
-#  ifdef _FILE_OFFSET_BITS
-#    undef _FILE_OFFSET_BITS
-#  endif
-#endif
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include <stdio.h>
-#include "zlib.h"
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#  include <limits.h>
-#endif
-
-#ifndef _POSIX_SOURCE
-#  define _POSIX_SOURCE
-#endif
-#include <fcntl.h>
-
-#ifdef _WIN32
-#  include <stddef.h>
-#endif
-
-#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
-#  include <io.h>
-#endif
-
-#if defined(_WIN32)
-#  define WIDECHAR
-#endif
-
-#ifdef WINAPI_FAMILY
-#  define open _open
-#  define read _read
-#  define write _write
-#  define close _close
-#endif
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
-   but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
-#         define vsnprintf _vsnprintf
-#      endif
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#  ifdef VMS
-#    define NO_vsnprintf
-#  endif
-#  ifdef __OS400__
-#    define NO_vsnprintf
-#  endif
-#  ifdef __MVS__
-#    define NO_vsnprintf
-#  endif
-#endif
-
-/* unlike snprintf (which is required in C99), _snprintf does not guarantee
-   null termination of the result -- however this is only used in gzlib.c where
-   the result is assured to fit in the space provided */
-#if defined(_MSC_VER) && _MSC_VER < 1900
-#  define snprintf _snprintf
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* since "static" is used to mean two completely different things in C, we
-   define "local" for the non-static meaning of "static", for readability
-   (compile with -Dlocal if your debugger can't find static symbols) */
-
-/* gz* functions always use library allocation functions */
-#ifndef STDC
-  extern voidp  malloc OF((uInt size));
-  extern void   free   OF((voidpf ptr));
-#endif
-
-/* get errno and strerror definition */
-#if defined UNDER_CE
-#  include <windows.h>
-#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
-#else
-#  ifndef NO_STRERROR
-#    include <errno.h>
-#    define zstrerror() strerror(errno)
-#  else
-#    define zstrerror() "stdio error (consult errno)"
-#  endif
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-#endif
-
-/* default memLevel */
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-
-/* default i/o buffer size -- double this for output when reading (this and
-   twice this must be able to fit in an unsigned type) */
-#define GZBUFSIZE 8192
-
-/* gzip modes, also provide a little integrity check on the passed structure */
-#define GZ_NONE 0
-#define GZ_READ 7247
-#define GZ_WRITE 31153
-#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */
-
-/* values for gz_state how */
-#define LOOK 0      /* look for a gzip header */
-#define COPY 1      /* copy input directly */
-#define GZIP 2      /* decompress a gzip stream */
-
-/* internal gzip file state data structure */
-typedef struct {
-        /* exposed contents for gzgetc() macro */
-    struct gzFile_s x;      /* "x" for exposed */
-                            /* x.have: number of bytes available at x.next */
-                            /* x.next: next output data to deliver or write */
-                            /* x.pos: current position in uncompressed data */
-        /* used for both reading and writing */
-    int mode;               /* see gzip modes above */
-    int fd;                 /* file descriptor */
-    char *path;             /* path or fd for error messages */
-    unsigned size;          /* buffer size, zero if not allocated yet */
-    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
-    unsigned char *in;      /* input buffer (double-sized when writing) */
-    unsigned char *out;     /* output buffer (double-sized when reading) */
-    int direct;             /* 0 if processing gzip, 1 if transparent */
-        /* just for reading */
-    int how;                /* 0: get header, 1: copy, 2: decompress */
-    z_off64_t start;        /* where the gzip data started, for rewinding */
-    int eof;                /* true if end of input file reached */
-    int past;               /* true if read requested past end */
-        /* just for writing */
-    int level;              /* compression level */
-    int strategy;           /* compression strategy */
-        /* seek request */
-    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
-    int seek;               /* true if seek request pending */
-        /* error information */
-    int err;                /* error code */
-    char *msg;              /* error message */
-        /* zlib inflate or deflate stream */
-    z_stream strm;          /* stream structure in-place (not a pointer) */
-} gz_state;
-typedef gz_state FAR *gz_statep;
-
-/* shared functions */
-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
-#if defined UNDER_CE
-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
-#endif
-
-/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
-   value -- needed when comparing unsigned to z_off64_t, which is signed
-   (possible z_off64_t types off_t, off64_t, and long are all signed) */
-#ifdef INT_MAX
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
-#else
-unsigned ZLIB_INTERNAL gz_intmax OF((void));
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
-#endif
diff --git a/contrib/zlib/gzlib.c b/contrib/zlib/gzlib.c
deleted file mode 100644
index 4838bf047..000000000
--- a/contrib/zlib/gzlib.c
+++ /dev/null
@@ -1,637 +0,0 @@
-/* gzlib.c -- zlib functions common to reading and writing gzip files
- * Copyright (C) 2004-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-#if defined(_WIN32) && !defined(__BORLANDC__)
-#  define LSEEK _lseeki64
-#else
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define LSEEK lseek64
-#else
-#  define LSEEK lseek
-#endif
-#endif
-
-/* Local functions */
-local void gz_reset OF((gz_statep));
-local gzFile gz_open OF((const void *, int, const char *));
-
-#if defined UNDER_CE
-
-/* Map the Windows error number in ERROR to a locale-dependent error message
-   string and return a pointer to it.  Typically, the values for ERROR come
-   from GetLastError.
-
-   The string pointed to shall not be modified by the application, but may be
-   overwritten by a subsequent call to gz_strwinerror
-
-   The gz_strwinerror function does not change the current setting of
-   GetLastError. */
-char ZLIB_INTERNAL *gz_strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-#endif /* UNDER_CE */
-
-/* Reset gzip file state */
-local void gz_reset(state)
-    gz_statep state;
-{
-    state->x.have = 0;              /* no output data available */
-    if (state->mode == GZ_READ) {   /* for reading ... */
-        state->eof = 0;             /* not at end of file */
-        state->past = 0;            /* have not read past end yet */
-        state->how = LOOK;          /* look for gzip header */
-    }
-    state->seek = 0;                /* no seek request pending */
-    gz_error(state, Z_OK, NULL);    /* clear error */
-    state->x.pos = 0;               /* no uncompressed data yet */
-    state->strm.avail_in = 0;       /* no input data yet */
-}
-
-/* Open a gzip file either by name or file descriptor. */
-local gzFile gz_open(path, fd, mode)
-    const void *path;
-    int fd;
-    const char *mode;
-{
-    gz_statep state;
-    z_size_t len;
-    int oflag;
-#ifdef O_CLOEXEC
-    int cloexec = 0;
-#endif
-#ifdef O_EXCL
-    int exclusive = 0;
-#endif
-
-    /* check input */
-    if (path == NULL)
-        return NULL;
-
-    /* allocate gzFile structure to return */
-    state = (gz_statep)malloc(sizeof(gz_state));
-    if (state == NULL)
-        return NULL;
-    state->size = 0;            /* no buffers allocated yet */
-    state->want = GZBUFSIZE;    /* requested buffer size */
-    state->msg = NULL;          /* no error message yet */
-
-    /* interpret mode */
-    state->mode = GZ_NONE;
-    state->level = Z_DEFAULT_COMPRESSION;
-    state->strategy = Z_DEFAULT_STRATEGY;
-    state->direct = 0;
-    while (*mode) {
-        if (*mode >= '0' && *mode <= '9')
-            state->level = *mode - '0';
-        else
-            switch (*mode) {
-            case 'r':
-                state->mode = GZ_READ;
-                break;
-#ifndef NO_GZCOMPRESS
-            case 'w':
-                state->mode = GZ_WRITE;
-                break;
-            case 'a':
-                state->mode = GZ_APPEND;
-                break;
-#endif
-            case '+':       /* can't read and write at the same time */
-                free(state);
-                return NULL;
-            case 'b':       /* ignore -- will request binary anyway */
-                break;
-#ifdef O_CLOEXEC
-            case 'e':
-                cloexec = 1;
-                break;
-#endif
-#ifdef O_EXCL
-            case 'x':
-                exclusive = 1;
-                break;
-#endif
-            case 'f':
-                state->strategy = Z_FILTERED;
-                break;
-            case 'h':
-                state->strategy = Z_HUFFMAN_ONLY;
-                break;
-            case 'R':
-                state->strategy = Z_RLE;
-                break;
-            case 'F':
-                state->strategy = Z_FIXED;
-                break;
-            case 'T':
-                state->direct = 1;
-                break;
-            default:        /* could consider as an error, but just ignore */
-                ;
-            }
-        mode++;
-    }
-
-    /* must provide an "r", "w", or "a" */
-    if (state->mode == GZ_NONE) {
-        free(state);
-        return NULL;
-    }
-
-    /* can't force transparent read */
-    if (state->mode == GZ_READ) {
-        if (state->direct) {
-            free(state);
-            return NULL;
-        }
-        state->direct = 1;      /* for empty file */
-    }
-
-    /* save the path name for error messages */
-#ifdef WIDECHAR
-    if (fd == -2) {
-        len = wcstombs(NULL, path, 0);
-        if (len == (z_size_t)-1)
-            len = 0;
-    }
-    else
-#endif
-        len = strlen((const char *)path);
-    state->path = (char *)malloc(len + 1);
-    if (state->path == NULL) {
-        free(state);
-        return NULL;
-    }
-#ifdef WIDECHAR
-    if (fd == -2)
-        if (len)
-            wcstombs(state->path, path, len + 1);
-        else
-            *(state->path) = 0;
-    else
-#endif
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-        (void)snprintf(state->path, len + 1, "%s", (const char *)path);
-#else
-        strcpy(state->path, path);
-#endif
-
-    /* compute the flags for open() */
-    oflag =
-#ifdef O_LARGEFILE
-        O_LARGEFILE |
-#endif
-#ifdef O_BINARY
-        O_BINARY |
-#endif
-#ifdef O_CLOEXEC
-        (cloexec ? O_CLOEXEC : 0) |
-#endif
-        (state->mode == GZ_READ ?
-         O_RDONLY :
-         (O_WRONLY | O_CREAT |
-#ifdef O_EXCL
-          (exclusive ? O_EXCL : 0) |
-#endif
-          (state->mode == GZ_WRITE ?
-           O_TRUNC :
-           O_APPEND)));
-
-    /* open the file with the appropriate flags (or just use fd) */
-    state->fd = fd > -1 ? fd : (
-#ifdef WIDECHAR
-        fd == -2 ? _wopen(path, oflag, 0666) :
-#endif
-        open((const char *)path, oflag, 0666));
-    if (state->fd == -1) {
-        free(state->path);
-        free(state);
-        return NULL;
-    }
-    if (state->mode == GZ_APPEND) {
-        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
-        state->mode = GZ_WRITE;         /* simplify later checks */
-    }
-
-    /* save the current position for rewinding (only if reading) */
-    if (state->mode == GZ_READ) {
-        state->start = LSEEK(state->fd, 0, SEEK_CUR);
-        if (state->start == -1) state->start = 0;
-    }
-
-    /* initialize stream */
-    gz_reset(state);
-
-    /* return stream */
-    return (gzFile)state;
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen64(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzdopen(fd, mode)
-    int fd;
-    const char *mode;
-{
-    char *path;         /* identifier for error messages */
-    gzFile gz;
-
-    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
-        return NULL;
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-    (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
-#else
-    sprintf(path, "<fd:%d>", fd);   /* for debugging */
-#endif
-    gz = gz_open(path, fd, mode);
-    free(path);
-    return gz;
-}
-
-/* -- see zlib.h -- */
-#ifdef WIDECHAR
-gzFile ZEXPORT gzopen_w(path, mode)
-    const wchar_t *path;
-    const char *mode;
-{
-    return gz_open(path, -2, mode);
-}
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzbuffer(file, size)
-    gzFile file;
-    unsigned size;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* make sure we haven't already allocated memory */
-    if (state->size != 0)
-        return -1;
-
-    /* check and set requested size */
-    if ((size << 1) < size)
-        return -1;              /* need to be able to double it */
-    if (size < 2)
-        size = 2;               /* need two bytes to check magic header */
-    state->want = size;
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzrewind(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* back up and start over */
-    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
-        return -1;
-    gz_reset(state);
-    return 0;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzseek64(file, offset, whence)
-    gzFile file;
-    z_off64_t offset;
-    int whence;
-{
-    unsigned n;
-    z_off64_t ret;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* check that there's no error */
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-
-    /* can only seek from start or relative to current position */
-    if (whence != SEEK_SET && whence != SEEK_CUR)
-        return -1;
-
-    /* normalize offset to a SEEK_CUR specification */
-    if (whence == SEEK_SET)
-        offset -= state->x.pos;
-    else if (state->seek)
-        offset += state->skip;
-    state->seek = 0;
-
-    /* if within raw area while reading, just go there */
-    if (state->mode == GZ_READ && state->how == COPY &&
-            state->x.pos + offset >= 0) {
-        ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);
-        if (ret == -1)
-            return -1;
-        state->x.have = 0;
-        state->eof = 0;
-        state->past = 0;
-        state->seek = 0;
-        gz_error(state, Z_OK, NULL);
-        state->strm.avail_in = 0;
-        state->x.pos += offset;
-        return state->x.pos;
-    }
-
-    /* calculate skip amount, rewinding if needed for back seek when reading */
-    if (offset < 0) {
-        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
-            return -1;
-        offset += state->x.pos;
-        if (offset < 0)                     /* before start of file! */
-            return -1;
-        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
-            return -1;
-    }
-
-    /* if reading, skip what's in output buffer (one less gzgetc() check) */
-    if (state->mode == GZ_READ) {
-        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
-            (unsigned)offset : state->x.have;
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        offset -= n;
-    }
-
-    /* request skip (if not zero) */
-    if (offset) {
-        state->seek = 1;
-        state->skip = offset;
-    }
-    return state->x.pos + offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzseek(file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    z_off64_t ret;
-
-    ret = gzseek64(file, (z_off64_t)offset, whence);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gztell64(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* return position */
-    return state->x.pos + (state->seek ? state->skip : 0);
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gztell(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gztell64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzoffset64(file)
-    gzFile file;
-{
-    z_off64_t offset;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* compute and return effective offset in file */
-    offset = LSEEK(state->fd, 0, SEEK_CUR);
-    if (offset == -1)
-        return -1;
-    if (state->mode == GZ_READ)             /* reading */
-        offset -= state->strm.avail_in;     /* don't count buffered input */
-    return offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzoffset(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gzoffset64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzeof(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return 0;
-
-    /* return end-of-file state */
-    return state->mode == GZ_READ ? state->past : 0;
-}
-
-/* -- see zlib.h -- */
-const char * ZEXPORT gzerror(file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return NULL;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return NULL;
-
-    /* return error information */
-    if (errnum != NULL)
-        *errnum = state->err;
-    return state->err == Z_MEM_ERROR ? "out of memory" :
-                                       (state->msg == NULL ? "" : state->msg);
-}
-
-/* -- see zlib.h -- */
-void ZEXPORT gzclearerr(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return;
-
-    /* clear error and end-of-file */
-    if (state->mode == GZ_READ) {
-        state->eof = 0;
-        state->past = 0;
-    }
-    gz_error(state, Z_OK, NULL);
-}
-
-/* Create an error message in allocated memory and set state->err and
-   state->msg accordingly.  Free any previous error message already there.  Do
-   not try to free or allocate space if the error is Z_MEM_ERROR (out of
-   memory).  Simply save the error message as a static string.  If there is an
-   allocation failure constructing the error message, then convert the error to
-   out of memory. */
-void ZLIB_INTERNAL gz_error(state, err, msg)
-    gz_statep state;
-    int err;
-    const char *msg;
-{
-    /* free previously allocated message and clear */
-    if (state->msg != NULL) {
-        if (state->err != Z_MEM_ERROR)
-            free(state->msg);
-        state->msg = NULL;
-    }
-
-    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
-    if (err != Z_OK && err != Z_BUF_ERROR)
-        state->x.have = 0;
-
-    /* set error code, and if no message, then done */
-    state->err = err;
-    if (msg == NULL)
-        return;
-
-    /* for an out of memory error, return literal string when requested */
-    if (err == Z_MEM_ERROR)
-        return;
-
-    /* construct error message with path */
-    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
-            NULL) {
-        state->err = Z_MEM_ERROR;
-        return;
-    }
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
-                   "%s%s%s", state->path, ": ", msg);
-#else
-    strcpy(state->msg, state->path);
-    strcat(state->msg, ": ");
-    strcat(state->msg, msg);
-#endif
-}
-
-#ifndef INT_MAX
-/* portably return maximum value for an int (when limits.h presumed not
-   available) -- we need to do this to cover cases where 2's complement not
-   used, since C standard permits 1's complement and sign-bit representations,
-   otherwise we could just use ((unsigned)-1) >> 1 */
-unsigned ZLIB_INTERNAL gz_intmax()
-{
-    unsigned p, q;
-
-    p = 1;
-    do {
-        q = p;
-        p <<= 1;
-        p++;
-    } while (p > q);
-    return q >> 1;
-}
-#endif
diff --git a/contrib/zlib/gzread.c b/contrib/zlib/gzread.c
deleted file mode 100644
index f94abfed3..000000000
--- a/contrib/zlib/gzread.c
+++ /dev/null
@@ -1,652 +0,0 @@
-/* gzread.c -- zlib functions for reading gzip files
- * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
-local int gz_avail OF((gz_statep));
-local int gz_look OF((gz_statep));
-local int gz_decomp OF((gz_statep));
-local int gz_fetch OF((gz_statep));
-local int gz_skip OF((gz_statep, z_off64_t));
-local z_size_t gz_read OF((gz_statep, voidp, z_size_t));
-
-/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
-   state->fd, and update state->eof, state->err, and state->msg as appropriate.
-   This function needs to loop on read(), since read() is not guaranteed to
-   read the number of bytes requested, depending on the type of descriptor. */
-local int gz_load(state, buf, len, have)
-    gz_statep state;
-    unsigned char *buf;
-    unsigned len;
-    unsigned *have;
-{
-    int ret;
-    unsigned get, max = ((unsigned)-1 >> 2) + 1;
-
-    *have = 0;
-    do {
-        get = len - *have;
-        if (get > max)
-            get = max;
-        ret = read(state->fd, buf + *have, get);
-        if (ret <= 0)
-            break;
-        *have += (unsigned)ret;
-    } while (*have < len);
-    if (ret < 0) {
-        gz_error(state, Z_ERRNO, zstrerror());
-        return -1;
-    }
-    if (ret == 0)
-        state->eof = 1;
-    return 0;
-}
-
-/* Load up input buffer and set eof flag if last data loaded -- return -1 on
-   error, 0 otherwise.  Note that the eof flag is set when the end of the input
-   file is reached, even though there may be unused data in the buffer.  Once
-   that data has been used, no more attempts will be made to read the file.
-   If strm->avail_in != 0, then the current data is moved to the beginning of
-   the input buffer, and then the remainder of the buffer is loaded with the
-   available data from the input file. */
-local int gz_avail(state)
-    gz_statep state;
-{
-    unsigned got;
-    z_streamp strm = &(state->strm);
-
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-    if (state->eof == 0) {
-        if (strm->avail_in) {       /* copy what's there to the start */
-            unsigned char *p = state->in;
-            unsigned const char *q = strm->next_in;
-            unsigned n = strm->avail_in;
-            do {
-                *p++ = *q++;
-            } while (--n);
-        }
-        if (gz_load(state, state->in + strm->avail_in,
-                    state->size - strm->avail_in, &got) == -1)
-            return -1;
-        strm->avail_in += got;
-        strm->next_in = state->in;
-    }
-    return 0;
-}
-
-/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
-   If this is the first time in, allocate required memory.  state->how will be
-   left unchanged if there is no more input data available, will be set to COPY
-   if there is no gzip header and direct copying will be performed, or it will
-   be set to GZIP for decompression.  If direct copying, then leftover input
-   data from the input buffer will be copied to the output buffer.  In that
-   case, all further file reads will be directly to either the output buffer or
-   a user buffer.  If decompressing, the inflate state will be initialized.
-   gz_look() will return 0 on success or -1 on failure. */
-local int gz_look(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    /* allocate read buffers and inflate memory */
-    if (state->size == 0) {
-        /* allocate buffers */
-        state->in = (unsigned char *)malloc(state->want);
-        state->out = (unsigned char *)malloc(state->want << 1);
-        if (state->in == NULL || state->out == NULL) {
-            free(state->out);
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        state->size = state->want;
-
-        /* allocate inflate memory */
-        state->strm.zalloc = Z_NULL;
-        state->strm.zfree = Z_NULL;
-        state->strm.opaque = Z_NULL;
-        state->strm.avail_in = 0;
-        state->strm.next_in = Z_NULL;
-        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
-            free(state->out);
-            free(state->in);
-            state->size = 0;
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-    }
-
-    /* get at least the magic bytes in the input buffer */
-    if (strm->avail_in < 2) {
-        if (gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0)
-            return 0;
-    }
-
-    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
-       a logical dilemma here when considering the case of a partially written
-       gzip file, to wit, if a single 31 byte is written, then we cannot tell
-       whether this is a single-byte file, or just a partially written gzip
-       file -- for here we assume that if a gzip file is being written, then
-       the header will be written in a single operation, so that reading a
-       single byte is sufficient indication that it is not a gzip file) */
-    if (strm->avail_in > 1 &&
-            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
-        inflateReset(strm);
-        state->how = GZIP;
-        state->direct = 0;
-        return 0;
-    }
-
-    /* no gzip header -- if we were decoding gzip before, then this is trailing
-       garbage.  Ignore the trailing garbage and finish. */
-    if (state->direct == 0) {
-        strm->avail_in = 0;
-        state->eof = 1;
-        state->x.have = 0;
-        return 0;
-    }
-
-    /* doing raw i/o, copy any leftover input to output -- this assumes that
-       the output buffer is larger than the input buffer, which also assures
-       space for gzungetc() */
-    state->x.next = state->out;
-    if (strm->avail_in) {
-        memcpy(state->x.next, strm->next_in, strm->avail_in);
-        state->x.have = strm->avail_in;
-        strm->avail_in = 0;
-    }
-    state->how = COPY;
-    state->direct = 1;
-    return 0;
-}
-
-/* Decompress from input to the provided next_out and avail_out in the state.
-   On return, state->x.have and state->x.next point to the just decompressed
-   data.  If the gzip stream completes, state->how is reset to LOOK to look for
-   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
-   on success, -1 on failure. */
-local int gz_decomp(state)
-    gz_statep state;
-{
-    int ret = Z_OK;
-    unsigned had;
-    z_streamp strm = &(state->strm);
-
-    /* fill output buffer up to end of deflate stream */
-    had = strm->avail_out;
-    do {
-        /* get more input for inflate() */
-        if (strm->avail_in == 0 && gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0) {
-            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
-            break;
-        }
-
-        /* decompress and handle errors */
-        ret = inflate(strm, Z_NO_FLUSH);
-        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
-            gz_error(state, Z_STREAM_ERROR,
-                     "internal error: inflate stream corrupt");
-            return -1;
-        }
-        if (ret == Z_MEM_ERROR) {
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
-            gz_error(state, Z_DATA_ERROR,
-                     strm->msg == NULL ? "compressed data error" : strm->msg);
-            return -1;
-        }
-    } while (strm->avail_out && ret != Z_STREAM_END);
-
-    /* update available output */
-    state->x.have = had - strm->avail_out;
-    state->x.next = strm->next_out - state->x.have;
-
-    /* if the gzip stream completed successfully, look for another */
-    if (ret == Z_STREAM_END)
-        state->how = LOOK;
-
-    /* good decompression */
-    return 0;
-}
-
-/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
-   Data is either copied from the input file or decompressed from the input
-   file depending on state->how.  If state->how is LOOK, then a gzip header is
-   looked for to determine whether to copy or decompress.  Returns -1 on error,
-   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
-   end of the input file has been reached and all data has been processed.  */
-local int gz_fetch(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    do {
-        switch(state->how) {
-        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
-            if (gz_look(state) == -1)
-                return -1;
-            if (state->how == LOOK)
-                return 0;
-            break;
-        case COPY:      /* -> COPY */
-            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
-                    == -1)
-                return -1;
-            state->x.next = state->out;
-            return 0;
-        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
-            strm->avail_out = state->size << 1;
-            strm->next_out = state->out;
-            if (gz_decomp(state) == -1)
-                return -1;
-        }
-    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
-    return 0;
-}
-
-/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
-local int gz_skip(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    unsigned n;
-
-    /* skip over len bytes or reach end-of-file, whichever comes first */
-    while (len)
-        /* skip over whatever is in output buffer */
-        if (state->x.have) {
-            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
-                (unsigned)len : state->x.have;
-            state->x.have -= n;
-            state->x.next += n;
-            state->x.pos += n;
-            len -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0)
-            break;
-
-        /* need more data to skip -- load up output buffer */
-        else {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return -1;
-        }
-    return 0;
-}
-
-/* Read len bytes into buf from file, or less than len up to the end of the
-   input.  Return the number of bytes read.  If zero is returned, either the
-   end of file was reached, or there was an error.  state->err must be
-   consulted in that case to determine which. */
-local z_size_t gz_read(state, buf, len)
-    gz_statep state;
-    voidp buf;
-    z_size_t len;
-{
-    z_size_t got;
-    unsigned n;
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* get len bytes to buf, or less than len if at the end */
-    got = 0;
-    do {
-        /* set n to the maximum amount of len that fits in an unsigned int */
-        n = (unsigned)-1;
-        if (n > len)
-            n = (unsigned)len;
-
-        /* first just try copying data from the output buffer */
-        if (state->x.have) {
-            if (state->x.have < n)
-                n = state->x.have;
-            memcpy(buf, state->x.next, n);
-            state->x.next += n;
-            state->x.have -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0) {
-            state->past = 1;        /* tried to read past end */
-            break;
-        }
-
-        /* need output data -- for small len or new stream load up our output
-           buffer */
-        else if (state->how == LOOK || n < (state->size << 1)) {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return 0;
-            continue;       /* no progress yet -- go back to copy above */
-            /* the copy above assures that we will leave with space in the
-               output buffer, allowing at least one gzungetc() to succeed */
-        }
-
-        /* large len -- read directly into user buffer */
-        else if (state->how == COPY) {      /* read directly */
-            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)
-                return 0;
-        }
-
-        /* large len -- decompress directly into user buffer */
-        else {  /* state->how == GZIP */
-            state->strm.avail_out = n;
-            state->strm.next_out = (unsigned char *)buf;
-            if (gz_decomp(state) == -1)
-                return 0;
-            n = state->x.have;
-            state->x.have = 0;
-        }
-
-        /* update progress */
-        len -= n;
-        buf = (char *)buf + n;
-        got += n;
-        state->x.pos += n;
-    } while (len);
-
-    /* return number of bytes read into user buffer */
-    return got;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzread(file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids a flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
-        return -1;
-    }
-
-    /* read len or fewer bytes to buf */
-    len = (unsigned)gz_read(state, buf, len);
-
-    /* check for an error */
-    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-
-    /* return the number of bytes read (this is assured to fit in an int) */
-    return (int)len;
-}
-
-/* -- see zlib.h -- */
-z_size_t ZEXPORT gzfread(buf, size, nitems, file)
-    voidp buf;
-    z_size_t size;
-    z_size_t nitems;
-    gzFile file;
-{
-    z_size_t len;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return 0;
-
-    /* compute bytes to read -- error on overflow */
-    len = nitems * size;
-    if (size && len / size != nitems) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
-        return 0;
-    }
-
-    /* read len or fewer bytes to buf, return the number of full items read */
-    return len ? gz_read(state, buf, len) / size : 0;
-}
-
-/* -- see zlib.h -- */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#else
-#  undef gzgetc
-#endif
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    unsigned char buf[1];
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* try output buffer (no need to check for skip request) */
-    if (state->x.have) {
-        state->x.have--;
-        state->x.pos++;
-        return *(state->x.next)++;
-    }
-
-    /* nothing there -- try gz_read() */
-    return gz_read(state, buf, 1) < 1 ? -1 : buf[0];
-}
-
-int ZEXPORT gzgetc_(file)
-gzFile file;
-{
-    return gzgetc(file);
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* can't push EOF */
-    if (c < 0)
-        return -1;
-
-    /* if output buffer empty, put byte at end (allows more pushing) */
-    if (state->x.have == 0) {
-        state->x.have = 1;
-        state->x.next = state->out + (state->size << 1) - 1;
-        state->x.next[0] = (unsigned char)c;
-        state->x.pos--;
-        state->past = 0;
-        return c;
-    }
-
-    /* if no room, give up (must have already done a gzungetc()) */
-    if (state->x.have == (state->size << 1)) {
-        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
-        return -1;
-    }
-
-    /* slide output data if needed and insert byte before existing data */
-    if (state->x.next == state->out) {
-        unsigned char *src = state->out + state->x.have;
-        unsigned char *dest = state->out + (state->size << 1);
-        while (src > state->out)
-            *--dest = *--src;
-        state->x.next = dest;
-    }
-    state->x.have++;
-    state->x.next--;
-    state->x.next[0] = (unsigned char)c;
-    state->x.pos--;
-    state->past = 0;
-    return c;
-}
-
-/* -- see zlib.h -- */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    unsigned left, n;
-    char *str;
-    unsigned char *eol;
-    gz_statep state;
-
-    /* check parameters and get internal structure */
-    if (file == NULL || buf == NULL || len < 1)
-        return NULL;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return NULL;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return NULL;
-    }
-
-    /* copy output bytes up to new line or len - 1, whichever comes first --
-       append a terminating zero to the string (we don't check for a zero in
-       the contents, let the user worry about that) */
-    str = buf;
-    left = (unsigned)len - 1;
-    if (left) do {
-        /* assure that something is in the output buffer */
-        if (state->x.have == 0 && gz_fetch(state) == -1)
-            return NULL;                /* error */
-        if (state->x.have == 0) {       /* end of file */
-            state->past = 1;            /* read past end */
-            break;                      /* return what we have */
-        }
-
-        /* look for end-of-line in current output buffer */
-        n = state->x.have > left ? left : state->x.have;
-        eol = (unsigned char *)memchr(state->x.next, '\n', n);
-        if (eol != NULL)
-            n = (unsigned)(eol - state->x.next) + 1;
-
-        /* copy through end-of-line, or remainder if not found */
-        memcpy(buf, state->x.next, n);
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        left -= n;
-        buf += n;
-    } while (left && eol == NULL);
-
-    /* return terminated string, or if nothing, end of file */
-    if (buf == str)
-        return NULL;
-    buf[0] = 0;
-    return str;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzdirect(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* if the state is not known, but we can find out, then do so (this is
-       mainly for right after a gzopen() or gzdopen()) */
-    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
-        (void)gz_look(state);
-
-    /* return 1 if transparent, 0 if processing a gzip stream */
-    return state->direct;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_r(file)
-    gzFile file;
-{
-    int ret, err;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're reading */
-    if (state->mode != GZ_READ)
-        return Z_STREAM_ERROR;
-
-    /* free memory and close file */
-    if (state->size) {
-        inflateEnd(&(state->strm));
-        free(state->out);
-        free(state->in);
-    }
-    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    ret = close(state->fd);
-    free(state);
-    return ret ? Z_ERRNO : err;
-}
diff --git a/contrib/zlib/gzwrite.c b/contrib/zlib/gzwrite.c
deleted file mode 100644
index 3560193b8..000000000
--- a/contrib/zlib/gzwrite.c
+++ /dev/null
@@ -1,668 +0,0 @@
-/* gzwrite.c -- zlib functions for writing gzip files
- * Copyright (C) 2004-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_init OF((gz_statep));
-local int gz_comp OF((gz_statep, int));
-local int gz_zero OF((gz_statep, z_off64_t));
-local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));
-
-/* Initialize state for writing a gzip file.  Mark initialization by setting
-   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
-   success. */
-local int gz_init(state)
-    gz_statep state;
-{
-    int ret;
-    z_streamp strm = &(state->strm);
-
-    /* allocate input buffer (double size for gzprintf) */
-    state->in = (unsigned char *)malloc(state->want << 1);
-    if (state->in == NULL) {
-        gz_error(state, Z_MEM_ERROR, "out of memory");
-        return -1;
-    }
-
-    /* only need output buffer and deflate state if compressing */
-    if (!state->direct) {
-        /* allocate output buffer */
-        state->out = (unsigned char *)malloc(state->want);
-        if (state->out == NULL) {
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-
-        /* allocate deflate memory, set up for gzip compression */
-        strm->zalloc = Z_NULL;
-        strm->zfree = Z_NULL;
-        strm->opaque = Z_NULL;
-        ret = deflateInit2(strm, state->level, Z_DEFLATED,
-                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
-        if (ret != Z_OK) {
-            free(state->out);
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        strm->next_in = NULL;
-    }
-
-    /* mark state as initialized */
-    state->size = state->want;
-
-    /* initialize write buffer if compressing */
-    if (!state->direct) {
-        strm->avail_out = state->size;
-        strm->next_out = state->out;
-        state->x.next = strm->next_out;
-    }
-    return 0;
-}
-
-/* Compress whatever is at avail_in and next_in and write to the output file.
-   Return -1 if there is an error writing to the output file or if gz_init()
-   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
-   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
-   reset to start a new gzip stream.  If gz->direct is true, then simply write
-   to the output file without compressing, and ignore flush. */
-local int gz_comp(state, flush)
-    gz_statep state;
-    int flush;
-{
-    int ret, writ;
-    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
-    z_streamp strm = &(state->strm);
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return -1;
-
-    /* write directly if requested */
-    if (state->direct) {
-        while (strm->avail_in) {
-            put = strm->avail_in > max ? max : strm->avail_in;
-            writ = write(state->fd, strm->next_in, put);
-            if (writ < 0) {
-                gz_error(state, Z_ERRNO, zstrerror());
-                return -1;
-            }
-            strm->avail_in -= (unsigned)writ;
-            strm->next_in += writ;
-        }
-        return 0;
-    }
-
-    /* run deflate() on provided input until it produces no more output */
-    ret = Z_OK;
-    do {
-        /* write out current buffer contents if full, or if flushing, but if
-           doing Z_FINISH then don't write until we get to Z_STREAM_END */
-        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
-            (flush != Z_FINISH || ret == Z_STREAM_END))) {
-            while (strm->next_out > state->x.next) {
-                put = strm->next_out - state->x.next > (int)max ? max :
-                      (unsigned)(strm->next_out - state->x.next);
-                writ = write(state->fd, state->x.next, put);
-                if (writ < 0) {
-                    gz_error(state, Z_ERRNO, zstrerror());
-                    return -1;
-                }
-                state->x.next += writ;
-            }
-            if (strm->avail_out == 0) {
-                strm->avail_out = state->size;
-                strm->next_out = state->out;
-                state->x.next = state->out;
-            }
-        }
-
-        /* compress */
-        have = strm->avail_out;
-        ret = deflate(strm, flush);
-        if (ret == Z_STREAM_ERROR) {
-            gz_error(state, Z_STREAM_ERROR,
-                      "internal error: deflate stream corrupt");
-            return -1;
-        }
-        have -= strm->avail_out;
-    } while (have);
-
-    /* if that completed a deflate stream, allow another to start */
-    if (flush == Z_FINISH)
-        deflateReset(strm);
-
-    /* all done, no errors */
-    return 0;
-}
-
-/* Compress len zeros to output.  Return -1 on a write error or memory
-   allocation failure by gz_comp(), or 0 on success. */
-local int gz_zero(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    int first;
-    unsigned n;
-    z_streamp strm = &(state->strm);
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return -1;
-
-    /* compress len zeros (len guaranteed > 0) */
-    first = 1;
-    while (len) {
-        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
-            (unsigned)len : state->size;
-        if (first) {
-            memset(state->in, 0, n);
-            first = 0;
-        }
-        strm->avail_in = n;
-        strm->next_in = state->in;
-        state->x.pos += n;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return -1;
-        len -= n;
-    }
-    return 0;
-}
-
-/* Write len bytes from buf to file.  Return the number of bytes written.  If
-   the returned value is less than len, then there was an error. */
-local z_size_t gz_write(state, buf, len)
-    gz_statep state;
-    voidpc buf;
-    z_size_t len;
-{
-    z_size_t put = len;
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* for small len, copy to input buffer, otherwise compress directly */
-    if (len < state->size) {
-        /* copy to input buffer, compress when full */
-        do {
-            unsigned have, copy;
-
-            if (state->strm.avail_in == 0)
-                state->strm.next_in = state->in;
-            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
-                              state->in);
-            copy = state->size - have;
-            if (copy > len)
-                copy = (unsigned)len;
-            memcpy(state->in + have, buf, copy);
-            state->strm.avail_in += copy;
-            state->x.pos += copy;
-            buf = (const char *)buf + copy;
-            len -= copy;
-            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-        } while (len);
-    }
-    else {
-        /* consume whatever's left in the input buffer */
-        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-
-        /* directly compress user buffer to file */
-        state->strm.next_in = (z_const Bytef *)buf;
-        do {
-            unsigned n = (unsigned)-1;
-            if (n > len)
-                n = (unsigned)len;
-            state->strm.avail_in = n;
-            state->x.pos += n;
-            if (gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-            len -= n;
-        } while (len);
-    }
-
-    /* input was all buffered or compressed */
-    return put;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzwrite(file, buf, len)
-    gzFile file;
-    voidpc buf;
-    unsigned len;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids a flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
-        return 0;
-    }
-
-    /* write len bytes from buf (the return value will fit in an int) */
-    return (int)gz_write(state, buf, len);
-}
-
-/* -- see zlib.h -- */
-z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)
-    voidpc buf;
-    z_size_t size;
-    z_size_t nitems;
-    gzFile file;
-{
-    z_size_t len;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* compute bytes to read -- error on overflow */
-    len = nitems * size;
-    if (size && len / size != nitems) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
-        return 0;
-    }
-
-    /* write len bytes to buf, return the number of full items written */
-    return len ? gz_write(state, buf, len) / size : 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned have;
-    unsigned char buf[1];
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* try writing to input buffer for speed (state->size == 0 if buffer not
-       initialized) */
-    if (state->size) {
-        if (strm->avail_in == 0)
-            strm->next_in = state->in;
-        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
-        if (have < state->size) {
-            state->in[have] = (unsigned char)c;
-            strm->avail_in++;
-            state->x.pos++;
-            return c & 0xff;
-        }
-    }
-
-    /* no room in buffer or not initialized, use gz_write() */
-    buf[0] = (unsigned char)c;
-    if (gz_write(state, buf, 1) != 1)
-        return -1;
-    return c & 0xff;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputs(file, str)
-    gzFile file;
-    const char *str;
-{
-    z_size_t len, put;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-
-    /* write string */
-    len = strlen(str);
-    if ((int)len < 0 || (unsigned)len != len) {
-        gz_error(state, Z_STREAM_ERROR, "string length does not fit in int");
-        return -1;
-    }
-    put = gz_write(state, str, len);
-    return put < len ? -1 : (int)len;
-}
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#include <stdarg.h>
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
-{
-    int len;
-    unsigned left;
-    char *next;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return state->err;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-
-    /* do the printf() into the input buffer, put length in len -- the input
-       buffer is double-sized just for this function, so there is guaranteed to
-       be state->size bytes available after the current contents */
-    if (strm->avail_in == 0)
-        strm->next_in = state->in;
-    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
-    next[state->size - 1] = 0;
-#ifdef NO_vsnprintf
-#  ifdef HAS_vsprintf_void
-    (void)vsprintf(next, format, va);
-    for (len = 0; len < state->size; len++)
-        if (next[len] == 0) break;
-#  else
-    len = vsprintf(next, format, va);
-#  endif
-#else
-#  ifdef HAS_vsnprintf_void
-    (void)vsnprintf(next, state->size, format, va);
-    len = strlen(next);
-#  else
-    len = vsnprintf(next, state->size, format, va);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, compress first half if past that */
-    strm->avail_in += (unsigned)len;
-    state->x.pos += len;
-    if (strm->avail_in >= state->size) {
-        left = strm->avail_in - state->size;
-        strm->avail_in = state->size;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return state->err;
-        memcpy(state->in, state->in + state->size, left);
-        strm->next_in = state->in;
-        strm->avail_in = left;
-    }
-    return len;
-}
-
-int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
-{
-    va_list va;
-    int ret;
-
-    va_start(va, format);
-    ret = gzvprintf(file, format, va);
-    va_end(va);
-    return ret;
-}
-
-#else /* !STDC && !Z_HAVE_STDARG_H */
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    unsigned len, left;
-    char *next;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that can really pass pointer in ints */
-    if (sizeof(int) != sizeof(void *))
-        return Z_STREAM_ERROR;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return state->error;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->error;
-    }
-
-    /* do the printf() into the input buffer, put length in len -- the input
-       buffer is double-sized just for this function, so there is guaranteed to
-       be state->size bytes available after the current contents */
-    if (strm->avail_in == 0)
-        strm->next_in = state->in;
-    next = (char *)(strm->next_in + strm->avail_in);
-    next[state->size - 1] = 0;
-#ifdef NO_snprintf
-#  ifdef HAS_sprintf_void
-    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
-            a13, a14, a15, a16, a17, a18, a19, a20);
-    for (len = 0; len < size; len++)
-        if (next[len] == 0)
-            break;
-#  else
-    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
-                  a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#else
-#  ifdef HAS_snprintf_void
-    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
-             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    len = strlen(next);
-#  else
-    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
-                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len == 0 || len >= state->size || next[state->size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, compress first half if past that */
-    strm->avail_in += len;
-    state->x.pos += len;
-    if (strm->avail_in >= state->size) {
-        left = strm->avail_in - state->size;
-        strm->avail_in = state->size;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return state->err;
-        memcpy(state->in, state->in + state->size, left);
-        strm->next_in = state->in;
-        strm->avail_in = left;
-    }
-    return (int)len;
-}
-
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzflush(file, flush)
-    gzFile file;
-    int flush;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* check flush parameter */
-    if (flush < 0 || flush > Z_FINISH)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-
-    /* compress remaining data with requested flush */
-    (void)gz_comp(state, flush);
-    return state->err;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzsetparams(file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* if no change is requested, then do nothing */
-    if (level == state->level && strategy == state->strategy)
-        return Z_OK;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-
-    /* change compression parameters for subsequent input */
-    if (state->size) {
-        /* flush previous input with previous parameters before changing */
-        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
-            return state->err;
-        deflateParams(strm, level, strategy);
-    }
-    state->level = level;
-    state->strategy = strategy;
-    return Z_OK;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_w(file)
-    gzFile file;
-{
-    int ret = Z_OK;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're writing */
-    if (state->mode != GZ_WRITE)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            ret = state->err;
-    }
-
-    /* flush, free memory, and close file */
-    if (gz_comp(state, Z_FINISH) == -1)
-        ret = state->err;
-    if (state->size) {
-        if (!state->direct) {
-            (void)deflateEnd(&(state->strm));
-            free(state->out);
-        }
-        free(state->in);
-    }
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    if (close(state->fd) == -1)
-        ret = Z_ERRNO;
-    free(state);
-    return ret;
-}
diff --git a/contrib/zlib/infback.c b/contrib/zlib/infback.c
deleted file mode 100644
index 59679ecbf..000000000
--- a/contrib/zlib/infback.c
+++ /dev/null
@@ -1,640 +0,0 @@
-/* infback.c -- inflate using a call-back interface
- * Copyright (C) 1995-2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
-   This code is largely copied from inflate.c.  Normally either infback.o or
-   inflate.o would be linked into an application--not both.  The interface
-   with inffast.c is retained so that optimized assembler-coded versions of
-   inflate_fast() can be used with either inflate.c or infback.c.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   windowBits is in the range 8..15, and window is a user-supplied
-   window and output buffer that is 2**windowBits bytes.
- */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_streamp strm;
-int windowBits;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
-        windowBits < 8 || windowBits > 15)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-    strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->dmax = 32768U;
-    state->wbits = (uInt)windowBits;
-    state->wsize = 1U << windowBits;
-    state->window = window;
-    state->wnext = 0;
-    state->whave = 0;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-/* Macros for inflateBack(): */
-
-/* Load returned state from inflate_fast() */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Set state from registers for inflate_fast() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = state->window; \
-            left = state->wsize; \
-            state->whave = left; \
-            if (out(out_desc, put, left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_streamp strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    state->mode = TYPE;
-    state->last = 0;
-    state->whave = 0;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = state->window;
-    left = state->wsize;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (state->mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (state->last) {
-                BYTEBITS();
-                state->mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (state->length != 0) {
-                copy = state->length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-
-        case LEN:
-            /* use inflate_fast() if we have enough input and output */
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                if (state->whave < state->wsize)
-                    state->whave = state->wsize - left;
-                inflate_fast(strm, state->wsize);
-                LOAD();
-                break;
-            }
-
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            state->length = (unsigned)here.val;
-
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(state->length);
-                left--;
-                state->mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-
-            /* get distance code */
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-
-            /* get distance extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            if (state->offset > state->wsize - (state->whave < state->wsize ?
-                                                left : 0)) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = state->wsize - state->offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - state->offset;
-                    copy = left;
-                }
-                if (copy > state->length) copy = state->length;
-                state->length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (state->length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < state->wsize) {
-                if (out(out_desc, state->window, state->wsize - left))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBackEnd(strm)
-z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff --git a/contrib/zlib/inffast.c b/contrib/zlib/inffast.c
deleted file mode 100644
index 1fec7f363..000000000
--- a/contrib/zlib/inffast.c
+++ /dev/null
@@ -1,323 +0,0 @@
-/* inffast.c -- fast decoding
- * Copyright (C) 1995-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifdef ASMINF
-#  pragma message("Assembler code may have bugs -- use at your own risk")
-#else
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void ZLIB_INTERNAL inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *in;      /* local strm->next_in */
-    z_const unsigned char FAR *last;    /* have enough input while in < last */
-    unsigned char FAR *out;     /* local strm->next_out */
-    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
-    unsigned char FAR *end;     /* while out < end, enough space available */
-#ifdef INFLATE_STRICT
-    unsigned dmax;              /* maximum distance from zlib header */
-#endif
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
-    unsigned bits;              /* local strm->bits */
-    code const FAR *lcode;      /* local strm->lencode */
-    code const FAR *dcode;      /* local strm->distcode */
-    unsigned lmask;             /* mask for first level of length codes */
-    unsigned dmask;             /* mask for first level of distance codes */
-    code const *here;           /* retrieved table entry */
-    unsigned op;                /* code bits, operation, extra bits, or */
-                                /*  window position, window bytes to copy */
-    unsigned len;               /* match length, unused bytes */
-    unsigned dist;              /* match distance */
-    unsigned char FAR *from;    /* where to copy match from */
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    in = strm->next_in;
-    last = in + (strm->avail_in - 5);
-    out = strm->next_out;
-    beg = out - (start - strm->avail_out);
-    end = out + (strm->avail_out - 257);
-#ifdef INFLATE_STRICT
-    dmax = state->dmax;
-#endif
-    wsize = state->wsize;
-    whave = state->whave;
-    wnext = state->wnext;
-    window = state->window;
-    hold = state->hold;
-    bits = state->bits;
-    lcode = state->lencode;
-    dcode = state->distcode;
-    lmask = (1U << state->lenbits) - 1;
-    dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-    do {
-        if (bits < 15) {
-            hold += (unsigned long)(*in++) << bits;
-            bits += 8;
-            hold += (unsigned long)(*in++) << bits;
-            bits += 8;
-        }
-        here = lcode + (hold & lmask);
-      dolen:
-        op = (unsigned)(here->bits);
-        hold >>= op;
-        bits -= op;
-        op = (unsigned)(here->op);
-        if (op == 0) {                          /* literal */
-            Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?
-                    "inflate:         literal '%c'\n" :
-                    "inflate:         literal 0x%02x\n", here->val));
-            *out++ = (unsigned char)(here->val);
-        }
-        else if (op & 16) {                     /* length base */
-            len = (unsigned)(here->val);
-            op &= 15;                           /* number of extra bits */
-            if (op) {
-                if (bits < op) {
-                    hold += (unsigned long)(*in++) << bits;
-                    bits += 8;
-                }
-                len += (unsigned)hold & ((1U << op) - 1);
-                hold >>= op;
-                bits -= op;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", len));
-            if (bits < 15) {
-                hold += (unsigned long)(*in++) << bits;
-                bits += 8;
-                hold += (unsigned long)(*in++) << bits;
-                bits += 8;
-            }
-            here = dcode + (hold & dmask);
-          dodist:
-            op = (unsigned)(here->bits);
-            hold >>= op;
-            bits -= op;
-            op = (unsigned)(here->op);
-            if (op & 16) {                      /* distance base */
-                dist = (unsigned)(here->val);
-                op &= 15;                       /* number of extra bits */
-                if (bits < op) {
-                    hold += (unsigned long)(*in++) << bits;
-                    bits += 8;
-                    if (bits < op) {
-                        hold += (unsigned long)(*in++) << bits;
-                        bits += 8;
-                    }
-                }
-                dist += (unsigned)hold & ((1U << op) - 1);
-#ifdef INFLATE_STRICT
-                if (dist > dmax) {
-                    strm->msg = (char *)"invalid distance too far back";
-                    state->mode = BAD;
-                    break;
-                }
-#endif
-                hold >>= op;
-                bits -= op;
-                Tracevv((stderr, "inflate:         distance %u\n", dist));
-                op = (unsigned)(out - beg);     /* max distance in output */
-                if (dist > op) {                /* see if copy from window */
-                    op = dist - op;             /* distance back in window */
-                    if (op > whave) {
-                        if (state->sane) {
-                            strm->msg =
-                                (char *)"invalid distance too far back";
-                            state->mode = BAD;
-                            break;
-                        }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        if (len <= op - whave) {
-                            do {
-                                *out++ = 0;
-                            } while (--len);
-                            continue;
-                        }
-                        len -= op - whave;
-                        do {
-                            *out++ = 0;
-                        } while (--op > whave);
-                        if (op == 0) {
-                            from = out - dist;
-                            do {
-                                *out++ = *from++;
-                            } while (--len);
-                            continue;
-                        }
-#endif
-                    }
-                    from = window;
-                    if (wnext == 0) {           /* very common case */
-                        from += wsize - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                *out++ = *from++;
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    else if (wnext < op) {      /* wrap around window */
-                        from += wsize + wnext - op;
-                        op -= wnext;
-                        if (op < len) {         /* some from end of window */
-                            len -= op;
-                            do {
-                                *out++ = *from++;
-                            } while (--op);
-                            from = window;
-                            if (wnext < len) {  /* some from start of window */
-                                op = wnext;
-                                len -= op;
-                                do {
-                                    *out++ = *from++;
-                                } while (--op);
-                                from = out - dist;      /* rest from output */
-                            }
-                        }
-                    }
-                    else {                      /* contiguous in window */
-                        from += wnext - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                *out++ = *from++;
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    while (len > 2) {
-                        *out++ = *from++;
-                        *out++ = *from++;
-                        *out++ = *from++;
-                        len -= 3;
-                    }
-                    if (len) {
-                        *out++ = *from++;
-                        if (len > 1)
-                            *out++ = *from++;
-                    }
-                }
-                else {
-                    from = out - dist;          /* copy direct from output */
-                    do {                        /* minimum length is three */
-                        *out++ = *from++;
-                        *out++ = *from++;
-                        *out++ = *from++;
-                        len -= 3;
-                    } while (len > 2);
-                    if (len) {
-                        *out++ = *from++;
-                        if (len > 1)
-                            *out++ = *from++;
-                    }
-                }
-            }
-            else if ((op & 64) == 0) {          /* 2nd level distance code */
-                here = dcode + here->val + (hold & ((1U << op) - 1));
-                goto dodist;
-            }
-            else {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-        }
-        else if ((op & 64) == 0) {              /* 2nd level length code */
-            here = lcode + here->val + (hold & ((1U << op) - 1));
-            goto dolen;
-        }
-        else if (op & 32) {                     /* end-of-block */
-            Tracevv((stderr, "inflate:         end of block\n"));
-            state->mode = TYPE;
-            break;
-        }
-        else {
-            strm->msg = (char *)"invalid literal/length code";
-            state->mode = BAD;
-            break;
-        }
-    } while (in < last && out < end);
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    len = bits >> 3;
-    in -= len;
-    bits -= len << 3;
-    hold &= (1U << bits) - 1;
-
-    /* update state and return */
-    strm->next_in = in;
-    strm->next_out = out;
-    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
-    strm->avail_out = (unsigned)(out < end ?
-                                 257 + (end - out) : 257 - (out - end));
-    state->hold = hold;
-    state->bits = bits;
-    return;
-}
-
-/*
-   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
-   - Using bit fields for code structure
-   - Different op definition to avoid & for extra bits (do & for table bits)
-   - Three separate decoding do-loops for direct, window, and wnext == 0
-   - Special case for distance > 1 copies to do overlapped load and store copy
-   - Explicit branch predictions (based on measured branch probabilities)
-   - Deferring match copy and interspersed it with decoding subsequent codes
-   - Swapping literal/length else
-   - Swapping window/direct else
-   - Larger unrolled copy loops (three is about right)
-   - Moving len -= 3 statement into middle of loop
- */
-
-#endif /* !ASMINF */
diff --git a/contrib/zlib/inffast.h b/contrib/zlib/inffast.h
deleted file mode 100644
index e5c1aa4ca..000000000
--- a/contrib/zlib/inffast.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));
diff --git a/contrib/zlib/inffixed.h b/contrib/zlib/inffixed.h
deleted file mode 100644
index d62832776..000000000
--- a/contrib/zlib/inffixed.h
+++ /dev/null
@@ -1,94 +0,0 @@
-    /* inffixed.h -- table for decoding fixed codes
-     * Generated automatically by makefixed().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
-        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
-        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
-        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
-        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
-        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
-        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
-        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
-        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
-        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
-        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
-        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
-        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
-        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
-        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
-        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
-        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
-        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
-        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
-        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
-        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
-        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
-        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
-        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
-        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
-        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
-        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
-        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
-        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
-        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
-        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
-        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
-        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
-        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
-        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
-        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
-        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
-        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
-        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
-        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
-        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
-        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
-        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
-        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
-        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
-        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
-        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
-        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
-        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
-        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
-        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
-        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
-        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
-        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
-        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
-        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
-        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
-        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
-        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
-        {0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
-        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
-        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
-        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
-        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
-        {22,5,193},{64,5,0}
-    };
diff --git a/contrib/zlib/inflate.c b/contrib/zlib/inflate.c
deleted file mode 100644
index 575fcdf82..000000000
--- a/contrib/zlib/inflate.c
+++ /dev/null
@@ -1,1563 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common wnext == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-
-/* function prototypes */
-local int inflateStateCheck OF((z_streamp strm));
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
-                           unsigned copy));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
-                              unsigned len));
-
-local int inflateStateCheck(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state == Z_NULL || state->strm != strm ||
-        state->mode < HEAD || state->mode > SYNC)
-        return 1;
-    return 0;
-}
-
-int ZEXPORT inflateResetKeep(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    if (state->wrap)        /* to support ill-conceived Java test suite */
-        strm->adler = state->wrap & 1;
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    state->sane = 1;
-    state->back = -1;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->wsize = 0;
-    state->whave = 0;
-    state->wnext = 0;
-    return inflateResetKeep(strm);
-}
-
-int ZEXPORT inflateReset2(strm, windowBits)
-z_streamp strm;
-int windowBits;
-{
-    int wrap;
-    struct inflate_state FAR *state;
-
-    /* get the state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* extract wrap request from windowBits parameter */
-    if (windowBits < 0) {
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        wrap = (windowBits >> 4) + 5;
-#ifdef GUNZIP
-        if (windowBits < 48)
-            windowBits &= 15;
-#endif
-    }
-
-    /* set number of window bits, free window if different */
-    if (windowBits && (windowBits < 8 || windowBits > 15))
-        return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
-    }
-
-    /* update state and reset the rest of it */
-    state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
-}
-
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    int ret;
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->strm = strm;
-    state->window = Z_NULL;
-    state->mode = HEAD;     /* to pass state test in inflateReset2() */
-    ret = inflateReset2(strm, windowBits);
-    if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-    }
-    return ret;
-}
-
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits < 0) {
-        state->hold = 0;
-        state->bits = 0;
-        return Z_OK;
-    }
-    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += (unsigned)value << state->bits;
-    state->bits += (uInt)bits;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-
-    void makefixed(void);
-
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
-               state.lencode[low].bits, state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, end, copy)
-z_streamp strm;
-const Bytef *end;
-unsigned copy;
-{
-    struct inflate_state FAR *state;
-    unsigned dist;
-
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->wnext = 0;
-        state->whave = 0;
-    }
-
-    /* copy state->wsize or less output bytes into the circular window */
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, end - state->wsize, state->wsize);
-        state->wnext = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->wnext;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->wnext, end - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, end - copy, copy);
-            state->wnext = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->wnext += dist;
-            if (state->wnext == state->wsize) state->wnext = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-
-/* Macros for inflate(): */
-
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE(check, buf, len) adler32(check, buf, len)
-#endif
-
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                if (state->wbits == 0)
-                    state->wbits = 15;
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            state->flags = 0;           /* expect zlib header */
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (state->wbits == 0)
-                state->wbits = len;
-            if (len > 15 || len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            state->dmax = 1U << len;
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if ((state->flags & 0x0200) && (state->wrap & 4))
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = ZSWAP32(hold);
-            INITBITS();
-            state->mode = DICT;
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-        case TYPE:
-            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN_;             /* decode codes */
-                if (flush == Z_TREES) {
-                    DROPBITS(2);
-                    goto inf_leave;
-                }
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY_;
-            if (flush == Z_TREES) goto inf_leave;
-        case COPY_:
-            state->mode = COPY;
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (const code FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN_;
-            if (flush == Z_TREES) goto inf_leave;
-        case LEN_:
-            state->mode = LEN;
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            state->length = (unsigned)here.val;
-            if ((int)(here.op) == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                state->mode = LIT;
-                break;
-            }
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->back = -1;
-                state->mode = TYPE;
-                break;
-            }
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = LENEXT;
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->was = state->length;
-            state->mode = DIST;
-        case DIST:
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = DISTEXT;
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-        case MATCH:
-            if (left == 0) goto inf_leave;
-            copy = out - left;
-            if (state->offset > copy) {         /* copy from window */
-                copy = state->offset - copy;
-                if (copy > state->whave) {
-                    if (state->sane) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                    Trace((stderr, "inflate.c too far\n"));
-                    copy -= state->whave;
-                    if (copy > state->length) copy = state->length;
-                    if (copy > left) copy = left;
-                    left -= copy;
-                    state->length -= copy;
-                    do {
-                        *put++ = 0;
-                    } while (--copy);
-                    if (state->length == 0) state->mode = LEN;
-                    break;
-#endif
-                }
-                if (copy > state->wnext) {
-                    copy -= state->wnext;
-                    from = state->window + (state->wsize - copy);
-                }
-                else
-                    from = state->window + (state->wnext - copy);
-                if (copy > state->length) copy = state->length;
-            }
-            else {                              /* copy from output */
-                from = put - state->offset;
-                copy = state->length;
-            }
-            if (copy > left) copy = left;
-            left -= copy;
-            state->length -= copy;
-            do {
-                *put++ = *from++;
-            } while (--copy);
-            if (state->length == 0) state->mode = LEN;
-            break;
-        case LIT:
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            left--;
-            state->mode = LEN;
-            break;
-        case CHECK:
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                if ((state->wrap & 4) && out)
-                    strm->adler = state->check =
-                        UPDATE(state->check, put - out, out);
-                out = left;
-                if ((state->wrap & 4) && (
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     ZSWAP32(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if (hold != (state->total & 0xffffffffUL)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-        default:
-            return Z_STREAM_ERROR;
-        }
-
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
-            (state->mode < CHECK || flush != Z_FINISH)))
-        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
-            state->mode = MEM;
-            return Z_MEM_ERROR;
-        }
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    if ((state->wrap & 4) && out)
-        strm->adler = state->check =
-            UPDATE(state->check, strm->next_out - out, out);
-    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0) +
-                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-Bytef *dictionary;
-uInt *dictLength;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* copy dictionary */
-    if (state->whave && dictionary != Z_NULL) {
-        zmemcpy(dictionary, state->window + state->wnext,
-                state->whave - state->wnext);
-        zmemcpy(dictionary + state->whave - state->wnext,
-                state->window, state->wnext);
-    }
-    if (dictLength != Z_NULL)
-        *dictLength = state->whave;
-    return Z_OK;
-}
-
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long dictid;
-    int ret;
-
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-
-    /* check for correct dictionary identifier */
-    if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
-        dictid = adler32(dictid, dictionary, dictLength);
-        if (dictid != state->check)
-            return Z_DATA_ERROR;
-    }
-
-    /* copy dictionary to window using updatewindow(), which will amend the
-       existing dictionary if appropriate */
-    ret = updatewindow(strm, dictionary + dictLength, dictLength);
-    if (ret) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
-    }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-const unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-
-    /* check parameters */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    if (state->mode == HEAD)
-        state->wrap = 0;    /* never processed header, so assume raw */
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->mode = TYPE;
-    return Z_OK;
-}
-
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize;
-
-    /* check input */
-    if (inflateStateCheck(source) || dest == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        window = (unsigned char FAR *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-
-    /* copy state */
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
-    copy->strm = dest;
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        wsize = 1U << state->wbits;
-        zmemcpy(window, state->window, wsize);
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
-
-int ZEXPORT inflateUndermine(strm, subvert)
-z_streamp strm;
-int subvert;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    state->sane = !subvert;
-    return Z_OK;
-#else
-    (void)subvert;
-    state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
-}
-
-int ZEXPORT inflateValidate(strm, check)
-z_streamp strm;
-int check;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (check && state->wrap)
-        state->wrap |= 4;
-    else
-        state->wrap &= ~4;
-    return Z_OK;
-}
-
-long ZEXPORT inflateMark(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (inflateStateCheck(strm))
-        return -(1L << 16);
-    state = (struct inflate_state FAR *)strm->state;
-    return (long)(((unsigned long)((long)state->back)) << 16) +
-        (state->mode == COPY ? state->length :
-            (state->mode == MATCH ? state->was - state->length : 0));
-}
-
-unsigned long ZEXPORT inflateCodesUsed(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return (unsigned long)-1;
-    state = (struct inflate_state FAR *)strm->state;
-    return (unsigned long)(state->next - state->codes);
-}
diff --git a/contrib/zlib/inflate.h b/contrib/zlib/inflate.h
deleted file mode 100644
index a46cce6b6..000000000
--- a/contrib/zlib/inflate.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD = 16180,   /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY_,      /* i/o: same as COPY below, but only first time in */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN_,       /* i: same as LEN below, but only first time in */
-            LEN,        /* i: waiting for length/lit/eob code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to BAD or MEM on error -- not shown for clarity)
-
-    Process header:
-        HEAD -> (gzip) or (zlib) or (raw)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
-                  HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-        (raw) -> TYPEDO
-    Read deflate blocks:
-            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
-            STORED -> COPY_ -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN_
-            LEN_ -> LEN
-    Read deflate codes in fixed or dynamic block:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-
-/* State maintained between inflate() calls -- approximately 7K bytes, not
-   including the allocated sliding window, which is up to 32K bytes. */
-struct inflate_state {
-    z_streamp strm;             /* pointer back to this zlib stream */
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,
-                                   bit 2 true to validate check value */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-    int sane;                   /* if false, allow invalid distance too far */
-    int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
-};
diff --git a/contrib/zlib/inftrees.c b/contrib/zlib/inftrees.c
deleted file mode 100644
index 716c98842..000000000
--- a/contrib/zlib/inftrees.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-
-#define MAXBITS 15
-
-const char inflate_copyright[] =
-   " inflate 1.2.11.1 Copyright 1995-2017 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code here;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    unsigned match;             /* use base and extra for symbol >= match */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 198, 196};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        here.op = (unsigned char)64;    /* invalid code marker */
-        here.bits = (unsigned char)1;
-        here.val = (unsigned short)0;
-        *(*table)++ = here;             /* make a table to force an error */
-        *(*table)++ = here;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min < max; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftrees.h
-       for more information.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        match = 20;
-        break;
-    case LENS:
-        base = lbase;
-        extra = lext;
-        match = 257;
-        break;
-    default:    /* DISTS */
-        base = dbase;
-        extra = dext;
-        match = 0;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if ((type == LENS && used > ENOUGH_LENS) ||
-        (type == DISTS && used > ENOUGH_DISTS))
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        here.bits = (unsigned char)(len - drop);
-        if (work[sym] + 1U < match) {
-            here.op = (unsigned char)0;
-            here.val = work[sym];
-        }
-        else if (work[sym] >= match) {
-            here.op = (unsigned char)(extra[work[sym] - match]);
-            here.val = base[work[sym] - match];
-        }
-        else {
-            here.op = (unsigned char)(32 + 64);         /* end of block */
-            here.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = here;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used > ENOUGH_LENS) ||
-                (type == DISTS && used > ENOUGH_DISTS))
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /* fill in remaining table entry if code is incomplete (guaranteed to have
-       at most one remaining entry, since if the code is incomplete, the
-       maximum code length that was allowed to get this far is one bit) */
-    if (huff != 0) {
-        here.op = (unsigned char)64;            /* invalid code marker */
-        here.bits = (unsigned char)(len - drop);
-        here.val = (unsigned short)0;
-        next[huff] = here;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff --git a/contrib/zlib/inftrees.h b/contrib/zlib/inftrees.h
deleted file mode 100644
index baa53a0b1..000000000
--- a/contrib/zlib/inftrees.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff --git a/contrib/zlib/trees.c b/contrib/zlib/trees.c
deleted file mode 100644
index 50cf4b457..000000000
--- a/contrib/zlib/trees.c
+++ /dev/null
@@ -1,1203 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2017 Jean-loup Gailly
- * detect_data_type() function provided freely by Cosmin Truta, 2006
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* @(#) $Id$ */
-
-/* #define GEN_TREES_H */
-
-#include "deflate.h"
-
-#ifdef ZLIB_DEBUG
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local const static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local const static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local const static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, const ct_data *ltree,
-                              const ct_data *dtree));
-local int  detect_data_type OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-
-#ifndef ZLIB_DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* !ZLIB_DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef ZLIB_DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !ZLIB_DEBUG */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = (int)value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* ZLIB_DEBUG */
-
-
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef ZLIB_DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void ZLIB_INTERNAL _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
-        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Tracev((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    unsigned code = 0;         /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        code = (code + bl_count[bits-1]) << 1;
-        next_code[bits] = (ush)code;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
-    bi_windup(s);        /* align on byte boundary */
-    put_short(s, (ush)stored_len);
-    put_short(s, (ush)~stored_len);
-    zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
-    s->pending += stored_len;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-    s->bits_sent += 2*16;
-    s->bits_sent += stored_len<<3;
-#endif
-}
-
-/* ===========================================================================
- * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
- */
-void ZLIB_INTERNAL _tr_flush_bits(s)
-    deflate_state *s;
-{
-    bi_flush(s);
-}
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- */
-void ZLIB_INTERNAL _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef ZLIB_DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and write out the encoded block.
- */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-        /* Check if the file is binary or text */
-        if (s->strm->data_type == Z_UNKNOWN)
-            s->strm->data_type = detect_data_type(s);
-
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len+3+7)>>3;
-        static_lenb = (s->static_len+3+7)>>3;
-
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->last_lit));
-
-        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, last);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+last, 3);
-        compress_block(s, (const ct_data *)static_ltree,
-                       (const ct_data *)static_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1)+last, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (const ct_data *)s->dyn_ltree,
-                       (const ct_data *)s->dyn_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-
-    if (last) {
-        bi_windup(s);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*last));
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int ZLIB_INTERNAL _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-#ifdef TRUNCATE_BLOCK
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-#endif
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    const ct_data *ltree; /* literal tree */
-    const ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= (unsigned)base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
-               "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-}
-
-/* ===========================================================================
- * Check if the data type is TEXT or BINARY, using the following algorithm:
- * - TEXT if the two conditions below are satisfied:
- *    a) There are no non-portable control characters belonging to the
- *       "black list" (0..6, 14..25, 28..31).
- *    b) There is at least one printable character belonging to the
- *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
- * - BINARY otherwise.
- * - The following partially-portable control characters form a
- *   "gray list" that is ignored in this detection algorithm:
- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local int detect_data_type(s)
-    deflate_state *s;
-{
-    /* black_mask is the bit mask of black-listed bytes
-     * set bits 0..6, 14..25, and 28..31
-     * 0xf3ffc07f = binary 11110011111111111100000001111111
-     */
-    unsigned long black_mask = 0xf3ffc07fUL;
-    int n;
-
-    /* Check for non-textual ("black-listed") bytes. */
-    for (n = 0; n <= 31; n++, black_mask >>= 1)
-        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
-            return Z_BINARY;
-
-    /* Check for textual ("white-listed") bytes. */
-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
-            || s->dyn_ltree[13].Freq != 0)
-        return Z_TEXT;
-    for (n = 32; n < LITERALS; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            return Z_TEXT;
-
-    /* There are no "black-listed" or "white-listed" bytes:
-     * this stream either is empty or has tolerated ("gray-listed") bytes only.
-     */
-    return Z_BINARY;
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
diff --git a/contrib/zlib/trees.h b/contrib/zlib/trees.h
deleted file mode 100644
index d35639d82..000000000
--- a/contrib/zlib/trees.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
-
diff --git a/contrib/zlib/uncompr.c b/contrib/zlib/uncompr.c
deleted file mode 100644
index f03a1a865..000000000
--- a/contrib/zlib/uncompr.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/* uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  *sourceLen is
-   the byte length of the source buffer. Upon entry, *destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data. (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit,
-   *destLen is the size of the decompressed data and *sourceLen is the number
-   of source bytes consumed. Upon return, source + *sourceLen points to the
-   first unused input byte.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
-   Z_DATA_ERROR if the input data was corrupted, including if the input data is
-   an incomplete zlib stream.
-*/
-int ZEXPORT uncompress2 (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong *sourceLen;
-{
-    z_stream stream;
-    int err;
-    const uInt max = (uInt)-1;
-    uLong len, left;
-    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
-
-    len = *sourceLen;
-    if (*destLen) {
-        left = *destLen;
-        *destLen = 0;
-    }
-    else {
-        left = 1;
-        dest = buf;
-    }
-
-    stream.next_in = (z_const Bytef *)source;
-    stream.avail_in = 0;
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-
-    stream.next_out = dest;
-    stream.avail_out = 0;
-
-    do {
-        if (stream.avail_out == 0) {
-            stream.avail_out = left > (uLong)max ? max : (uInt)left;
-            left -= stream.avail_out;
-        }
-        if (stream.avail_in == 0) {
-            stream.avail_in = len > (uLong)max ? max : (uInt)len;
-            len -= stream.avail_in;
-        }
-        err = inflate(&stream, Z_NO_FLUSH);
-    } while (err == Z_OK);
-
-    *sourceLen -= len + stream.avail_in;
-    if (dest != buf)
-        *destLen = stream.total_out;
-    else if (stream.total_out && err == Z_BUF_ERROR)
-        left = 1;
-
-    inflateEnd(&stream);
-    return err == Z_STREAM_END ? Z_OK :
-           err == Z_NEED_DICT ? Z_DATA_ERROR  :
-           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
-           err;
-}
-
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return uncompress2(dest, destLen, source, &sourceLen);
-}
diff --git a/contrib/zlib/win32/DLL_FAQ.txt b/contrib/zlib/win32/DLL_FAQ.txt
deleted file mode 100644
index 12c009018..000000000
--- a/contrib/zlib/win32/DLL_FAQ.txt
+++ /dev/null
@@ -1,397 +0,0 @@
-
-            Frequently Asked Questions about ZLIB1.DLL
-
-
-This document describes the design, the rationale, and the usage
-of the official DLL build of zlib, named ZLIB1.DLL.  If you have
-general questions about zlib, you should see the file "FAQ" found
-in the zlib distribution, or at the following location:
-  http://www.gzip.org/zlib/zlib_faq.html
-
-
- 1. What is ZLIB1.DLL, and how can I get it?
-
-  - ZLIB1.DLL is the official build of zlib as a DLL.
-    (Please remark the character '1' in the name.)
-
-    Pointers to a precompiled ZLIB1.DLL can be found in the zlib
-    web site at:
-      http://www.zlib.net/
-
-    Applications that link to ZLIB1.DLL can rely on the following
-    specification:
-
-    * The exported symbols are exclusively defined in the source
-      files "zlib.h" and "zlib.def", found in an official zlib
-      source distribution.
-    * The symbols are exported by name, not by ordinal.
-    * The exported names are undecorated.
-    * The calling convention of functions is "C" (CDECL).
-    * The ZLIB1.DLL binary is linked to MSVCRT.DLL.
-
-    The archive in which ZLIB1.DLL is bundled contains compiled
-    test programs that must run with a valid build of ZLIB1.DLL.
-    It is recommended to download the prebuilt DLL from the zlib
-    web site, instead of building it yourself, to avoid potential
-    incompatibilities that could be introduced by your compiler
-    and build settings.  If you do build the DLL yourself, please
-    make sure that it complies with all the above requirements,
-    and it runs with the precompiled test programs, bundled with
-    the original ZLIB1.DLL distribution.
-
-    If, for any reason, you need to build an incompatible DLL,
-    please use a different file name.
-
-
- 2. Why did you change the name of the DLL to ZLIB1.DLL?
-    What happened to the old ZLIB.DLL?
-
-  - The old ZLIB.DLL, built from zlib-1.1.4 or earlier, required
-    compilation settings that were incompatible to those used by
-    a static build.  The DLL settings were supposed to be enabled
-    by defining the macro ZLIB_DLL, before including "zlib.h".
-    Incorrect handling of this macro was silently accepted at
-    build time, resulting in two major problems:
-
-    * ZLIB_DLL was missing from the old makefile.  When building
-      the DLL, not all people added it to the build options.  In
-      consequence, incompatible incarnations of ZLIB.DLL started
-      to circulate around the net.
-
-    * When switching from using the static library to using the
-      DLL, applications had to define the ZLIB_DLL macro and
-      to recompile all the sources that contained calls to zlib
-      functions.  Failure to do so resulted in creating binaries
-      that were unable to run with the official ZLIB.DLL build.
-
-    The only possible solution that we could foresee was to make
-    a binary-incompatible change in the DLL interface, in order to
-    remove the dependency on the ZLIB_DLL macro, and to release
-    the new DLL under a different name.
-
-    We chose the name ZLIB1.DLL, where '1' indicates the major
-    zlib version number.  We hope that we will not have to break
-    the binary compatibility again, at least not as long as the
-    zlib-1.x series will last.
-
-    There is still a ZLIB_DLL macro, that can trigger a more
-    efficient build and use of the DLL, but compatibility no
-    longer dependents on it.
-
-
- 3. Can I build ZLIB.DLL from the new zlib sources, and replace
-    an old ZLIB.DLL, that was built from zlib-1.1.4 or earlier?
-
-  - In principle, you can do it by assigning calling convention
-    keywords to the macros ZEXPORT and ZEXPORTVA.  In practice,
-    it depends on what you mean by "an old ZLIB.DLL", because the
-    old DLL exists in several mutually-incompatible versions.
-    You have to find out first what kind of calling convention is
-    being used in your particular ZLIB.DLL build, and to use the
-    same one in the new build.  If you don't know what this is all
-    about, you might be better off if you would just leave the old
-    DLL intact.
-
-
- 4. Can I compile my application using the new zlib interface, and
-    link it to an old ZLIB.DLL, that was built from zlib-1.1.4 or
-    earlier?
-
-  - The official answer is "no"; the real answer depends again on
-    what kind of ZLIB.DLL you have.  Even if you are lucky, this
-    course of action is unreliable.
-
-    If you rebuild your application and you intend to use a newer
-    version of zlib (post- 1.1.4), it is strongly recommended to
-    link it to the new ZLIB1.DLL.
-
-
- 5. Why are the zlib symbols exported by name, and not by ordinal?
-
-  - Although exporting symbols by ordinal is a little faster, it
-    is risky.  Any single glitch in the maintenance or use of the
-    DEF file that contains the ordinals can result in incompatible
-    builds and frustrating crashes.  Simply put, the benefits of
-    exporting symbols by ordinal do not justify the risks.
-
-    Technically, it should be possible to maintain ordinals in
-    the DEF file, and still export the symbols by name.  Ordinals
-    exist in every DLL, and even if the dynamic linking performed
-    at the DLL startup is searching for names, ordinals serve as
-    hints, for a faster name lookup.  However, if the DEF file
-    contains ordinals, the Microsoft linker automatically builds
-    an implib that will cause the executables linked to it to use
-    those ordinals, and not the names.  It is interesting to
-    notice that the GNU linker for Win32 does not suffer from this
-    problem.
-
-    It is possible to avoid the DEF file if the exported symbols
-    are accompanied by a "__declspec(dllexport)" attribute in the
-    source files.  You can do this in zlib by predefining the
-    ZLIB_DLL macro.
-
-
- 6. I see that the ZLIB1.DLL functions use the "C" (CDECL) calling
-    convention.  Why not use the STDCALL convention?
-    STDCALL is the standard convention in Win32, and I need it in
-    my Visual Basic project!
-
-    (For readability, we use CDECL to refer to the convention
-     triggered by the "__cdecl" keyword, STDCALL to refer to
-     the convention triggered by "__stdcall", and FASTCALL to
-     refer to the convention triggered by "__fastcall".)
-
-  - Most of the native Windows API functions (without varargs) use
-    indeed the WINAPI convention (which translates to STDCALL in
-    Win32), but the standard C functions use CDECL.  If a user
-    application is intrinsically tied to the Windows API (e.g.
-    it calls native Windows API functions such as CreateFile()),
-    sometimes it makes sense to decorate its own functions with
-    WINAPI.  But if ANSI C or POSIX portability is a goal (e.g.
-    it calls standard C functions such as fopen()), it is not a
-    sound decision to request the inclusion of <windows.h>, or to
-    use non-ANSI constructs, for the sole purpose to make the user
-    functions STDCALL-able.
-
-    The functionality offered by zlib is not in the category of
-    "Windows functionality", but is more like "C functionality".
-
-    Technically, STDCALL is not bad; in fact, it is slightly
-    faster than CDECL, and it works with variable-argument
-    functions, just like CDECL.  It is unfortunate that, in spite
-    of using STDCALL in the Windows API, it is not the default
-    convention used by the C compilers that run under Windows.
-    The roots of the problem reside deep inside the unsafety of
-    the K&R-style function prototypes, where the argument types
-    are not specified; but that is another story for another day.
-
-    The remaining fact is that CDECL is the default convention.
-    Even if an explicit convention is hard-coded into the function
-    prototypes inside C headers, problems may appear.  The
-    necessity to expose the convention in users' callbacks is one
-    of these problems.
-
-    The calling convention issues are also important when using
-    zlib in other programming languages.  Some of them, like Ada
-    (GNAT) and Fortran (GNU G77), have C bindings implemented
-    initially on Unix, and relying on the C calling convention.
-    On the other hand, the pre- .NET versions of Microsoft Visual
-    Basic require STDCALL, while Borland Delphi prefers, although
-    it does not require, FASTCALL.
-
-    In fairness to all possible uses of zlib outside the C
-    programming language, we choose the default "C" convention.
-    Anyone interested in different bindings or conventions is
-    encouraged to maintain specialized projects.  The "contrib/"
-    directory from the zlib distribution already holds a couple
-    of foreign bindings, such as Ada, C++, and Delphi.
-
-
- 7. I need a DLL for my Visual Basic project.  What can I do?
-
-  - Define the ZLIB_WINAPI macro before including "zlib.h", when
-    building both the DLL and the user application (except that
-    you don't need to define anything when using the DLL in Visual
-    Basic).  The ZLIB_WINAPI macro will switch on the WINAPI
-    (STDCALL) convention.  The name of this DLL must be different
-    than the official ZLIB1.DLL.
-
-    Gilles Vollant has contributed a build named ZLIBWAPI.DLL,
-    with the ZLIB_WINAPI macro turned on, and with the minizip
-    functionality built in.  For more information, please read
-    the notes inside "contrib/vstudio/readme.txt", found in the
-    zlib distribution.
-
-
- 8. I need to use zlib in my Microsoft .NET project.  What can I
-    do?
-
-  - Henrik Ravn has contributed a .NET wrapper around zlib.  Look
-    into contrib/dotzlib/, inside the zlib distribution.
-
-
- 9. If my application uses ZLIB1.DLL, should I link it to
-    MSVCRT.DLL?  Why?
-
-  - It is not required, but it is recommended to link your
-    application to MSVCRT.DLL, if it uses ZLIB1.DLL.
-
-    The executables (.EXE, .DLL, etc.) that are involved in the
-    same process and are using the C run-time library (i.e. they
-    are calling standard C functions), must link to the same
-    library.  There are several libraries in the Win32 system:
-    CRTDLL.DLL, MSVCRT.DLL, the static C libraries, etc.
-    Since ZLIB1.DLL is linked to MSVCRT.DLL, the executables that
-    depend on it should also be linked to MSVCRT.DLL.
-
-
-10. Why are you saying that ZLIB1.DLL and my application should
-    be linked to the same C run-time (CRT) library?  I linked my
-    application and my DLLs to different C libraries (e.g. my
-    application to a static library, and my DLLs to MSVCRT.DLL),
-    and everything works fine.
-
-  - If a user library invokes only pure Win32 API (accessible via
-    <windows.h> and the related headers), its DLL build will work
-    in any context.  But if this library invokes standard C API,
-    things get more complicated.
-
-    There is a single Win32 library in a Win32 system.  Every
-    function in this library resides in a single DLL module, that
-    is safe to call from anywhere.  On the other hand, there are
-    multiple versions of the C library, and each of them has its
-    own separate internal state.  Standalone executables and user
-    DLLs that call standard C functions must link to a C run-time
-    (CRT) library, be it static or shared (DLL).  Intermixing
-    occurs when an executable (not necessarily standalone) and a
-    DLL are linked to different CRTs, and both are running in the
-    same process.
-
-    Intermixing multiple CRTs is possible, as long as their
-    internal states are kept intact.  The Microsoft Knowledge Base
-    articles KB94248 "HOWTO: Use the C Run-Time" and KB140584
-    "HOWTO: Link with the Correct C Run-Time (CRT) Library"
-    mention the potential problems raised by intermixing.
-
-    If intermixing works for you, it's because your application
-    and DLLs are avoiding the corruption of each of the CRTs'
-    internal states, maybe by careful design, or maybe by fortune.
-
-    Also note that linking ZLIB1.DLL to non-Microsoft CRTs, such
-    as those provided by Borland, raises similar problems.
-
-
-11. Why are you linking ZLIB1.DLL to MSVCRT.DLL?
-
-  - MSVCRT.DLL exists on every Windows 95 with a new service pack
-    installed, or with Microsoft Internet Explorer 4 or later, and
-    on all other Windows 4.x or later (Windows 98, Windows NT 4,
-    or later).  It is freely distributable; if not present in the
-    system, it can be downloaded from Microsoft or from other
-    software provider for free.
-
-    The fact that MSVCRT.DLL does not exist on a virgin Windows 95
-    is not so problematic.  Windows 95 is scarcely found nowadays,
-    Microsoft ended its support a long time ago, and many recent
-    applications from various vendors, including Microsoft, do not
-    even run on it.  Furthermore, no serious user should run
-    Windows 95 without a proper update installed.
-
-
-12. Why are you not linking ZLIB1.DLL to
-    <<my favorite C run-time library>> ?
-
-  - We considered and abandoned the following alternatives:
-
-    * Linking ZLIB1.DLL to a static C library (LIBC.LIB, or
-      LIBCMT.LIB) is not a good option.  People are using the DLL
-      mainly to save disk space.  If you are linking your program
-      to a static C library, you may as well consider linking zlib
-      in statically, too.
-
-    * Linking ZLIB1.DLL to CRTDLL.DLL looks appealing, because
-      CRTDLL.DLL is present on every Win32 installation.
-      Unfortunately, it has a series of problems: it does not
-      work properly with Microsoft's C++ libraries, it does not
-      provide support for 64-bit file offsets, (and so on...),
-      and Microsoft discontinued its support a long time ago.
-
-    * Linking ZLIB1.DLL to MSVCR70.DLL or MSVCR71.DLL, supplied
-      with the Microsoft .NET platform, and Visual C++ 7.0/7.1,
-      raises problems related to the status of ZLIB1.DLL as a
-      system component.  According to the Microsoft Knowledge Base
-      article KB326922 "INFO: Redistribution of the Shared C
-      Runtime Component in Visual C++ .NET", MSVCR70.DLL and
-      MSVCR71.DLL are not supposed to function as system DLLs,
-      because they may clash with MSVCRT.DLL.  Instead, the
-      application's installer is supposed to put these DLLs
-      (if needed) in the application's private directory.
-      If ZLIB1.DLL depends on a non-system runtime, it cannot
-      function as a redistributable system component.
-
-    * Linking ZLIB1.DLL to non-Microsoft runtimes, such as
-      Borland's, or Cygwin's, raises problems related to the
-      reliable presence of these runtimes on Win32 systems.
-      It's easier to let the DLL build of zlib up to the people
-      who distribute these runtimes, and who may proceed as
-      explained in the answer to Question 14.
-
-
-13. If ZLIB1.DLL cannot be linked to MSVCR70.DLL or MSVCR71.DLL,
-    how can I build/use ZLIB1.DLL in Microsoft Visual C++ 7.0
-    (Visual Studio .NET) or newer?
-
-  - Due to the problems explained in the Microsoft Knowledge Base
-    article KB326922 (see the previous answer), the C runtime that
-    comes with the VC7 environment is no longer considered a
-    system component.  That is, it should not be assumed that this
-    runtime exists, or may be installed in a system directory.
-    Since ZLIB1.DLL is supposed to be a system component, it may
-    not depend on a non-system component.
-
-    In order to link ZLIB1.DLL and your application to MSVCRT.DLL
-    in VC7, you need the library of Visual C++ 6.0 or older.  If
-    you don't have this library at hand, it's probably best not to
-    use ZLIB1.DLL.
-
-    We are hoping that, in the future, Microsoft will provide a
-    way to build applications linked to a proper system runtime,
-    from the Visual C++ environment.  Until then, you have a
-    couple of alternatives, such as linking zlib in statically.
-    If your application requires dynamic linking, you may proceed
-    as explained in the answer to Question 14.
-
-
-14. I need to link my own DLL build to a CRT different than
-    MSVCRT.DLL.  What can I do?
-
-  - Feel free to rebuild the DLL from the zlib sources, and link
-    it the way you want.  You should, however, clearly state that
-    your build is unofficial.  You should give it a different file
-    name, and/or install it in a private directory that can be
-    accessed by your application only, and is not visible to the
-    others (i.e. it's neither in the PATH, nor in the SYSTEM or
-    SYSTEM32 directories).  Otherwise, your build may clash with
-    applications that link to the official build.
-
-    For example, in Cygwin, zlib is linked to the Cygwin runtime
-    CYGWIN1.DLL, and it is distributed under the name CYGZ.DLL.
-
-
-15. May I include additional pieces of code that I find useful,
-    link them in ZLIB1.DLL, and export them?
-
-  - No.  A legitimate build of ZLIB1.DLL must not include code
-    that does not originate from the official zlib source code.
-    But you can make your own private DLL build, under a different
-    file name, as suggested in the previous answer.
-
-    For example, zlib is a part of the VCL library, distributed
-    with Borland Delphi and C++ Builder.  The DLL build of VCL
-    is a redistributable file, named VCLxx.DLL.
-
-
-16. May I remove some functionality out of ZLIB1.DLL, by enabling
-    macros like NO_GZCOMPRESS or NO_GZIP at compile time?
-
-  - No.  A legitimate build of ZLIB1.DLL must provide the complete
-    zlib functionality, as implemented in the official zlib source
-    code.  But you can make your own private DLL build, under a
-    different file name, as suggested in the previous answer.
-
-
-17. I made my own ZLIB1.DLL build.  Can I test it for compliance?
-
-  - We prefer that you download the official DLL from the zlib
-    web site.  If you need something peculiar from this DLL, you
-    can send your suggestion to the zlib mailing list.
-
-    However, in case you do rebuild the DLL yourself, you can run
-    it with the test programs found in the DLL distribution.
-    Running these test programs is not a guarantee of compliance,
-    but a failure can imply a detected problem.
-
-**
-
-This document is written and maintained by
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff --git a/contrib/zlib/win32/Makefile.bor b/contrib/zlib/win32/Makefile.bor
deleted file mode 100644
index d152bbb7f..000000000
--- a/contrib/zlib/win32/Makefile.bor
+++ /dev/null
@@ -1,110 +0,0 @@
-# Makefile for zlib
-# Borland C++ for Win32
-#
-# Usage:
-#  make -f win32/Makefile.bor
-#  make -f win32/Makefile.bor LOCAL_ZLIB=-DASMV OBJA=match.obj OBJPA=+match.obj
-
-# ------------ Borland C++ ------------
-
-# Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-# should be added to the environment via "set LOCAL_ZLIB=-DFOO" or
-# added to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-CC = bcc32
-AS = bcc32
-LD = bcc32
-AR = tlib
-CFLAGS  = -a -d -k- -O2 $(LOC)
-ASFLAGS = $(LOC)
-LDFLAGS = $(LOC)
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-#OBJA =
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-#OBJPA=
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $<
-
-.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2) $(OBJA)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-	$(AR) $(ZLIB_LIB) $(OBJPA)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del $(ZLIB_LIB)
-	-del *.obj
-	-del *.exe
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
diff --git a/contrib/zlib/win32/Makefile.gcc b/contrib/zlib/win32/Makefile.gcc
deleted file mode 100644
index 305be50af..000000000
--- a/contrib/zlib/win32/Makefile.gcc
+++ /dev/null
@@ -1,182 +0,0 @@
-# Makefile for zlib, derived from Makefile.dj2.
-# Modified for mingw32 by C. Spieler, 6/16/98.
-# Updated for zlib 1.2.x by Christian Spieler and Cosmin Truta, Mar-2003.
-# Last updated: Mar 2012.
-# Tested under Cygwin and MinGW.
-
-# Copyright (C) 1995-2003 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type from the top level zlib directory:
-#
-#   make -fwin32/Makefile.gcc;  make test testdll -fwin32/Makefile.gcc
-#
-# To use the asm code, type:
-#   cp contrib/asm?86/match.S ./match.S
-#   make LOC=-DASMV OBJA=match.o -fwin32/Makefile.gcc
-#
-# To install libz.a, zconf.h and zlib.h in the system directories, type:
-#
-#   make install -fwin32/Makefile.gcc
-#
-# BINARY_PATH, INCLUDE_PATH and LIBRARY_PATH must be set.
-#
-# To install the shared lib, append SHARED_MODE=1 to the make command :
-#
-#   make install -fwin32/Makefile.gcc SHARED_MODE=1
-
-# Note:
-# If the platform is *not* MinGW (e.g. it is Cygwin or UWIN),
-# the DLL name should be changed from "zlib1.dll".
-
-STATICLIB = libz.a
-SHAREDLIB = zlib1.dll
-IMPLIB    = libz.dll.a
-
-#
-# Set to 1 if shared object needs to be installed
-#
-SHARED_MODE=0
-
-#LOC = -DASMV
-#LOC = -DZLIB_DEBUG -g
-
-PREFIX =
-CC = $(PREFIX)gcc
-CFLAGS = $(LOC) -O3 -Wall
-
-AS = $(CC)
-ASFLAGS = $(LOC) -Wall
-
-LD = $(CC)
-LDFLAGS = $(LOC)
-
-AR = $(PREFIX)ar
-ARFLAGS = rcs
-
-RC = $(PREFIX)windres
-RCFLAGS = --define GCC_WINDRES
-
-STRIP = $(PREFIX)strip
-
-CP = cp -fp
-# If GNU install is available, replace $(CP) with install.
-INSTALL = $(CP)
-RM = rm -f
-
-prefix ?= /usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o deflate.o gzclose.o gzlib.o gzread.o \
-       gzwrite.o infback.o inffast.o inflate.o inftrees.o trees.o uncompr.o zutil.o
-OBJA =
-
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) example.exe minigzip.exe example_d.exe minigzip_d.exe
-
-test: example.exe minigzip.exe
-	./example
-	echo hello world | ./minigzip | ./minigzip -d
-
-testdll: example_d.exe minigzip_d.exe
-	./example_d
-	echo hello world | ./minigzip_d | ./minigzip_d -d
-
-.c.o:
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-.S.o:
-	$(AS) $(ASFLAGS) -c -o $@ $<
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlibrc.o
-	$(CC) -shared -Wl,--out-implib,$(IMPLIB) $(LDFLAGS) \
-	-o $@ win32/zlib.def $(OBJS) $(OBJA) zlibrc.o
-	$(STRIP) $@
-
-example.exe: example.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(STATICLIB)
-	$(STRIP) $@
-
-minigzip.exe: minigzip.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(STATICLIB)
-	$(STRIP) $@
-
-example_d.exe: example.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(IMPLIB)
-	$(STRIP) $@
-
-minigzip_d.exe: minigzip.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(IMPLIB)
-	$(STRIP) $@
-
-example.o: test/example.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/example.c
-
-minigzip.o: test/minigzip.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/minigzip.c
-
-zlibrc.o: win32/zlib1.rc
-	$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc
-
-.PHONY: install uninstall clean
-
-install: zlib.h zconf.h $(STATICLIB) $(IMPLIB)
-	@if test -z "$(DESTDIR)$(INCLUDE_PATH)" -o -z "$(DESTDIR)$(LIBRARY_PATH)" -o -z "$(DESTDIR)$(BINARY_PATH)"; then \
-		echo INCLUDE_PATH, LIBRARY_PATH, and BINARY_PATH must be specified; \
-		exit 1; \
-	fi
-	-@mkdir -p '$(DESTDIR)$(INCLUDE_PATH)'
-	-@mkdir -p '$(DESTDIR)$(LIBRARY_PATH)' '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig
-	-if [ "$(SHARED_MODE)" = "1" ]; then \
-		mkdir -p '$(DESTDIR)$(BINARY_PATH)'; \
-		$(INSTALL) $(SHAREDLIB) '$(DESTDIR)$(BINARY_PATH)'; \
-		$(INSTALL) $(IMPLIB) '$(DESTDIR)$(LIBRARY_PATH)'; \
-	fi
-	-$(INSTALL) zlib.h '$(DESTDIR)$(INCLUDE_PATH)'
-	-$(INSTALL) zconf.h '$(DESTDIR)$(INCLUDE_PATH)'
-	-$(INSTALL) $(STATICLIB) '$(DESTDIR)$(LIBRARY_PATH)'
-	sed \
-		-e 's|@prefix@|${prefix}|g' \
-		-e 's|@exec_prefix@|${exec_prefix}|g' \
-		-e 's|@libdir@|$(LIBRARY_PATH)|g' \
-		-e 's|@sharedlibdir@|$(LIBRARY_PATH)|g' \
-		-e 's|@includedir@|$(INCLUDE_PATH)|g' \
-		-e 's|@VERSION@|'`sed -n -e '/VERSION "/s/.*"\(.*\)".*/\1/p' zlib.h`'|g' \
-		zlib.pc.in > '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig/zlib.pc
-
-uninstall:
-	-if [ "$(SHARED_MODE)" = "1" ]; then \
-		$(RM) '$(DESTDIR)$(BINARY_PATH)'/$(SHAREDLIB); \
-		$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(IMPLIB); \
-	fi
-	-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zlib.h
-	-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zconf.h
-	-$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(STATICLIB)
-
-clean:
-	-$(RM) $(STATICLIB)
-	-$(RM) $(SHAREDLIB)
-	-$(RM) $(IMPLIB)
-	-$(RM) *.o
-	-$(RM) *.exe
-	-$(RM) foo.gz
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-gzclose.o: zlib.h zconf.h gzguts.h
-gzlib.o: zlib.h zconf.h gzguts.h
-gzread.o: zlib.h zconf.h gzguts.h
-gzwrite.o: zlib.h zconf.h gzguts.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff --git a/contrib/zlib/win32/Makefile.msc b/contrib/zlib/win32/Makefile.msc
deleted file mode 100644
index 6831882de..000000000
--- a/contrib/zlib/win32/Makefile.msc
+++ /dev/null
@@ -1,163 +0,0 @@
-# Makefile for zlib using Microsoft (Visual) C
-# zlib is copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
-#
-# Usage:
-#   nmake -f win32/Makefile.msc                          (standard build)
-#   nmake -f win32/Makefile.msc LOC=-DFOO                (nonstandard build)
-#   nmake -f win32/Makefile.msc LOC="-DASMV -DASMINF" \
-#         OBJA="inffas32.obj match686.obj"               (use ASM code, x86)
-#   nmake -f win32/Makefile.msc AS=ml64 LOC="-DASMV -DASMINF -I." \
-#         OBJA="inffasx64.obj gvmat64.obj inffas8664.obj"  (use ASM code, x64)
-
-# The toplevel directory of the source tree.
-#
-TOP = .
-
-# optional build flags
-LOC =
-
-# variables
-STATICLIB = zlib.lib
-SHAREDLIB = zlib1.dll
-IMPLIB    = zdll.lib
-
-CC = cl
-AS = ml
-LD = link
-AR = lib
-RC = rc
-CFLAGS  = -nologo -MD -W3 -O2 -Oy- -Zi -Fd"zlib" $(LOC)
-WFLAGS  = -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE
-ASFLAGS = -coff -Zi $(LOC)
-LDFLAGS = -nologo -debug -incremental:no -opt:ref
-ARFLAGS = -nologo
-RCFLAGS = /dWIN32 /r
-
-OBJS = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj \
-       gzwrite.obj infback.obj inflate.obj inftrees.obj inffast.obj trees.obj uncompr.obj zutil.obj
-OBJA =
-
-
-# targets
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) \
-     example.exe minigzip.exe example_d.exe minigzip_d.exe
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) -out:$@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): $(TOP)/win32/zlib.def $(OBJS) $(OBJA) zlib1.res
-	$(LD) $(LDFLAGS) -def:$(TOP)/win32/zlib.def -dll -implib:$(IMPLIB) \
-	  -out:$@ -base:0x5A4C0000 $(OBJS) $(OBJA) zlib1.res
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;2
-
-example.exe: example.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) example.obj $(STATICLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-minigzip.exe: minigzip.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(STATICLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-example_d.exe: example.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ example.obj $(IMPLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-minigzip_d.exe: minigzip.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ minigzip.obj $(IMPLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-{$(TOP)}.c.obj:
-	$(CC) -c $(WFLAGS) $(CFLAGS) $<
-
-{$(TOP)/test}.c.obj:
-	$(CC) -c -I$(TOP) $(WFLAGS) $(CFLAGS) $<
-
-{$(TOP)/contrib/masmx64}.c.obj:
-	$(CC) -c $(WFLAGS) $(CFLAGS) $<
-
-{$(TOP)/contrib/masmx64}.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-{$(TOP)/contrib/masmx86}.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: $(TOP)/adler32.c $(TOP)/zlib.h $(TOP)/zconf.h
-
-compress.obj: $(TOP)/compress.c $(TOP)/zlib.h $(TOP)/zconf.h
-
-crc32.obj: $(TOP)/crc32.c $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/crc32.h
-
-deflate.obj: $(TOP)/deflate.c $(TOP)/deflate.h $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h
-
-gzclose.obj: $(TOP)/gzclose.c $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/gzguts.h
-
-gzlib.obj: $(TOP)/gzlib.c $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/gzguts.h
-
-gzread.obj: $(TOP)/gzread.c $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/gzguts.h
-
-gzwrite.obj: $(TOP)/gzwrite.c $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/gzguts.h
-
-infback.obj: $(TOP)/infback.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/inftrees.h $(TOP)/inflate.h \
-             $(TOP)/inffast.h $(TOP)/inffixed.h
-
-inffast.obj: $(TOP)/inffast.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/inftrees.h $(TOP)/inflate.h \
-             $(TOP)/inffast.h
-
-inflate.obj: $(TOP)/inflate.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/inftrees.h $(TOP)/inflate.h \
-             $(TOP)/inffast.h $(TOP)/inffixed.h
-
-inftrees.obj: $(TOP)/inftrees.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/inftrees.h
-
-trees.obj: $(TOP)/trees.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h $(TOP)/deflate.h $(TOP)/trees.h
-
-uncompr.obj: $(TOP)/uncompr.c $(TOP)/zlib.h $(TOP)/zconf.h
-
-zutil.obj: $(TOP)/zutil.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h
-
-gvmat64.obj: $(TOP)/contrib\masmx64\gvmat64.asm
-
-inffasx64.obj: $(TOP)/contrib\masmx64\inffasx64.asm
-
-inffas8664.obj: $(TOP)/contrib\masmx64\inffas8664.c $(TOP)/zutil.h $(TOP)/zlib.h $(TOP)/zconf.h \
-		$(TOP)/inftrees.h $(TOP)/inflate.h $(TOP)/inffast.h
-
-inffas32.obj: $(TOP)/contrib\masmx86\inffas32.asm
-
-match686.obj: $(TOP)/contrib\masmx86\match686.asm
-
-example.obj: $(TOP)/test/example.c $(TOP)/zlib.h $(TOP)/zconf.h
-
-minigzip.obj: $(TOP)/test/minigzip.c $(TOP)/zlib.h $(TOP)/zconf.h
-
-zlib1.res: $(TOP)/win32/zlib1.rc
-	$(RC) $(RCFLAGS) /fo$@ $(TOP)/win32/zlib1.rc
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-testdll: example_d.exe minigzip_d.exe
-	example_d
-	echo hello world | minigzip_d | minigzip_d -d
-
-
-# cleanup
-clean:
-	-del $(STATICLIB)
-	-del $(SHAREDLIB)
-	-del $(IMPLIB)
-	-del *.obj
-	-del *.res
-	-del *.exp
-	-del *.exe
-	-del *.pdb
-	-del *.manifest
-	-del foo.gz
diff --git a/contrib/zlib/win32/README-WIN32.txt b/contrib/zlib/win32/README-WIN32.txt
deleted file mode 100644
index a1de359a3..000000000
--- a/contrib/zlib/win32/README-WIN32.txt
+++ /dev/null
@@ -1,103 +0,0 @@
-ZLIB DATA COMPRESSION LIBRARY
-
-zlib 1.2.11.1 is a general purpose data compression library.  All the code is
-thread safe.  The data format used by the zlib library is described by RFCs
-(Request for Comments) 1950 to 1952 in the files
-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)
-and rfc1952.txt (gzip format).
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org).  Two compiled
-examples are distributed in this package, example and minigzip.  The example_d
-and minigzip_d flavors validate that the zlib1.dll file is working correctly.
-
-Questions about zlib should be sent to <zlib@gzip.org>.  The zlib home page
-is http://zlib.net/ .  Before reporting a problem, please check this site to
-verify that you have the latest version of zlib; otherwise get the latest
-version and check whether the problem still exists or not.
-
-PLEASE read DLL_FAQ.txt, and the the zlib FAQ http://zlib.net/zlib_faq.html
-before asking for help.
-
-
-Manifest:
-
-The package zlib-1.2.11.1-win32-x86.zip will contain the following files:
-
-  README-WIN32.txt This document
-  ChangeLog        Changes since previous zlib packages
-  DLL_FAQ.txt      Frequently asked questions about zlib1.dll
-  zlib.3.pdf       Documentation of this library in Adobe Acrobat format
-
-  example.exe      A statically-bound example (using zlib.lib, not the dll)
-  example.pdb      Symbolic information for debugging example.exe
-
-  example_d.exe    A zlib1.dll bound example (using zdll.lib)
-  example_d.pdb    Symbolic information for debugging example_d.exe
-
-  minigzip.exe     A statically-bound test program (using zlib.lib, not the dll)
-  minigzip.pdb     Symbolic information for debugging minigzip.exe
-
-  minigzip_d.exe   A zlib1.dll bound test program (using zdll.lib)
-  minigzip_d.pdb   Symbolic information for debugging minigzip_d.exe
-
-  zlib.h           Install these files into the compilers' INCLUDE path to
-  zconf.h          compile programs which use zlib.lib or zdll.lib
-
-  zdll.lib         Install these files into the compilers' LIB path if linking
-  zdll.exp         a compiled program to the zlib1.dll binary
-
-  zlib.lib         Install these files into the compilers' LIB path to link zlib
-  zlib.pdb         into compiled programs, without zlib1.dll runtime dependency
-                   (zlib.pdb provides debugging info to the compile time linker)
-
-  zlib1.dll        Install this binary shared library into the system PATH, or
-                   the program's runtime directory (where the .exe resides)
-  zlib1.pdb        Install in the same directory as zlib1.dll, in order to debug
-                   an application crash using WinDbg or similar tools.
-
-All .pdb files above are entirely optional, but are very useful to a developer
-attempting to diagnose program misbehavior or a crash.  Many additional
-important files for developers can be found in the zlib127.zip source package
-available from http://zlib.net/ - review that package's README file for details.
-
-
-Acknowledgments:
-
-The deflate format used by zlib was defined by Phil Katz.  The deflate and
-zlib specifications were written by L.  Peter Deutsch.  Thanks to all the
-people who reported problems and suggested various improvements in zlib; they
-are too numerous to cite here.
-
-
-Copyright notice:
-
-  (C) 1995-2017 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not* receiving
-lengthy legal documents to sign.  The sources are provided for free but without
-warranty of any kind.  The library has been entirely written by Jean-loup
-Gailly and Mark Adler; it does not include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include in
-the file ChangeLog history information documenting your changes.  Please read
-the FAQ for more information on the distribution of modified source versions.
diff --git a/contrib/zlib/win32/VisualC.txt b/contrib/zlib/win32/VisualC.txt
deleted file mode 100644
index 1005b2194..000000000
--- a/contrib/zlib/win32/VisualC.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-
-To build zlib using the Microsoft Visual C++ environment,
-use the appropriate project from the contrib/vstudio/ directory.
diff --git a/contrib/zlib/win32/zlib.def b/contrib/zlib/win32/zlib.def
deleted file mode 100644
index a2188b000..000000000
--- a/contrib/zlib/win32/zlib.def
+++ /dev/null
@@ -1,94 +0,0 @@
-; zlib data compression library
-EXPORTS
-; basic functions
-    zlibVersion
-    deflate
-    deflateEnd
-    inflate
-    inflateEnd
-; advanced functions
-    deflateSetDictionary
-    deflateGetDictionary
-    deflateCopy
-    deflateReset
-    deflateParams
-    deflateTune
-    deflateBound
-    deflatePending
-    deflatePrime
-    deflateSetHeader
-    inflateSetDictionary
-    inflateGetDictionary
-    inflateSync
-    inflateCopy
-    inflateReset
-    inflateReset2
-    inflatePrime
-    inflateMark
-    inflateGetHeader
-    inflateBack
-    inflateBackEnd
-    zlibCompileFlags
-; utility functions
-    compress
-    compress2
-    compressBound
-    uncompress
-    uncompress2
-    gzopen
-    gzdopen
-    gzbuffer
-    gzsetparams
-    gzread
-    gzfread
-    gzwrite
-    gzfwrite
-    gzprintf
-    gzvprintf
-    gzputs
-    gzgets
-    gzputc
-    gzgetc
-    gzungetc
-    gzflush
-    gzseek
-    gzrewind
-    gztell
-    gzoffset
-    gzeof
-    gzdirect
-    gzclose
-    gzclose_r
-    gzclose_w
-    gzerror
-    gzclearerr
-; large file functions
-    gzopen64
-    gzseek64
-    gztell64
-    gzoffset64
-    adler32_combine64
-    crc32_combine64
-; checksum functions
-    adler32
-    adler32_z
-    crc32
-    crc32_z
-    adler32_combine
-    crc32_combine
-; various hacks, don't look :)
-    deflateInit_
-    deflateInit2_
-    inflateInit_
-    inflateInit2_
-    inflateBackInit_
-    gzgetc_
-    zError
-    inflateSyncPoint
-    get_crc_table
-    inflateUndermine
-    inflateValidate
-    inflateCodesUsed
-    inflateResetKeep
-    deflateResetKeep
-    gzopen_w
diff --git a/contrib/zlib/win32/zlib1.rc b/contrib/zlib/win32/zlib1.rc
deleted file mode 100644
index 234e641c3..000000000
--- a/contrib/zlib/win32/zlib1.rc
+++ /dev/null
@@ -1,40 +0,0 @@
-#include <winver.h>
-#include "../zlib.h"
-
-#ifdef GCC_WINDRES
-VS_VERSION_INFO		VERSIONINFO
-#else
-VS_VERSION_INFO		VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-#endif
-  FILEVERSION		ZLIB_VER_MAJOR,ZLIB_VER_MINOR,ZLIB_VER_REVISION,0
-  PRODUCTVERSION	ZLIB_VER_MAJOR,ZLIB_VER_MINOR,ZLIB_VER_REVISION,0
-  FILEFLAGSMASK		VS_FFI_FILEFLAGSMASK
-#ifdef _DEBUG
-  FILEFLAGS		1
-#else
-  FILEFLAGS		0
-#endif
-  FILEOS		VOS__WINDOWS32
-  FILETYPE		VFT_DLL
-  FILESUBTYPE		0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-    BEGIN
-      VALUE "FileDescription",	"zlib data compression library\0"
-      VALUE "FileVersion",	ZLIB_VERSION "\0"
-      VALUE "InternalName",	"zlib1.dll\0"
-      VALUE "LegalCopyright",	"(C) 1995-2017 Jean-loup Gailly & Mark Adler\0"
-      VALUE "OriginalFilename",	"zlib1.dll\0"
-      VALUE "ProductName",	"zlib\0"
-      VALUE "ProductVersion",	ZLIB_VERSION "\0"
-      VALUE "Comments",		"For more information visit http://www.zlib.net/\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff --git a/contrib/zlib/zconf.h.cmakein b/contrib/zlib/zconf.h.cmakein
deleted file mode 100644
index a7f24cce6..000000000
--- a/contrib/zlib/zconf.h.cmakein
+++ /dev/null
@@ -1,536 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-#cmakedefine Z_PREFIX
-#cmakedefine Z_HAVE_UNISTD_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff --git a/contrib/zlib/zconf.h.in b/contrib/zlib/zconf.h.in
deleted file mode 100644
index 5e1d68a00..000000000
--- a/contrib/zlib/zconf.h.in
+++ /dev/null
@@ -1,534 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff --git a/contrib/zlib/zconf.h.included b/contrib/zlib/zconf.h.included
deleted file mode 100644
index 352f552b8..000000000
--- a/contrib/zlib/zconf.h.included
+++ /dev/null
@@ -1,536 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-/* #undef Z_PREFIX */
-/* #undef Z_HAVE_UNISTD_H */
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff --git a/contrib/zlib/zlib.h b/contrib/zlib/zlib.h
deleted file mode 100644
index dcb7b5063..000000000
--- a/contrib/zlib/zlib.h
+++ /dev/null
@@ -1,1917 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.11.1, January xxth, 2017
-
-  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
-  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.11.1-motley"
-#define ZLIB_VERNUM 0x12b1
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 11
-#define ZLIB_VER_SUBREVISION 1
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip and raw deflate streams in
-  memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in the case of corrupted input.
-*/
-
-#ifdef __ANDROID__
-typedef unsigned long zcrc_t;
-#endif
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    z_const Bytef *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte will go here */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
-
-    z_const char *msg;  /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text
-                           for deflate, or the decoding state for inflate */
-    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
-   Z_NULL on entry to the initialization function, they are set to internal
-   routines that use the standard library functions malloc() and free().
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use by the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field for deflate() */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary.  Some output may be provided even if
-    flush is zero.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending. See deflatePending(),
-  which can be used if desired to determine whether or not there is more ouput
-  in that case.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed
-  codes block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
-  function must be called again with Z_FINISH and more output space (updated
-  avail_out) but no more input data, until it returns with Z_STREAM_END or an
-  error.  After deflate has returned Z_STREAM_END, the only possible operations
-  on the stream are deflateReset or deflateEnd.
-
-    Z_FINISH can be used in the first deflate call after deflateInit if all the
-  compression is to be done in a single step.  In order to complete in one
-  call, avail_out must be at least the value returned by deflateBound (see
-  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
-  output space is provided, deflate will not return Z_STREAM_END, and it must
-  be called again as described above.
-
-    deflate() sets strm->adler to the Adler-32 checksum of all input read
-  so far (that is, total_in bytes).  If a gzip stream is being generated, then
-  strm->adler will be the CRC-32 checksum of the input read so far.  (See
-  deflateInit2 below.)
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
-  considered binary.  This field is only for information purposes and does not
-  affect the compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL or the state was inadvertently written over
-  by the application), or Z_BUF_ERROR if no progress is possible (for example
-  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
-  deflate() can be called again with more input and more output space to
-  continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  In the current version of inflate, the provided input is not
-   read or consumed.  The allocation of a sliding window will be deferred to
-   the first call of inflate (if the decompression does not complete on the
-   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
-   them to use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression.
-   Actual decompression will be done by inflate().  So next_in, and avail_in,
-   next_out, and avail_out are unused and unchanged.  The current
-   implementation of inflateInit() does not process any header information --
-   that is deferred until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), then next_in and avail_in are updated
-    accordingly, and processing will resume at this point for the next call of
-    inflate().
-
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  If the
-  caller of inflate() does not provide both available input and available
-  output space, it is possible that there will be no progress made.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  To assist in this, on return inflate() always sets strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all of the uncompressed data for the
-  operation to complete.  (The size of the uncompressed data may have been
-  saved by the compressor for this purpose.)  The use of Z_FINISH is not
-  required to perform an inflation in one step.  However it may be used to
-  inform inflate that a faster approach can be used for the single inflate()
-  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
-  stream completes, which reduces inflate's memory footprint.  If the stream
-  does not complete, either because not all of the stream is provided or not
-  enough output space is provided, then a sliding window will be allocated and
-  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
-  been used.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the effects of the flush parameter in this implementation are
-  on the return value of inflate() as noted below, when inflate() returns early
-  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
-  memory for a sliding window when Z_FINISH is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the Adler-32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed Adler-32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained unless inflateGetHeader() is used.  When processing
-  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
-  uncompressed length, modulo 2^32.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value, in which case strm->msg points to a string with a more specific
-  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL, or the state was inadvertently written over
-  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
-  if no progress was possible or if there was not enough room in the output
-  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is to be attempted.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
-   was inconsistent.
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     For the current implementation of deflate(), a windowBits value of 8 (a
-   window size of 256 bytes) is not supported.  As a result, a request for 8
-   will result in 9 (a 512-byte window).  In that case, providing 8 to
-   inflateInit2() will result in an error when the zlib header with 9 is
-   checked against the initialization of inflate().  The remedy is to not use 8
-   with deflateInit2() with this initialization, or at least in that case use 9
-   with inflateInit2().
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute a check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to the appropriate value,
-   if the operating system was determined at compile time.  If a gzip stream is
-   being written, strm->adler is a CRC-32 instead of an Adler-32.
-
-     For raw deflate or gzip encoding, a request for a 256-byte window is
-   rejected as invalid, since only the zlib header provides a means of
-   transmitting the window size to the decompressor.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  When using the zlib format, this
-   function must be called immediately after deflateInit, deflateInit2 or
-   deflateReset, and before any call of deflate.  When doing raw deflate, this
-   function must be called either before any call of deflate, or immediately
-   after the completion of a deflate block, i.e. after all input has been
-   consumed and all output has been delivered when using any of the flush
-   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
-   compressor and decompressor must use exactly the same dictionary (see
-   inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the Adler-32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The Adler-32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   Adler-32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if not at a block boundary for raw deflate).  deflateSetDictionary does
-   not perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by deflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If deflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similary, if dictLength is Z_NULL, then it is not set.
-
-     deflateGetDictionary() may return a length less than the window size, even
-   when more than the window size in input has been provided. It may return up
-   to 258 bytes less in that case, due to how zlib's implementation of deflate
-   manages the sliding window and lookahead for matches, where matches can be
-   up to 258 bytes long. If the application needs the last window-size bytes of
-   input, then that would need to be saved by the application outside of zlib.
-
-     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit, but
-   does not free and reallocate the internal compression state.  The stream
-   will leave the compression level and any other attributes that may have been
-   set unchanged.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2().  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression approach (which is a function of the level) or the
-   strategy is changed, and if there have been any deflate() calls since the
-   state was initialized or reset, then the input available so far is
-   compressed with the old level and strategy using deflate(strm, Z_BLOCK).
-   There are three approaches for the compression levels 0, 1..3, and 4..9
-   respectively.  The new level and strategy will take effect at the next call
-   of deflate().
-
-     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
-   not have enough output space to complete, then the parameter change will not
-   take effect.  In this case, deflateParams() can be called again with the
-   same parameters and more output space to try again.
-
-     In order to assure a change in the parameters on the first try, the
-   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
-   request until strm.avail_out is not zero, before calling deflateParams().
-   Then no more input data should be provided before the deflateParams() call.
-   If this is done, the old level and strategy will be applied to the data
-   compressed before deflateParams(), and the new level and strategy will be
-   applied to the the data compressed after deflateParams().
-
-     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
-   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
-   there was not enough output space to complete the compression of the
-   available input data before a change in the strategy or approach.  Note that
-   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
-   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
-   retried with more output space.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().  If that first deflate() call is provided the
-   sourceLen input bytes, an output buffer allocated to the size returned by
-   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
-   to return Z_STREAM_END.  Note that it is possible for the compressed size to
-   be larger than the value returned by deflateBound() if flush options other
-   than Z_FINISH or Z_NO_FLUSH are used.
-*/
-
-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
-                                       unsigned *pending,
-                                       int *bits));
-/*
-     deflatePending() returns the number of bytes and bits of output that have
-   been generated, but not yet provided in the available output.  The bytes not
-   provided would be due to the available output space having being consumed.
-   The number of bits of output not provided are between 0 and 7, where they
-   await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
-
-     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
- */
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
-   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
-   below), inflate() will not automatically decode concatenated gzip streams.
-   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state
-   would need to be reset to continue decoding a subsequent gzip stream.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the Adler-32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called at any
-   time to set the dictionary.  If the provided dictionary is smaller than the
-   window and there is already data in the window, then the provided dictionary
-   will amend what's there.  The application must insure that the dictionary
-   that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by inflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If inflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similary, if dictLength is Z_NULL, then it is not set.
-
-     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a possible full flush point (see above
-   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
-   All full flush points have this pattern, but not all occurrences of this
-   pattern are full flush points.
-
-     inflateSync returns Z_OK if a possible full flush point has been found,
-   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
-   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
-   In the success case, the application may save the current current value of
-   total_in which indicates where valid compressed data was found.  In the
-   error case, the application may repeatedly call inflateSync, providing more
-   input each time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.  If the window size is changed, then the
-   memory allocated for the window is freed, and the window will be reallocated
-   by inflate() if needed.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above, or -65536 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *,
-                                z_const unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is potentially more efficient than
-   inflate() for file i/o applications, in that it avoids copying between the
-   output and the sliding window by simply making the window itself the output
-   buffer.  inflate() can be faster on modern CPUs when used with large
-   buffers.  inflateBack() trusts the application to not change the output
-   buffer passed by the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the default
-   behavior of inflate(), which expects a zlib header and trailer around the
-   deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero -- buf is ignored in that
-   case -- and inflateBack() will return a buffer error.  inflateBack() will
-   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
-   out() should return zero on success, or non-zero on failure.  If out()
-   returns non-zero, inflateBack() will return with an error.  Neither in() nor
-   out() are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.)  Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: ZLIB_DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-#ifndef Z_SOLO
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.  compress() is equivalent to compress2() with a level
-   parameter of Z_DEFAULT_COMPRESSION.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed data.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
-   the case where there is not enough room, uncompress() will fill the output
-   buffer with the uncompressed data up to that point.
-*/
-
-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
-                                    const Bytef *source, uLong *sourceLen));
-/*
-     Same as uncompress, except that sourceLen is a pointer, where the
-   length of the source is *sourceLen.  On return, *sourceLen is the number of
-   source bytes consumed.
-*/
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.)  'T' will
-   request transparent writing or appending with no compression and not using
-   the gzip format.
-
-     "a" can be used instead of "w" to request that the gzip stream that will
-   be written be appended to the file.  "+" will result in an error, since
-   reading and writing to the same gzip file is not supported.  The addition of
-   "x" when writing will create the file exclusively, which fails if the file
-   already exists.  On systems that support it, the addition of "e" when
-   reading or writing will set the flag to close the file on an execve() call.
-
-     These functions, as well as gzip, will read and decode a sequence of gzip
-   streams in a file.  The append function of gzopen() can be used to create
-   such a file.  (Also see gzflush() for another way to do this.)  When
-   appending, gzopen does not test whether the file begins with a gzip stream,
-   nor does it look for the end of the gzip streams to begin appending.  gzopen
-   will simply append a gzip stream to the existing file.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.  When
-   reading, this will be detected automatically by looking for the magic two-
-   byte gzip header.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.  If you are using fileno() to get the
-   file descriptor from a FILE *, then you will have to use dup() to avoid
-   double-close()ing the file descriptor.  Both gzclose() and fclose() will
-   close the associated file descriptor, so they need to have different file
-   descriptors.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Three times that size in buffer space is allocated.  A larger buffer
-   size of, for example, 64K or 128K bytes will noticeably increase the speed
-   of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.  Previously provided
-   data is flushed before the parameter change.
-
-     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
-   opened for writing, Z_ERRNO if there is an error writing the flushed data,
-   or Z_MEM_ERROR if there is a memory allocation error.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file is not in gzip format, gzread copies the given number of
-   bytes into the buffer directly from the file.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream.  Any number of gzip streams may be
-   concatenated in the input file, and will all be decompressed by gzread().
-   If something other than a gzip stream is encountered after a gzip stream,
-   that remaining trailing garbage is ignored (and no error is returned).
-
-     gzread can be used to read a gzip file that is being concurrently written.
-   Upon reaching the end of the input, gzread will return with the available
-   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
-   gzclearerr can be used to clear the end of file indicator in order to permit
-   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
-   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
-   middle of a gzip stream.  Note that gzread does not return -1 in the event
-   of an incomplete gzip stream.  This error is deferred until gzclose(), which
-   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
-   stream.  Alternatively, gzerror can be used before gzclose to detect this
-   case.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.  If len is too large to fit in an int,
-   then nothing is read, -1 is returned, and the error state is set to
-   Z_STREAM_ERROR.
-*/
-
-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
-                                     gzFile file));
-/*
-     Read up to nitems items of size size from file to buf, otherwise operating
-   as gzread() does.  This duplicates the interface of stdio's fread(), with
-   size_t request and return types.  If the library defines size_t, then
-   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned
-   integer type that can contain a pointer.
-
-     gzfread() returns the number of full items read of size size, or zero if
-   the end of the file was reached and a full item could not be read, or if
-   there was an error.  gzerror() must be consulted if zero is returned in
-   order to determine if there was an error.  If the multiplication of size and
-   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
-   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
-
-     In the event that the end of file is reached and only a partial item is
-   available at the end, i.e. the remaining uncompressed data length is not a
-   multiple of size, then the final partial item is nevetheless read into buf
-   and the end-of-file flag is set.  The length of the partial item read is not
-   provided, but could be inferred from the result of gztell().  This behavior
-   is the same as the behavior of fread() implementations in common libraries,
-   but it prevents the direct use of gzfread() to read a concurrently written
-   file, reseting and retrying on end-of-file, when size is not 1.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
-                                      z_size_t nitems, gzFile file));
-/*
-     gzfwrite() writes nitems items of size size from buf to file, duplicating
-   the interface of stdio's fwrite(), with size_t request and return types.  If
-   the library defines size_t, then z_size_t is identical to size_t.  If not,
-   then z_size_t is an unsigned integer type that can contain a pointer.
-
-     gzfwrite() returns the number of full items written of size size, or zero
-   if there was an error.  If the multiplication of size and nitems overflows,
-   i.e. the product does not fit in a z_size_t, then nothing is written, zero
-   is returned, and the error state is set to Z_STREAM_ERROR.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or a negative zlib error code in case
-   of error.  The number of uncompressed bytes written is limited to 8191, or
-   one less than the buffer size given to gzbuffer().  The caller should assure
-   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
-   return an error (0) with nothing written.  In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf()
-   because the secure snprintf() or vsnprintf() functions were not available.
-   This can be determined using zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.  This is implemented as a macro for speed.
-   As such, it does not do all of the checking the other functions do.  I.e.
-   it does not check to see if file is NULL, nor whether the structure file
-   points to has been clobbered or not.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatenated gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-
-     When writing, gzdirect() returns true (1) if transparent writing was
-   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
-   gzdirect() is not needed when writing.  Transparent writing must be
-   explicitly requested, so the application already knows the answer.  When
-   linking statically, using gzdirect() will include all of the zlib code for
-   gzip file reading and decompression, which may not be desired.)
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
-   last read ended in the middle of a gzip stream, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-#endif /* !Z_SOLO */
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
-                                    z_size_t len));
-/*
-     Same as adler32(), but with a size_t length.
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the crc.  Pre- and post-conditioning (one's complement) is
-   performed within this function so it shouldn't be done by the application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-ZEXTERN uLong ZEXPORT crc32_z OF((uLong adler, const Bytef *buf,
-                                  z_size_t len));
-/*
-     Same as crc32(), but with a size_t length.
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#ifdef Z_PREFIX_SET
-#  define z_deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define z_inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#else
-#  define deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#endif
-
-#ifndef Z_SOLO
-
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#endif
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-#else /* Z_SOLO */
-
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-
-#endif /* !Z_SOLO */
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));
-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
-#if defined(_WIN32) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
-                                            const char *mode));
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
-                                                  const char *format,
-                                                  va_list va));
-#  endif
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
diff --git a/contrib/zlib/zlib.pc.cmakein b/contrib/zlib/zlib.pc.cmakein
deleted file mode 100644
index a5e642938..000000000
--- a/contrib/zlib/zlib.pc.cmakein
+++ /dev/null
@@ -1,13 +0,0 @@
-prefix=@CMAKE_INSTALL_PREFIX@
-exec_prefix=@CMAKE_INSTALL_PREFIX@
-libdir=@INSTALL_LIB_DIR@
-sharedlibdir=@INSTALL_LIB_DIR@
-includedir=@INSTALL_INC_DIR@
-
-Name: zlib
-Description: zlib compression library
-Version: @VERSION@
-
-Requires:
-Libs: -L${libdir} -L${sharedlibdir} -lz
-Cflags: -I${includedir}
diff --git a/contrib/zlib/zutil.c b/contrib/zlib/zutil.c
deleted file mode 100644
index dcab28a0d..000000000
--- a/contrib/zlib/zutil.c
+++ /dev/null
@@ -1,325 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2017 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zutil.h"
-#ifndef Z_SOLO
-#  include "gzguts.h"
-#endif
-
-z_const char * const z_errmsg[10] = {
-    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
-    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
-    (z_const char *)"",                    /* Z_OK              0  */
-    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
-    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
-    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
-    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
-    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
-    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
-    (z_const char *)""
-};
-
-
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-
-    flags = 0;
-    switch ((int)(sizeof(uInt))) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch ((int)(sizeof(uLong))) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch ((int)(sizeof(voidpf))) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch ((int)(sizeof(z_off_t))) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef ZLIB_DEBUG
-    flags += 1 << 8;
-#endif
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifdef NO_vsnprintf
-    flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#else
-    flags += 1L << 24;
-#  ifdef NO_snprintf
-    flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-
-#ifdef ZLIB_DEBUG
-#include <stdlib.h>
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int ZLIB_INTERNAL z_verbose = verbose;
-
-void ZLIB_INTERNAL z_error (m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-
-#if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
-    /* The older Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-
-#ifndef HAVE_MEMCPY
-
-void ZLIB_INTERNAL zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-
-int ZLIB_INTERNAL zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-
-void ZLIB_INTERNAL zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-
-#ifndef Z_SOLO
-
-#ifdef SYS16BIT
-
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-
-#define MAX_PTR 10
-/* 10*64K = 640K */
-
-local int next_ptr = 0;
-
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf;
-    ulg bsize = (ulg)items*size;
-
-    (void)opaque;
-
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    int n;
-
-    (void)opaque;
-
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    Assert(0, "zcfree: ptr not found");
-}
-
-#endif /* __TURBOC__ */
-
-
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
-{
-    (void)opaque;
-    return _halloc((long)items, size);
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    (void)opaque;
-    _hfree(ptr);
-}
-
-#endif /* M_I86 */
-
-#endif /* SYS16BIT */
-
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    (void)opaque;
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-
-void ZLIB_INTERNAL zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    (void)opaque;
-    free(ptr);
-}
-
-#endif /* MY_ZCALLOC */
-
-#endif /* !Z_SOLO */
diff --git a/contrib/zlib/zutil.h b/contrib/zlib/zutil.h
deleted file mode 100644
index 60a0bca79..000000000
--- a/contrib/zlib/zutil.h
+++ /dev/null
@@ -1,263 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZUTIL_H
-#define ZUTIL_H
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include "zlib.h"
-
-#if defined(STDC) && !defined(Z_SOLO)
-#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* since "static" is used to mean two completely different things in C, we
-   define "local" for the non-static meaning of "static", for readability
-   (compile with -Dlocal if your debugger can't find static symbols) */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  ifndef Z_SOLO
-#    if defined(__TURBOC__) || defined(__BORLANDC__)
-#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-         /* Allow compilation with ANSI keywords only enabled */
-         void _Cdecl farfree( void *block );
-         void *_Cdecl farmalloc( unsigned long nbytes );
-#      else
-#        include <alloc.h>
-#      endif
-#    else /* MSC or DJGPP */
-#      include <malloc.h>
-#    endif
-#  endif
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  1
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  2
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#ifdef __370__
-#  if __TARGET_LIB__ < 0x20000000
-#    define OS_CODE 4
-#  elif __TARGET_LIB__ < 0x40000000
-#    define OS_CODE 11
-#  else
-#    define OS_CODE 8
-#  endif
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  5
-#endif
-
-#ifdef OS2
-#  define OS_CODE  6
-#  if defined(M_I86) && !defined(Z_SOLO)
-#    include <malloc.h>
-#  endif
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  7
-#  ifndef Z_SOLO
-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#      include <unix.h> /* for fdopen */
-#    else
-#      ifndef fdopen
-#        define fdopen(fd,mode) NULL /* No fdopen() */
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef __acorn
-#  define OS_CODE 13
-#endif
-
-#if defined(WIN32) && !defined(__CYGWIN__)
-#  define OS_CODE  10
-#endif
-
-#ifdef _BEOS_
-#  define OS_CODE  16
-#endif
-
-#ifdef __TOS_OS400__
-#  define OS_CODE 18
-#endif
-
-#ifdef __APPLE__
-#  define OS_CODE 19
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-
-#if defined(__BORLANDC__) && !defined(MSDOS)
-  #pragma warn -8004
-  #pragma warn -8008
-  #pragma warn -8066
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_WIN32) && \
-    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#endif
-
-        /* common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  3     /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#if defined(pyr) || defined(Z_SOLO)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef ZLIB_DEBUG
-#  include <stdio.h>
-   extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-#ifndef Z_SOLO
-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
-                                    unsigned size));
-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
-#endif
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-/* Reverse the bytes in a 32-bit value */
-#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
-#endif /* ZUTIL_H */
diff --git a/tools/assimp_cmd/Main.h b/tools/assimp_cmd/Main.h
index 1d3dd8fb2..5a139a580 100644
--- a/tools/assimp_cmd/Main.h
+++ b/tools/assimp_cmd/Main.h
@@ -66,7 +66,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #endif
 
 #ifdef ASSIMP_BUILD_NO_OWN_ZLIB
-#include <zlib.h>
+#include <zlib/zlib.h>
 #else
 #include <../contrib/zlib/zlib.h>
 #endif
